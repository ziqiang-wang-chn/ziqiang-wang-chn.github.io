{"title":"Docker 基础","uid":"f1090bfedc2e663395ad1f45484947c5","slug":"docker/docker1","date":"2023-02-07T12:41:41.000Z","updated":"2023-02-14T12:41:18.510Z","comments":true,"path":"api/articles/docker/docker1.json","keywords":null,"cover":"/img/docker/docker-cover.png","content":"<h1 id=\"Ubuntu-安装\"><a href=\"#Ubuntu-安装\" class=\"headerlink\" title=\"Ubuntu 安装\"></a>Ubuntu 安装</h1><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">sudo apt-get update\nsudo apt-get install \\\n    ca-certificates \\\n    curl \\\n    gnupg \\\n    lsb-release\nsudo mkdir -p &#x2F;etc&#x2F;apt&#x2F;keyrings\ncurl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo gpg --dearmor -o &#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg\necho \\\n  &quot;deb [arch&#x3D;$(dpkg --print-architecture) signed-by&#x3D;&#x2F;etc&#x2F;apt&#x2F;keyrings&#x2F;docker.gpg] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \\\n  $(lsb_release -cs) stable&quot; | sudo tee &#x2F;etc&#x2F;apt&#x2F;sources.list.d&#x2F;docker.list &gt; &#x2F;dev&#x2F;null\nsudo apt-get update\nsudo apt-get install docker-ce docker-ce-cli containerd.io docker-buildx-plugin docker-compose-plugin\n\nsudo docker run hello-world</code></pre>\n<h2 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 不使用sudo\nsudo usermod -aG docker</code></pre>\n\n\n\n<h1 id=\"LXC\"><a href=\"#LXC\" class=\"headerlink\" title=\"LXC\"></a>LXC</h1><ul>\n<li>LXC就是基于 Linux内核通过调用 CGroups 和 Namespaces ，来实现容器轻量级虚拟化的项技术，与此同时，LXC也是一组面向 Liux 内核容器的用户态API接口。用户通过LXC提供的资源限制和隔离功能，可以创建一套完整并且相互隔离的虚拟应用运行环境。LXC是 Docker运行的基础，而 Docker 则是LXC的杀手级应用</li>\n</ul>\n<h2 id=\"CGroups\"><a href=\"#CGroups\" class=\"headerlink\" title=\"CGroups\"></a>CGroups</h2><ul>\n<li>CGroups 可以限制、记录、调整进程组所使用的物理资源。比如：使用 CGroups 可以给某项进程组多分配一些CPU使用周期。同样也可以通过CGroups 限制某项进程组可使用的内存上限,一旦达到上限，内核就会发出Out of Memory 错误。同时CGroups也具有记录物理资源使用情况的功能比如CGroups调用cpuacct 子系统就可以记录每个进程所使用的内存数量、CPU时间等数据。正因为Linux有了CGroups资源管理机制，内核虚拟化才变成了可能。</li>\n</ul>\n<h2 id=\"Namespaces\"><a href=\"#Namespaces\" class=\"headerlink\" title=\"Namespaces\"></a>Namespaces</h2><ul>\n<li>Namespaces 则是另外一个重要的资源隔离机制。Namespaces 将进程、进程组、IPC、网络、内存等资源都变得不再是全局性资源，而是将这些资源从内核层面属于某个特定的 Namespace。在不同的 Namespace 之间，这些资源是相互透明、不可见的。比如说，A 用户登录系统后，可以查看到B用户的进程PID。虽说A 用户不能杀死B 用户的进程，但A和B 却能相感知。但假如A用户在Namespace-A中，B用户在Namespace-B 中，虽然A和B仍然共存于同一个Linux 操作系统当中，但A却无法感知到B。在这种情况下，Linux内核不但将Namespace 相互隔离，而且将所分配的资源牢牢固定在各自空间之中。</li>\n</ul>\n<h1 id=\"AUFS\"><a href=\"#AUFS\" class=\"headerlink\" title=\"AUFS\"></a>AUFS</h1><ul>\n<li>AUFS 本质上是堆式的联合文件系统。AUFS 的功能简单说就是可以将分布在不同地方的目录挂载到同一个虚拟文件系统当中。<ul>\n<li>首先我们将思路切换到 Linux 启动阶段。典型的 Linux 启动时，首先加载 bootfs (Boot FileSystem)目录。这个目录里面包括 Bootloader和 kerenl。Bootloader 用来加载启动 kerenl。当kerenl成功加载到内存中后，bootfs 就会释放掉，kerenl随之开始加载rootfs。rootfs(Root File System)包含的是 Linux 系统中标准的&#x2F;dev、&#x2F;proc、&#x2F;bin、&#x2F;etc 等文件。因为rootfs是后续 kerenl启动的基础，对于 kerenl来说异常重要，因此此时 kerenl将 Rootfs 加锁，设为readonly。 在只读权限下，kerenl进行一系列的检查操作。当kerenl确认rootfs 包含的文件正确无误后，将readonly改为readwrite (可读可写)，以后用户就可以按照正确的权限对这些目录进行操作了。</li>\n<li>轮到到AUFS 登场了。当 Docker 利用LXC 虚拟化出来一个容器之后，就相当于购买了一台裸机，有内存、CPU、硬盘，但没有操作系统。Docker 参考 Linux 的启动过程，将一个readonly 权限的bootfs 挂载到容器文件系统中，然后通过AUFS，再将readonly权限的rootfs添加到 bootfs之上，当rootfs 检查完毕之后，再将用户所要使用的文件内容挂载到rootfs 之上，同样是readonly 权限。每次挂载一个FS 文件层，并且每层之间只会挂载增量 (在这里大家可以借助于SVN进行理解，相当每个FS层都是SVN提交上去的数据增量)。</li>\n<li>这些文件层就是堆栈式文件系统中所保存的数据。将不同的文件层挂载到同一个文件系统中的文件系统，就是联合文件系统。但是每个FS层都是readonly权限那么容器内部如何向这些文件写入数据呢？其实当Docker利用AUFS加载完最高一层之后，会在最上面再添加一个FS层而这个层是readwrite 权限。容器内部的应用，对当前文件系统所有的写操作(包括删除)都会保存在这个FS 层当中，而当容器向Docker发出commit命令后，Docker 会将这个FS层中的数据作为单独一个文件层保存到AUFS之中。而一个镜像 (image)就可以理解为：特定 FS 层的集合。所以可以看出镜像的层次关系，处于下层的image是上层image 的父类，而没有父类image的就是 baseimage。因此需要从image启动container时，Docker 会依次加载 baseimage 和父类image，而用户所有的操作就都保存在最高层的readwrite的layer中。</li>\n<li>通过将镜像“分隔”为 AUFS 的文件层，使得所有容器都可以共享文件层，且不会发生写冲突。但在 Docker 中，所有的镜像都是只读的，所有的镜像也都不保存用户信息，只会用于新建和复制。而对于容器而言，其所看到的所有文件都是可读写的，只不过所有的写操作都被保存在最上层的文件层当中。</li>\n<li>Docker 正是通过 AUFS 的这些特性，解决了容器初始化和写时复制问题，所以 Docker 选择AUFS作为其第二个核心组件。</li>\n</ul>\n</li>\n<li>其他的文件系统的存储驱动包括overlay2，overlay，fuse-overlayfs\t，btrfs ，zfs，vfs，devicemapper。默认为overlay2。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>Docker storage drivers ：<a href=\"https://docs.docker.com/storage/storagedriver/select-storage-driver/\">https://docs.docker.com/storage/storagedriver/select-storage-driver/</a></p></blockquote>\n<h1 id=\"写时复制\"><a href=\"#写时复制\" class=\"headerlink\" title=\"写时复制\"></a>写时复制</h1><ul>\n<li>写时复制是Docker image之所以如此强大的一个重要原因。当父进程fok子进程时，内核并没有为子进程分配内存(当然基本的进程控制块、堆栈还是需要的)，而是让父子进程共享内存。当两者之一修改共享内存时，会触发一次缺页异常导致真正的内存分配。这样做既加速了子进程的创建速度，又减少了内存的消耗。Dockerimage使用写时复制也是为了达到相同目的：快和节省空间。</li>\n</ul>\n<h1 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.cnblogs.com/poloyy/p/13922325.html\">https://www.cnblogs.com/poloyy/p/13922325.html</a></p></blockquote>\n<h2 id=\"images操作\"><a href=\"#images操作\" class=\"headerlink\" title=\"images操作\"></a>images操作</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">qidai@qidai:~$ docker ps -a   # 将运行中或者退出的容器列出，没有-a参数，则只列出运行中的容器\nCONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES\nqidai@qidai:~$ docker search nginx  # 搜索相关容器\nNAME                                              DESCRIPTION                                     STARS     OFFICIAL   AUTOMATED\nnginx                                             Official build of Nginx.                        18075     [OK]       \nbitnami&#x2F;nginx                                     Bitnami nginx Docker Image                      150                  [OK]\nbitnami&#x2F;nginx-ingress-controller                  Bitnami Docker Image for NGINX Ingress Contr…   23                   [OK]\nubuntu&#x2F;nginx                                      Nginx, a high-performance reverse proxy &amp; we…   77                   \n...                \nqidai@qidai:~$ docker pull nginx   # 拉取容器，与search结果中的NAME对应\nUsing default tag: latest\nlatest: Pulling from library&#x2F;nginx\na2abf6c4d29d: Pull complete \na9edb18cadd1: Pull complete \n589b7251471a: Pull complete \n186b1aaa4aa6: Pull complete \nb4df32aa5a72: Pull complete \na0bcbecc962e: Pull complete \nDigest: sha256:0d17b565c37bcbd895e9d92315a05c1c3c9a29f762b011a10c54a66cd53c9b31\nStatus: Downloaded newer image for nginx:latest\ndocker.io&#x2F;library&#x2F;nginx:latest\nqidai@qidai:~$ docker images   # 列出本地的镜像\nREPOSITORY   TAG       IMAGE ID       CREATED         SIZE\nnginx        latest    605c77e624dd   13 months ago   141MB\nubuntu       latest    ba6acccedd29   16 months ago   72.8MB</code></pre>\n\n<h2 id=\"RUN\"><a href=\"#RUN\" class=\"headerlink\" title=\"RUN\"></a>RUN</h2><ul>\n<li>可以指定容器的DNS，内存，CPU等一系列限制参数。<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 运行一个容器，--name 其名字为nginx-ohbug，基于本地镜像nginx进行，-p 将主机的8080端口与容器内部80映射，\n# -d 后台守护， -v 指示将本机当前目录映射到 容器内部的 &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps 目录\n# --restart 指定容器总是运行，当物理主机重启后docker服务开启后，则此容器自动启动\nqidai@qidai:~$ docker run --name nginx-ohbug -p 8080:80 -d -v .:&#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps --restart always nginx\n6071784b8087292a9d1c9d72e8fecf531631baf6f8cd9107751bae0c9cd96b57\nqidai@qidai:~$ docker ps  # 查看正在运行中的容器\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS                                   NAMES\n6071784b8087   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   41 seconds ago   Up 39 seconds   0.0.0.0:8080-&gt;80&#x2F;tcp, :::8080-&gt;80&#x2F;tcp   nginx-ohbug\nqidai@qidai:~$ ls   # 物理机当前目录无文件\nqidai@qidai:~$ docker exec nginx-ohbug ls &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps  # 容器映射目录无文件\nqidai@qidai:~$ touch test.c  # 物理机当前目录创建文件\nqidai@qidai:~$ docker exec nginx-ohbug ls &#x2F;usr&#x2F;local&#x2F;tomcat&#x2F;webapps  # 容器映射目录同步文件\ntest.c</code></pre></li>\n<li><code>--restart</code>：可选 <code>always</code> ，<code>on-failure:次数</code>，<code>unless-stopped</code><ul>\n<li><code>always</code>：总是启动。</li>\n<li><code>on-failure:3</code>：自动尝试三次重启。</li>\n<li><code>unless-stopped</code>：在容器退出时总是重启，但不考虑Docker守护进程启动时就已经停止的容器。</li>\n<li><code>no</code>：默认，容器退出后不重启。</li>\n</ul>\n</li>\n<li><code>-p</code> 格式：可选<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker run -p ip:主机端口:容器端口\ndocker run -p 主机端口:容器端口\ndocker run -p 容器端口</code></pre>\n<hr/></li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># -i STDIN输入模式 ，  -t 伪终端tty ， 执行命令 bash\nqidai@qidai:~$ docker run -it --name nginx-ohbug nginx bash\nroot@cae357bf36e1:&#x2F;#       # 已经进入tty\nroot@cae357bf36e1:&#x2F;# \nroot@cae357bf36            # ctrl+p+q，可以不将容器关闭而退出容器，若为exit，则退出后容器停止运行\nqidai@qidai:~$ docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES\ncae357bf36e1   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   17 seconds ago   Up 17 seconds   80&#x2F;tcp    nginx-ohbug\n# --privileged&#x3D;true 拥有root权限，-u root 指定进入容器的身份\nqidai@qidai:~$ docker run -it --privileged&#x3D;true -u root --name nginx-ohbugs nginx bash</code></pre>\n<ul>\n<li>其他参数可以通过 <code>docker run --help</code>查看。</li>\n</ul>\n<h2 id=\"start-x2F-restart-x2F-stop\"><a href=\"#start-x2F-restart-x2F-stop\" class=\"headerlink\" title=\"start&#x2F;restart&#x2F;stop\"></a>start&#x2F;restart&#x2F;stop</h2><pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker start $(docker ps -a -q)  # 启动所有容器  -q参数是只列出容器id\ndocker restart $(docker ps -a -q)  # 重新启动所有容器  -q参数是只列出容器id\ndocker stop $(docker ps -a -q)  # 停止所有容器  -q参数是只列出容器id</code></pre>\n\n\n<h2 id=\"exec\"><a href=\"#exec\" class=\"headerlink\" title=\"exec\"></a>exec</h2><ul>\n<li>在正在运行的容器中运行命令。<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">qidai@qidai:~$ docker run -d --name nginx-ohbug   nginx \n6be309269bd46614b529f5a65d613e8e7876a69c5e002f783c99db03d0d61988\nqidai@qidai:~$ docker ps\nCONTAINER ID   IMAGE     COMMAND                  CREATED         STATUS         PORTS     NAMES\n6be309269bd4   nginx     &quot;&#x2F;docker-entrypoint.…&quot;   8 seconds ago   Up 7 seconds   80&#x2F;tcp    nginx-ohbu\n# -w 指定工作目录， -u 指定用户角色，  -e 新增环境变量， 执行输出环境变量的任务。\nqidai@qidai:~$ docker exec -u root  -w &#x2F;usr -e website&#x3D;ohbug.cn nginx-ohbug sh -c &#39;echo $website&#39;\nohbug.cn\nqidai@qidai:~$ docker exec -it nginx-ohbug bash\nroot@6be309269bd4:&#x2F;#\n\n# 区别\n# 进入当前容器后开启一个新的终端，可以在里面操作。（常用）\n# docker exec \n# 进入容器正在执行某个命令的终端，不能在里面操作\n# docker attach </code></pre></li>\n</ul>\n<h2 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h2><ul>\n<li>在容器和主机之间复制文件&#x2F;文件夹。<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">docker cp [OPTIONS] CONTAINER:SRC_PATH DEST_PATH|-\ndocker cp [OPTIONS] SRC_PATH|- CONTAINER:DEST_PATH\n# 该命令会假定容器路径相对于容器的 &#x2F;（根）目录\n# 而主机路径则是相对于执行 docker cp 命令的当前目录</code></pre></li>\n<li><code>SRC_PATH</code> 指定一个文件，<ul>\n<li>若 <code>DEST_PATH</code> 不存在，创建 <code>DEST_PATH</code> 所需的文件夹，文件正常保存到 <code>DEST_PATH</code> 中。</li>\n<li>若 <code>DEST_PATH</code> 不存在，并以 <code>/</code> 结尾，错误：目标目录必须存在。</li>\n<li>若 <code>DEST_PATH</code> 存在并且是一个文件，目标被源文件的内容覆盖。</li>\n<li>若 <code>DEST_PATH</code> 存在并且是目录，使用 <code>SRC_PATH</code> 中的基本名称将文件复制到此目录中。</li>\n</ul>\n</li>\n<li><code>SRC_PATH</code> 指定目录<ul>\n<li>若 <code>DEST_PATH</code> 不存在，将 <code>DEST_PATH</code> 创建为目录，并将源目录的内容复制到该目录中。</li>\n<li>若 <code>DEST_PATH</code> 存在并且是一个文件，错误：无法将目录复制到文件。</li>\n<li>若 <code>DEST_PATH</code> 存在并且是目录，<code>SRC_PATH</code> 不以 <code>/. </code>结尾，源目录复制到此目录，<code>SRC_PATH</code> 以 <code>/.</code> 结尾，源目录的内容被复制到该目录中。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Dockerfile\"><a href=\"#Dockerfile\" class=\"headerlink\" title=\"Dockerfile\"></a>Dockerfile</h1><ul>\n<li>Dockerfile中命令不区分大小写，但是大写是约定，更容易区分。格式为 <code>命令 参数...</code>。命令顺序执行，必须以FROM 开头.</li>\n<li><code>FROM</code> : 若使用多个镜像，则需要使用多个<code>FROM</code>。意思就是之后的构建命令基于哪个镜像进行构建。<code>FROM</code>前面只能有一个或多个<code>ARG</code>指令，这些指令声明Dockerfile中<code>FROM</code>行中使用的参数。多个 FROM 会产生多个 images，但是只有最后一个image有id值，其余的image只作为中间构建过程并无 id。</li>\n<li>MAINTAINER：作者信息。</li>\n<li>LABELS：其他信息。</li>\n<li>RUN：RUN指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定<code>--no-cache</code>参数，如：<code>docker build --no-cache</code>。尽量将指令放入一个RUN中进行，因为RUN一次就多一层。最多126层。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># &#x2F;bin&#x2F;sh -c来执行，直接可以使用Linux中的命令\nRUN &lt;command&gt;\n# 可以执行基础镜像中任意二进制程序，用exec执行：例如 RUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo xx&quot;]\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\n\n# 输出环境变量。而 [&quot;echo&quot;, &quot;$HOME&quot;]是获取不到的。\nRUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;]</code></pre>\n\n<ul>\n<li>CMD：每个Dockerfile都只能有一个CMD指令 ，在启动容器时执行，若用户指定了运行的命令，则CMD被覆盖失效。CMD不同于RUN，CMD用于指定在容器启动时所要执行的命令，而RUN用于指定镜像构建时所要执行的命令。</li>\n</ul>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># exec 格式\nCMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]\n# 则直接调用ENTRYPOINT添加参数\nCMD [&quot;param1&quot;,&quot;param2&quot;] \n# &#x2F;bin&#x2F;sh 提供给需要交互的应用，shell内部命令\nCMD command param1 param2</code></pre>\n\n<ul>\n<li>ENTRYPOINT：ENTRYPOINT与CMD非常类似，不同的是通过docker run执行的命令不会覆盖ENTRYPOINT，<br>  而docker run命令中指定的任何参数，都会被当做参数再次传递给ENTRYPOINT。<br>  Dockerfile中只允许有一个ENTRYPOINT命令</li>\n</ul>\n","abstracts":"其中涉及到的概念，基本命令。","text":"其中涉及到的概念，基本命令。","link":"","photos":[],"count_time":{"symbolsCount":"9.7k","symbolsTime":"9 mins."},"categories":[{"name":"Docker","slug":"Docker","count":4,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":4,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Ubuntu-%E5%AE%89%E8%A3%85\"><span class=\"toc-text\">Ubuntu 安装</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%85%8D%E7%BD%AE\"><span class=\"toc-text\">配置</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#LXC\"><span class=\"toc-text\">LXC</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#CGroups\"><span class=\"toc-text\">CGroups</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Namespaces\"><span class=\"toc-text\">Namespaces</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#AUFS\"><span class=\"toc-text\">AUFS</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%99%E6%97%B6%E5%A4%8D%E5%88%B6\"><span class=\"toc-text\">写时复制</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">基础命令</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#images%E6%93%8D%E4%BD%9C\"><span class=\"toc-text\">images操作</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#RUN\"><span class=\"toc-text\">RUN</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#start-x2F-restart-x2F-stop\"><span class=\"toc-text\">start&#x2F;restart&#x2F;stop</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#exec\"><span class=\"toc-text\">exec</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#cp\"><span class=\"toc-text\">cp</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Dockerfile\"><span class=\"toc-text\">Dockerfile</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Spring6-AOP","uid":"30fb76edd6cb328c4c2c75f78ac58f78","slug":"spring/spring6-4","date":"2023-02-08T02:31:46.000Z","updated":"2023-02-08T07:46:36.424Z","comments":true,"path":"api/articles/spring/spring6-4.json","keywords":null,"cover":"/img/spring/OG-Spring.png","text":"AOP概念及注解使用。","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/categories/Spring6.json"}],"tags":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/tags/Spring6.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Spring6-IoC注解开发","uid":"9db447d066a0b58da846388fb136c7b5","slug":"spring/spring6-3","date":"2023-02-07T12:41:41.000Z","updated":"2023-02-07T16:28:18.761Z","comments":true,"path":"api/articles/spring/spring6-3.json","keywords":null,"cover":"/img/spring/OG-Spring.png","text":"IoC中的注解使用。","link":"","photos":[],"count_time":{"symbolsCount":"7.4k","symbolsTime":"7 mins."},"categories":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/categories/Spring6.json"}],"tags":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/tags/Spring6.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}