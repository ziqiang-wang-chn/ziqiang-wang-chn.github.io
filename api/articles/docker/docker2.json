{"title":"Dockerfile","uid":"75603112ad785d198fb30f0b34b1d632","slug":"docker/docker2","date":"2023-02-13T14:27:41.000Z","updated":"2023-02-14T09:11:19.572Z","comments":true,"path":"api/articles/docker/docker2.json","keywords":null,"cover":"/img/docker/docker-cover.png","content":"<p><img src=\"/img/docker/docker-command.png\" alt=\"picture 1\">  </p>\n<h1 id=\"基础指令\"><a href=\"#基础指令\" class=\"headerlink\" title=\"基础指令\"></a>基础指令</h1><ul>\n<li><p>Dockerfile中命令不区分大小写，但是大写是约定，更容易区分。格式为 <code>命令 参数...</code>。命令顺序执行，必须以 <code>FROM</code> 开头.</p>\n</li>\n<li><p><code>FROM</code> : 若使用多个镜像，则需要使用多个<code>FROM</code>。意思就是之后的构建命令基于哪个镜像进行构建。<code>FROM</code>前面只能有一个或多个<code>ARG</code>指令，这些指令声明Dockerfile中<code>FROM</code>行中使用的参数。多个 <code>FROM</code> 会产生多个 images，但是只有最后一个image有id值，其余的image只作为中间构建过程并无 id。</p>\n</li>\n<li><p><code>MAINTAINER</code> ：作者信息。</p>\n</li>\n<li><p><code>LABELS</code> ：其他信息。</p>\n</li>\n<li><p><code>RUN</code> ：<code>RUN</code> 指令创建的中间镜像会被缓存，并会在下次构建中使用。如果不想使用这些缓存镜像，可以在构建时指定<code>--no-cache</code>参数，如：<code>docker build --no-cache</code>。尽量将指令放入一个<code>RUN</code>中进行，因为<code>RUN</code>一次就多一层。最多126层。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># &#x2F;bin&#x2F;sh -c来执行，直接可以使用Linux中的命令\nRUN &lt;command&gt;\n# 可以执行基础镜像中任意二进制程序，用exec执行：例如 RUN [&quot;&#x2F;bin&#x2F;bash&quot;, &quot;-c&quot;, &quot;echo xx&quot;]\nRUN [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]\n# 输出环境变量。而 [&quot;echo&quot;, &quot;$HOME&quot;]是获取不到的。\nRUN [&quot;sh&quot;, &quot;-c&quot;, &quot;echo&quot;, &quot;$HOME&quot;]</code></pre>\n</li>\n<li><p><code>CMD</code> ：每个Dockerfile都只能有一个<code>CMD</code>指令 ，在启动容器时执行，若用户指定了运行的命令，则<code>CMD</code>被覆盖，只有最后一个<code>CMD</code>生效。<code>CMD</code>不同于<code>RUN</code>，<code>CMD</code>用于指定在容器启动时所要执行的命令，而<code>RUN</code>用于指定镜像构建时所要执行的命令。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># exec 格式\nCMD [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]\n# 则直接作为ENTRYPOINT参数\nCMD [&quot;param1&quot;,&quot;param2&quot;] \n# &#x2F;bin&#x2F;sh 提供给需要交互的应用，shell内部命令\nCMD command param1 param2</code></pre>\n</li>\n<li><p><code>LABEL</code> ：同样是会产生文件层，所以建议放到一行执行。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">LABEL &lt;KEY&gt;&#x3D;&lt;VAL&gt; ...</code></pre>\n</li>\n<li><p><code>EXPOSE</code> ：当容器运行时，来通知 Docker 这个容器中哪些端口是应用程序用来监听的。但是使用 <code>EXPOSE</code> 命令不等同于这些端口就可以被外部网络访问。只有在容器启动时，配合<code>-p</code>或者<code>-P</code>，外部网络才可以访问到这些端口。如果没有使用<code>-p</code> 或者<code>-P</code>，那么这些端口只能被主机中的其他容器访问，无法被外部网络所访问到。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">EXPOSE &lt;PORT&gt; ...</code></pre>\n</li>\n<li><p><code>ENV</code> ： 设定环境变量。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ENV &lt;KEY&gt;&#x3D;&lt;VAL&gt; ...</code></pre>\n</li>\n<li><p><code>ADD</code> ： 将 <code>src</code> 标记的路径添加到容器中的<code>dest</code>目录中去。<code>src</code> 可以是本地目录，也可以是网络地址，本地目录必须是再 <code>Dockerfile</code> 文件所在目录。<code>src</code> 中可以使用通配符。<code>dest </code>中不允许通配符，其路径必须是绝对路径，或者相对于<code> WORKDIR</code> 路径。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">ADD &lt;src&gt; ... &lt;dest&gt;</code></pre>\n</li>\n<li><p><code>COPY</code>：同<code>ADD</code> 一样。但是 ADD 有自动解压缩的功能。</p>\n</li>\n<li><p><code>ENTRYPOINT</code> ：<code>ENTRYPOINT</code> 与 <code>CMD</code> 非常类似，不同的是通过<code>docker run</code>执行的命令不会覆盖<code>ENTRYPOINT</code>，而<code>docker run</code>命令中指定的任何参数，都会被当做参数再次传递给 <code>ENTRYPOINT</code> 。Dockerfile中只允许有一个<code>ENTRYPOINT</code>命令。</p>\n</li>\n<li><p><code>VOLUME</code> ：在容器内部创建一个挂载点。一般在  Dockerfile 结尾处声明挂载点。一般用在共享目录功能。</p>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">VOLUME [&quot;&#x2F;data&quot;]</code></pre>\n</li>\n<li><p><code>USER</code> ： 切换用户身份。</p>\n</li>\n<li><p><code>WORKDIR</code> ： 切换当前工作目录，影响到后续的<code>RUN</code>、<code>CMD</code>、<code>ENTRYPOINT</code>、<code>COPY</code>和<code>ADD</code>指令中的路径。</p>\n</li>\n<li><p><code>ONBUILD</code> ： <code>ONBUILD</code>是用来创建触发命令集的命令。由<code>ONBUILD</code> 创建的触发命令集在当前 Dockerfile执行过程中不会执行，而当此镜像被其他镜像当作基础镜像使用时，将会被触发执行。只要是在Dockerfile中属于合法的内置命令，都可以在此设定。</p>\n</li>\n</ul>\n<h1 id=\"最佳实践\"><a href=\"#最佳实践\" class=\"headerlink\" title=\"最佳实践\"></a>最佳实践</h1><ul>\n<li>短小精悍：镜像寻求单服务，不要追求大而全。一个容器只运行一种服务。不安装不必要的软件包</li>\n<li><code>.Dockerignore</code>：使用 <code>ADD</code> 或者 <code>COPY</code> 指令时，可以将目录中的不需要的文件加入 <code>.Dockerignore</code> 文件中，进行过滤掉。<code>.Dockerignore</code> 需要放在 Dockerfile 目录中。在<code>.Dockerignore</code> 文件中，后面的规则将覆盖上面的规则。<br><img src=\"/img/docker/Dockerignore.png\" alt=\"picture 2\">  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 首先不过滤 license.md 文件，之后过滤掉所有文件，最终结果所有md文件都被忽略\n!license.md\n*.md\n# -------------\n# 忽略所有md文件，之后除了 license.md 之外，最终结果只有 license.md 文件没有被忽略掉。\n*.md\n!license.md</code></pre></li>\n<li>控制文件层数：比如之前提到的 RUN 应写成一行等。</li>\n</ul>\n","feature":true,"abstracts":"Dockerfile知识总结","text":"Dockerfile知识总结","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Docker","slug":"Docker","count":3,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":3,"path":"api/tags/Docker.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4\"><span class=\"toc-text\">基础指令</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5\"><span class=\"toc-text\">最佳实践</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Docker 网络","uid":"ee6d2c39692a2e32a317cb32fe1cabc5","slug":"docker/docker3","date":"2023-02-14T12:55:41.000Z","updated":"2023-02-14T15:10:35.243Z","comments":true,"path":"api/articles/docker/docker3.json","keywords":null,"cover":"/img/docker/docker-cover.png","text":"Docker 网络知识","link":"","photos":[],"count_time":{"symbolsCount":"3.4k","symbolsTime":"3 mins."},"categories":[{"name":"Docker","slug":"Docker","count":3,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":3,"path":"api/tags/Docker.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true},"next_post":{"title":"Java复习篇：抽象类，String，枚举","uid":"4a3de2f382252848e66f9fb50dc1dbc0","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","updated":"2023-02-02T10:10:38.637Z","comments":true,"path":"api/articles/java/basic/basicjava3.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":7,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true}}