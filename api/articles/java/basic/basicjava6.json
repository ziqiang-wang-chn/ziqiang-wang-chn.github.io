{"title":"Java复习篇：Map源码实现","uid":"cfeb076eceaa089663cf2e1f4248e9ee","slug":"java/basic/basicjava6","date":"2023-01-29T01:56:01.000Z","updated":"2023-02-03T02:26:10.991Z","comments":true,"path":"api/articles/java/basic/basicjava6.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<p><img src=\"/img/java/CollectionClassMap-Map.png\"></p>\n<ul>\n<li>紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。</li>\n<li>下面进行实现类的源码分析，主要是分析其实现类的主要功能。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>对于红黑树的原理可以参考本博客中文章  <a href=\"datastructure/redblacktree-avl\">《红黑树 VS AVL》</a><br><a href=\"https://www.pdai.tech/md/java/collection/java-map-HashMap&HashSet.html\">https://www.pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html</a><br><a href=\"https://www.bilibili.com/video/BV1ST411o7GR/?p=6&spm_id_from=pageDriver&vd_source=e1294f8209fc39ec6e458c23cce6613f\">https://www.bilibili.com/video/BV1ST411o7GR/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=e1294f8209fc39ec6e458c23cce6613f</a></p></blockquote>\n<h1 id=\"HashMap\"><a href=\"#HashMap\" class=\"headerlink\" title=\"HashMap\"></a>HashMap</h1><h2 id=\"移位运算\"><a href=\"#移位运算\" class=\"headerlink\" title=\"移位运算\"></a>移位运算</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">A&gt;&gt;1;   &#x2F;&#x2F; 相当于A&#x2F;2，高位正数补零，负数补一\nA&lt;&lt;1;   &#x2F;&#x2F;相当于A*2，高位移出，低位的空位补零\nA&gt;&gt;&gt;1； &#x2F;&#x2F;无符号右移，只使用 0 进行补位</code></pre>\n<h2 id=\"散列表\"><a href=\"#散列表\" class=\"headerlink\" title=\"散列表\"></a>散列表</h2><ul>\n<li>即一个元素通过一个function可以得出对应的的散列值，但不同的元素也可能得到相同的散列值。是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。</li>\n<li>把关键字称为 Key，记录称为 Value，通过 Key 访问一个function来得到 Value 的地址。而这个function，也叫作散列函数或者哈希函数，存放记录的数组叫作散列表。</li>\n<li>当发生两个key产生了同一个散列值时，此时发生hash碰撞，解决办法就是拉链法，即如图通过链表的方式将发生冲突的元素都连接起来。HashMap就是采用这一方法解决hash冲突，但是如果当冲突非常多，那么链表会越来越长，则效率变差，此时HashMap中定义了一个值，当链表长度超过此值且满足一定条件时，将链表转化为红黑树。</li>\n</ul>\n<p><img src=\"/img/java/hashmapfuncation.png\"></p>\n<h2 id=\"HashMap结构\"><a href=\"#HashMap结构\" class=\"headerlink\" title=\"HashMap结构\"></a>HashMap结构</h2><p><img src=\"/img/java/java-collection-hashmap8.png\"></p>\n<ul>\n<li><p>Map的实现基于数组+链表+红黑树结构。每一个数组被称为一个bin，每一个bin里面可能连接着链表或者红黑树结构。</p>\n</li>\n<li><p>数组的源码定义，从此看出Map的实现基于Node类型的数组。</p>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">transient Node&lt;K,V&gt;[] table;</code></pre>\n\n<ul>\n<li>链表的源码定义</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n    final int hash;\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n&#125;</code></pre>\n\n\n<ul>\n<li>红黑树的源码定义为</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;\n    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links\n    TreeNode&lt;K,V&gt; left;\n    TreeNode&lt;K,V&gt; right;\n    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion+\n    boolean red;\n    ...\n&#125;</code></pre>\n\n<h2 id=\"内部变量\"><a href=\"#内部变量\" class=\"headerlink\" title=\"内部变量\"></a>内部变量</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;**\n * 默认容量\n *&#x2F;\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n&#x2F;**\n * 最大容量\n *&#x2F;\nstatic final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;\n&#x2F;**\n * 负载因子，当数组的容量达到总容量的百分之七十五时，则map就需要考虑扩容了\n *&#x2F;\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n&#x2F;**\n * 树化阈值，当一个bin中的链表元素个数超过8时才具备链表转红黑树的条件。\n *&#x2F;\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;\n&#x2F;**\n * 红黑树退化为链表的阈值\n *&#x2F;\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;\n&#x2F;**\n * 整个bin的数量达到64个且链表长度达到8个后才具备转换红黑树的条件\n * TREEIFY_THRESHOLD 和 MIN_TREEIFY_CAPACITY 两个变量是同时具备才可以\n * 这样可以避免因为数组容量太小以至于都hash计算到一个bin中，若bin都64个了且链表\n * 还是大于8个长，那么就说明了不是因为数组太小导致的hash冲突\n *&#x2F;\nstatic final int MIN_TREEIFY_CAPACITY &#x3D; 64;\n\n</code></pre>\n\n<h2 id=\"构造方法\"><a href=\"#构造方法\" class=\"headerlink\" title=\"构造方法\"></a>构造方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> &#x2F;**\n  * 默认的初始化16容量和0.75的负载因子\n  *&#x2F;\n public HashMap() &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted\n &#125;\n&#x2F;**\n  * 指定初始化容量，默认负载因子0.75\n  *&#x2F;\n public HashMap(int initialCapacity) &#123;\n     this(initialCapacity, DEFAULT_LOAD_FACTOR);\n &#125;\n&#x2F;**\n  * 可指定默认初始化容量和负载因子\n  *&#x2F;\n public HashMap(int initialCapacity, float loadFactor) &#123;\n     &#x2F;&#x2F; 参数检查开始\n     if (initialCapacity &lt; 0)\n         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                            initialCapacity);\n     if (initialCapacity &gt; MAXIMUM_CAPACITY)\n         initialCapacity &#x3D; MAXIMUM_CAPACITY;\n     if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                            loadFactor);\n     &#x2F;&#x2F; 参数检查结束\n     &#x2F;&#x2F; 指定的负载因子\n     this.loadFactor &#x3D; loadFactor;\n     &#x2F;&#x2F; threshold &#x3D; capacity * load factor，即直接算出来了下次数组达到多大的时候进行扩容。\n     this.threshold &#x3D; tableSizeFor(initialCapacity);\n &#125;\n &#x2F;**\n  *&#x2F;\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);\n &#125;</code></pre>\n\n<ul>\n<li>其中的<code>putMapEntries</code>方法一会分析，现在来分析一下<code>tableSizeFor</code>。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\"> &#x2F;**\n  * 返回大于cap的最小2的幂次方数，比如给定cap&#x3D;12，返回16，给定5返回8，返回结果始终是2的幂次方\n  * 原理： 因为2的幂次方的二进制都是高位为1，其余位都是0。比如cap&#x3D;100，tableSizeFor应返回128\n  * cap &#x3D; 0000 0000 0000 0000 0000 0000 0110 0100     numberOfLeadingZeros返回25\n  *  -1&#x3D;  10000 0000 0000 0000 0000 0000 0000 0001    无条件&gt;&gt;&gt;25\n  * res:  0000 0000 0000 0000 0000 0000 1000 0000      128\n  *\n  * 旧版HashMap.tableSizeFor的参考文章：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiyixiaodao&#x2F;p&#x2F;14483876.html\n  *&#x2F;\n static final int tableSizeFor(int cap) &#123;\n     &#x2F;&#x2F; 返回无符号整形i的最高非零位前面的0的个数，包括符号位在内\n     &#x2F;&#x2F; cap-1是防止出现cap已经是2的次方数了\n     int n &#x3D; -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);\n     &#x2F;&#x2F; 小于0即cap为负数，负数返回1，否则只要不超过 最大容量 都会返回n+1\n     return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n &#125;\n&#x2F;**\n  *  返回无符号整形i的最高非零位前面的0的个数，包括符号位在内。\n  *&#x2F;\n public static int numberOfLeadingZeros(int i) &#123;\n     &#x2F;&#x2F; HD, Count leading 0&#39;s\n     &#x2F;&#x2F; 若为0或负数，\n     if (i &lt;&#x3D; 0)\n         &#x2F;&#x2F; 0的所有位都是0，所以返回32位，若i为负数，负数的二进制位的最高位已经是1了，所以返回0；\n         return i &#x3D;&#x3D; 0 ? 32 : 0;\n     int n &#x3D; 31;\n     &#x2F;**\n      * 举例子  i&#x3D;65537\n      *     7: 0000 0000 0000 0001 0000 0000 0000 0001\n      * 1&lt;&lt;16: 0000 0000 0000 0001 0000 0000 0000 0000\n      * 1&lt;&lt;8 : 0000 0000 0000 0000 0000 0001 0000 0000\n      * 1&lt;&lt;4 : 0000 0000 0000 0000 0000 0000 0001 0000\n      * 1&lt;&lt;2 : 0000 0000 0000 0000 0000 0000 0000 0100\n      *\n      * 其中：i &gt;&#x3D; 1 &lt;&lt; 16 ，因为1&lt;&lt;16的高16位有1，若i&gt;1&lt;&lt;16，则i的高十六位一定也有1\n      *      i &gt;&#x3D; 1 &lt;&lt; 16，  满足，则n&#x3D;15，i&#x3D;0000 0000 0000 0000 0000 0000 0000 0001&#x3D;1\n      *      i &gt;&#x3D; 1 &lt;&lt;  8，不满足\n      *      i &gt;&#x3D; 1 &lt;&lt;  4，不满足\n      *      i &gt;&#x3D; 1 &lt;&lt;  2，不满足\n      *      return 15-0\n      *&#x2F;\n     &#x2F;&#x2F;如果高16位有1，那么n减半（二分查找的核心），i无符号右移16位，保留高16位\n     if (i &gt;&#x3D; 1 &lt;&lt; 16) &#123; n -&#x3D; 16; i &gt;&gt;&gt;&#x3D; 16; &#125;\n     &#x2F;&#x2F;到这里，如果前面一步false，那么高16位都是0；如果上面一步true，那么只有16位了。\n     &#x2F;&#x2F;如果高8位有1，那么n减半（二分查找的核心），i无符号右移8位，保留高8位\n     if (i &gt;&#x3D; 1 &lt;&lt;  8) &#123; n -&#x3D;  8; i &gt;&gt;&gt;&#x3D;  8; &#125;\n     &#x2F;&#x2F;如果高4位有1，那么n减半（二分查找的核心），i无符号右移4位，保留高4位\n     if (i &gt;&#x3D; 1 &lt;&lt;  4) &#123; n -&#x3D;  4; i &gt;&gt;&gt;&#x3D;  4; &#125;\n     &#x2F;&#x2F;如果高2位有1，那么n减半（二分查找的核心），i无符号右移2位，保留高2位\n     if (i &gt;&#x3D; 1 &lt;&lt;  2) &#123; n -&#x3D;  2; i &gt;&gt;&gt;&#x3D;  2; &#125;\n     return n - (i &gt;&gt;&gt; 1);\n &#125;</code></pre>\n\n<ul>\n<li>由此看出<code>tablesizeFor</code>的实现最关键的是得到一个数字的高位0的个数，通过对负一移位来实现的。</li>\n</ul>\n<h2 id=\"Put方法\"><a href=\"#Put方法\" class=\"headerlink\" title=\"Put方法\"></a>Put方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n&#x2F;**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don&#39;t change existing value\n * @param evict if false, the table is in creation mode. 只有在构造方法执行的时候，才会传入false为构造模式\n * @return previous value, or null if none\n * 从方法也可以看出来，若put替换value是不增加modCount的。\n *&#x2F;\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;\n    &#x2F;&#x2F; tab 保存之前的数组引用，p指向当前要操作的位置上的元素，n&#x3D; tab.length，i遍历下标\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    &#x2F;&#x2F; 如果表为空\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        &#x2F;&#x2F; 表进行扩容初始化\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 到这表示表不为空，但是hash计算出来的结果映射到的数组下标位置上没有元素\n    &#x2F;&#x2F; (n - 1) &amp; hash，n为表长为2的次方数，只有(n - 1) &amp; hash这样才可以将hash均匀的分配到数组中，\n    &#x2F;&#x2F; 也是通过这种方式进行查位于哪个数组的\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)\n        &#x2F;&#x2F; 则直接赋值\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;\n        &#x2F;&#x2F; 到这表示表不为空，且位置上有元素\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 如果此位置上就是要put的key\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            &#x2F;&#x2F; 暂存\n            e &#x3D; p;\n        &#x2F;&#x2F; 此位置上第一个与要put的key不匹配，且已经是红黑树了\n        else if (p instanceof TreeNode)\n            &#x2F;&#x2F; 执行红黑树的操作\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 即不是红黑树也不是单个元素，则只剩下链表的情况，遍历寻找\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; e已经保存了此位置上第一个元素的引用，判断是否还有下一个元素\n                &#x2F;&#x2F; 之前已经排除了第一个元素就是put的key，则如果没有下一个就直接链接上新node\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;\n                    &#x2F;&#x2F; 链接上新node\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; 判断是否需要树化，binCount在遍历链表的时候已经算出目前位置有多少元素了\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F; 进行树化\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果遍历中找到了与put元素一样的key，则跳出\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    break;\n                &#x2F;&#x2F; 用于循环\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 前面break后，e的引用已经是指向了链表的末尾。 情况为要么后面没元素了要么就是现在就是put的元素key\n        &#x2F;&#x2F; 不为空的情况就是第二种：现在e就是与要put的元素key相同的元素\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            &#x2F;&#x2F; 保存旧值用于返回\n            V oldValue &#x3D; e.value;  \n            &#x2F;&#x2F; 是否替换\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;\n            &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法\n            afterNodeAccess(e);\n            return oldValue;&#x2F;&#x2F; 返回旧值\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 判断是否需要扩容\n    if (++size &gt; threshold)\n        resize();\n    &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法\n    afterNodeInsertion(evict);\n    return null;\n&#125;</code></pre>\n\n<h2 id=\"resize方法\"><a href=\"#resize方法\" class=\"headerlink\" title=\"resize方法\"></a>resize方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">final Node&lt;K,V&gt;[] resize() &#123;\n    &#x2F;&#x2F; 暂存旧引用\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    &#x2F;&#x2F; 对于初始化没有分配空间的情况，oldtab是空的，若不是空，则保存之前的容量\n    &#x2F;&#x2F; 之前的扩容阈值，达到这个阈值后考虑扩容\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    &#x2F;&#x2F; newCap扩容后的新容量，newThr扩容后的新阈值\n    int newCap, newThr &#x3D; 0;\n    &#x2F;&#x2F; 若之前有容量\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 已经比最大的容量还大\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            &#x2F;&#x2F; 当下次达到Integer.MAX_VALUE个元素后再扩容。\n            &#x2F;&#x2F; 目的是之前扩容阈值&#x3D;capacity*0.75，这样赋值最大值是将剩下的百分十25利用起来\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 未到最大容量而且小于最大容量，则新容量是旧容量的二倍，通过oldCap &lt;&lt; 1实现，\n        &#x2F;&#x2F; 且旧容量已经大于等于16，则下次扩容阈值是之前扩容阈值的二倍\n        &#x2F;&#x2F; 若不满足，代表map初始化的时候指定了初始化容量。容量小于16\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    &#x2F;&#x2F; 到这表示oldCap&#x3D;0,但是oldThr&gt;0；此时只有初始化时指定参数。oldThr&#x3D;threshold&#x3D;tablesizeFor\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        &#x2F;&#x2F; 将阈值直接当作新容量\n        newCap &#x3D; oldThr;\n    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults\n        &#x2F;&#x2F; 初始化时是默认的构造\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 如果是0，表示newThr在前面的代码中未被赋值，表示只满足else if (oldThr &gt; 0)情况。\n        &#x2F;&#x2F; 计算下次扩容阈值\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    &#x2F;&#x2F; 下面进行从旧数组将数组迁移到新数组的操作\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) &#x2F;&#x2F; 新容量数组\n    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    &#x2F;&#x2F; 如果之前的旧数组是空的话代表无元素可迁移，直接返回新数组引用即可。\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 循环旧数组中的元素\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            &#x2F;&#x2F; 若元素不为空\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                &#x2F;&#x2F; 为了方便垃圾回收\n                oldTab[j] &#x3D; null;\n                &#x2F;&#x2F; bin中仅有一个元素\n                if (e.next &#x3D;&#x3D; null)\n                    &#x2F;&#x2F; 映射到新数组中\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                &#x2F;&#x2F; 如果已经是树了，进行树的操作\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                &#x2F;&#x2F; 到这就是链表情况\n                else &#123; &#x2F;&#x2F; preserve order\n                    &#x2F;&#x2F; 若一个bin中有一条链表，那么在遍历此链表上的元素的时候，由于容量不一样了，所以需要对\n                    &#x2F;&#x2F; 元素进行重新的hash计算，则会出现有的元素hash后在新数组的位置与目前位置相同，有些元素\n                    &#x2F;&#x2F; 在hash后在新数组的位置是 原来旧数组的位置加上原来旧容量的长度\n                    &#x2F;&#x2F; 若下标不动的，则依次链接到loxxxx的链表上\n                    &#x2F;&#x2F; 下标动的，依次链接到hixxxx的链表上\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; e.hash &amp; oldCap 决定了链表上的元素的下标是不是动\n                        &#x2F;&#x2F; 因为oldCap都是2的次方，则高位为1，其余位为0\n                        &#x2F;&#x2F; 例如：\n                        &#x2F;&#x2F; oldCap &#x3D; 1 0000\n                        &#x2F;&#x2F; e.hash &#x3D; 1 1111   或\n                        &#x2F;&#x2F; e.hash &#x3D; 0 1111   \n                        &#x2F;&#x2F; 则通过与运算后，链表上的元素就被分为两个链表\n                        &#x2F;&#x2F; 下面就是拆分链表的逻辑\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 不为空，则有下标不动的元素链表，直接链接\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 不为空，则有下标移动的元素链表，连接到原来数组下标+旧容量的位置。\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;</code></pre>\n\n<h2 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n, hash; K k;\n    &#x2F;&#x2F; 若表不空，且key的hash位置不为空才继续\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; (hash &#x3D; hash(key))]) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 检查第一个元素是否匹配\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        &#x2F;&#x2F; 第一个元素不匹配\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            &#x2F;&#x2F; 从树中寻找\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            &#x2F;&#x2F; 否则遍历链表寻找\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;</code></pre>\n\n\n\n\n<h1 id=\"TreeMap\"><a href=\"#TreeMap\" class=\"headerlink\" title=\"TreeMap\"></a>TreeMap</h1><p>todo</p>\n","abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":3,"path":"api/tags/todo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#HashMap\"><span class=\"toc-text\">HashMap</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A7%BB%E4%BD%8D%E8%BF%90%E7%AE%97\"><span class=\"toc-text\">移位运算</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%95%A3%E5%88%97%E8%A1%A8\"><span class=\"toc-text\">散列表</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#HashMap%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">HashMap结构</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">内部变量</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">构造方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Put%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Put方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#resize%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">resize方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#get\"><span class=\"toc-text\">get</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#TreeMap\"><span class=\"toc-text\">TreeMap</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java复习篇：抽象类，String，枚举","uid":"4a3de2f382252848e66f9fb50dc1dbc0","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","updated":"2023-02-02T10:10:38.637Z","comments":true,"path":"api/articles/java/basic/basicjava3.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true},"next_post":{"title":"Java复习篇：List源码实现","uid":"1ecb0dcab298124399035c934d4bcb66","slug":"java/basic/basicjava5","date":"2023-01-27T01:57:16.000Z","updated":"2023-02-02T10:09:20.854Z","comments":true,"path":"api/articles/java/basic/basicjava5.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}