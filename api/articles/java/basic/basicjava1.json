{"title":"Java基础复习篇 {一}","uid":"694fd2173697f1cffe0ab1a293546237","slug":"java/basic/basicjava1","date":"2023-01-10T13:06:07.000Z","updated":"2023-01-16T15:26:04.069Z","comments":true,"path":"api/articles/java/basic/basicjava1.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  本文内容来自书籍 ： 《写给大忙人看的JAVA核心技术》，《Java编程的逻辑》</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>参考：<a href=\"https://www.cnblogs.com/dolphin0520/p/3811445.html\">https://www.cnblogs.com/dolphin0520/p/3811445.html</a>     十分重要</p></blockquote>\n<h1 id=\"小知识点的收获\"><a href=\"#小知识点的收获\" class=\"headerlink\" title=\"小知识点的收获\"></a>小知识点的收获</h1><ul>\n<li>可变长参数就可以理解为数组</li>\n<li>文中的一些说法，accessor访问器方法和mutator更改器方法，说白了mutator更改器方法就是类似list.add()方法，add方法改变了list对象的内容，即被成为更改器方法。而前者accessor就是相反，不改变调用者的对象属性与内容，比如工厂类的实现。</li>\n<li>java所有参数都是值传递，引用对象传递地址值，基本数据类型是值拷贝。</li>\n</ul>\n<h1 id=\"函数调用的原理\"><a href=\"#函数调用的原理\" class=\"headerlink\" title=\"函数调用的原理\"></a>函数调用的原理</h1><ul>\n<li>函数调用是通过栈来实现的，通过出栈和入栈的配合操作来达到函数调用，每次的调用都会分配栈空间来存储参数，局部变量以及返回地址等，从这也就知道函数调用是有成本的，若进行递归操作，数量多的递归层数会造成大量的方法栈压栈，若超出栈空间则会栈溢出，即<code>StackOverflowError</code>错误，会直接导致程序停摆。所以能避免这种进行就应该进行避免。</li>\n</ul>\n<h1 id=\"内部类\"><a href=\"#内部类\" class=\"headerlink\" title=\"内部类\"></a>内部类</h1><ul>\n<li>对于所有内部类，越是作用域范围小的地方定义的变量优先级越高。</li>\n</ul>\n<h2 id=\"静态内部类\"><a href=\"#静态内部类\" class=\"headerlink\" title=\"静态内部类\"></a>静态内部类</h2>  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  ...\n  public static class Inner &#123;....&#125;\n&#125;</code></pre>\n<ul>\n<li>使用，如下两种创建方式</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  private static int name &#x3D; 2;\n  public static class Inner &#123;\n    public void test() &#123;\n     System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n public static void main(String[] args) &#123;\n  &#x2F;&#x2F;静态内部类对象的两种创建方式\n    new Inner().test();\n    new Outter.Inner().test();\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>静态内部类除了不可以访问外部类的成员变量和方法，其他与普通类没啥不一样。</li>\n<li>关于<strong>内部类为何可以访问外部类的私有变量</strong>，《Java编程的逻辑》中提到，是通过给私有变量建立了一个非私有的访问方法，在该方法中返回私有变量的值，类似于getter&#x2F;setter方法。<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>由于这里自己就没编译出书上的代码段，则直接引用了书上的结果，之后会补上为什么。@todo P143</p></blockquote>\n</li>\n</ul>\n<h2 id=\"成员内部类\"><a href=\"#成员内部类\" class=\"headerlink\" title=\"成员内部类\"></a>成员内部类</h2>  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  ...\n  public class Inner &#123;....&#125;\n&#125;</code></pre>\n<ul>\n<li>使用，如下两种方式</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  private String name;\n  public Outter(String name) &#123;\n      this.name &#x3D; name;\n  &#125;\n  &#x2F;&#x2F; 得到内部类实例的方法一\n  public Inner getInner(String name) &#123;\n      return new Inner(name);\n  &#125;\n  public class Inner &#123;\n      private String name;\n      public Inner(String name) &#123;\n          this.name &#x3D; name;\n      &#125;\n      &#x2F;&#x2F; 判断是否属于一个Outter对象的方法\n      public boolean belongsTo(Outter obj) &#123;\n          return Outter.this &#x3D;&#x3D; obj;\n      &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n      Outter qidai &#x3D; new Outter(&quot;Qidai&quot;);\n      Inner inner &#x3D; qidai.getInner(&quot;inner&quot;);\n      System.out.println(inner.belongsTo(qidai));\n\n      Outter ohbug &#x3D; new Outter(&quot;ohbug.cn&quot;);\n      &#x2F;&#x2F;得到内部实力类的方法二\n      Inner inner2 &#x3D; ohbug.new Inner(&quot;inner2&quot;);\n      System.out.println(inner2.belongsTo(qidai));\n  &#125;\n&#125;\n&#x2F;&#x2F; output : true false</code></pre>\n<ul>\n<li>成员内部类可以访问外部类的所有内容。</li>\n<li>外部类访问内部类也是一样，但是外部类访问内部类的成员变量时需要创建内部类的对象，通过对象才可以访问，这是因为成员内部类的创建是依赖于外部类的，当有内部类访问外部类的时候，外部类一定先于内部类进行了初始化，所以内部类访问外部类的所有东西都是无条件的，而当外部类访问成员内部类的成员变量时，成员变量必须初始化才使用，即内部类初始化后才可以使用，即外部类引用内部类的变量必须通过内部类对象引用。</li>\n<li>成员内部类中不能存在任何static的变量和方法，个人的理解是内部类要依赖于某一个外部类对象，而static修饰的变量和方法是在编译期就明确下来的，并不能知晓属于某一个外部类对象。但是static final 修饰的变量则为常量，是可以出现的。</li>\n<li>可以看到，成员内部类的实例化是必须依赖一个已经实例化的外部类对象的。代码中展示了创建成员内部类对象的两种方法。  </li>\n<li>由于内部类对象和外部类对象是类似绑定关系，则如上代码中的<code>beblongsTo()</code>方法展示了如何判断两个内部类对象是否属于一个外部类对象。</li>\n<li>成员内部类编译完成后隐含的包含一个指向外部类的引用。通过<code>javap -p target.class</code>可以看到。如下代码。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  private int name &#x3D; 2;\n  public class Inner &#123;\n    public void test() &#123;\n      System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n    Inner inner &#x3D; new Outter().new Inner();\n    inner.test();\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>反编译后为</li>\n</ul>\n  <pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">shell&gt; javap -p Outter$Inner.class #内部类\nCompiled from &quot;Outter.java&quot;\npublic class Outter$Inner &#123;    \n  final Outter this$0;             #外部类对象引用，final不可变\n  public Outter$Inner(Outter);     #从这可以看到，本身代码并没有对Inner构造器初始化，但是Java自动的将Outter的对象传入进行初始化，进行绑定。\n  public void test();\n&#125;\nshell&gt; javap -p Outter.class       #外部类\nCompiled from &quot;Outter.java&quot;\npublic class Outter &#123;\n  private int name;\n  public Outter();\n  public static void main(java.lang.String[]);\n&#125;</code></pre>\n<ul>\n<li>对比静态内部类，则没有<code>this$0</code>的引用，以及默认初始化的操作。</li>\n</ul>\n<details class=\"custom-details\">\n<summary>点击查看静态内部类的代码以及反编译结果。</summary>\n<p><pre><code><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  private static int name &#x3D; 2;\n  public static class Inner &#123;\n    public void test() &#123;\n      System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n    new Inner().test();\n  &#125;\n&#125;</code></pre>\n<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\">shell&gt; javap -p Outter$Inner.class\nCompiled from &quot;Outter.java&quot;\npublic class Outter$Inner &#123;\n  public Outter$Inner();\n  public void test();\n&#125;\nshell&gt; javap -p Outter.class\nCompiled from &quot;Outter.java&quot;\npublic class Outter &#123;\n  private static int name;\n  public Outter();\n  public static void main(java.lang.String[]);\n  static &#123;&#125;;\n&#125;</code></pre>\n</code></pre>\n</p>\n</details>\n<h2 id=\"方法内部类\"><a href=\"#方法内部类\" class=\"headerlink\" title=\"方法内部类\"></a>方法内部类</h2>  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Outter &#123;\n  ...\n  public void test() &#123;\n    class Inner &#123;\n      ...\n    &#125;\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>若<code>test()</code>是实例方法，内部类则可以访问外部类的所有，以及<code>test()</code>方法中被final修饰的变量。</li>\n<li>若<code>test()</code>是静态方法，则内部类只可以访问外部类的静态变量和方法，以及<code>test()</code>方法中被final修饰的变量。</li>\n<li>关于其具体实现，与上面分析的成员内部类十分相似，若是成员方法内部类，一样是存有外部类的对象引用，一样是通过传递构造器参数来初始化成员方法内部类。静态方法内部类类似则没有。</li>\n</ul>\n<h2 id=\"匿名内部类\"><a href=\"#匿名内部类\" class=\"headerlink\" title=\"匿名内部类\"></a>匿名内部类</h2><ul>\n<li><p>常用于监听类函数使用，在Java8中加入的lambda表达式中常用。</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">new Panel().addMouseListener(new MouseAdapter() &#123;\n  @Override\n  public void mouseClicked(MouseEvent e) &#123;\n    super.mouseClicked(e);\n  &#125;\n&#125;);</code></pre>\n</li>\n<li><p>只能被使用一次，没有类名，没有构造方法。</p>\n</li>\n<li><p>可以使用外部类的所有内容，必须为final修饰。</p>\n</li>\n</ul>\n<h2 id=\"final修饰\"><a href=\"#final修饰\" class=\"headerlink\" title=\"final修饰\"></a>final修饰</h2><ul>\n<li><strong>关于匿名和方法内部类引用变量必须final修饰</strong>，有如下代码，摘自参考文章中。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n  public void test() &#123;\n    final int a &#x3D; 1;\n    new Thread()&#123;\n        public void run() &#123;\n            ...\n            System.out.println(a);\n            ...\n        &#125;;\n    &#125;.start();\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>当<code>test()</code>方法执行完后，新开线程未必能够执行完成，那么a是如何处理的，a由final修饰，在编译期已经可以确定下来，则Java是将final参数直接复制一份进匿名内部类中。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Test &#123;\n  public void test(final int a) &#123;\n    new Thread()&#123;\n        public void run() &#123;\n            ...\n            System.out.println(a);\n            ...\n        &#125;;\n    &#125;.start();\n  &#125;\n&#125;</code></pre>\n<ul>\n<li>对于这种编译器并不能确定的参数，回想之前的成员内部类初始化，匿名内部类同样也有外部引用，为达到对匿名类内a的初始化，则在将外部引用传入内部类初始化的同时，会传入参数a的值，即内部类初始化的时候是通过类似<code>Inner(Outter_constructor,int)</code>的方式进行a的内容赋值的。</li>\n<li>对于为何必须final修饰，由于Java是通过拷贝外部变量进内部类中，则两个内外部类的变量是不同的，这样如果内部类对变量进行修改，则内外变量会造成数据的不一样，所以必须是final修饰。</li>\n</ul>\n","abstracts":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"《Java编程的逻辑》","slug":"《Java编程的逻辑》","count":6,"path":"api/tags/《Java编程的逻辑》.json"},{"name":"《写给大忙人看的Java核心技术》","slug":"《写给大忙人看的Java核心技术》","count":6,"path":"api/tags/《写给大忙人看的Java核心技术》.json"},{"name":"todo","slug":"todo","count":2,"path":"api/tags/todo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B0%8F%E7%9F%A5%E8%AF%86%E7%82%B9%E7%9A%84%E6%94%B6%E8%8E%B7\"><span class=\"toc-text\">小知识点的收获</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E7%9A%84%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">函数调用的原理</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">内部类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">静态内部类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%88%90%E5%91%98%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">成员内部类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%96%B9%E6%B3%95%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">方法内部类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB\"><span class=\"toc-text\">匿名内部类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#final%E4%BF%AE%E9%A5%B0\"><span class=\"toc-text\">final修饰</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java基础复习篇 {二}","uid":"ad681c0b6378ea0f7ccf1db3176a0a81","slug":"java/basic/basicjava2","date":"2023-01-11T01:47:37.000Z","updated":"2023-01-16T15:26:23.340Z","comments":true,"path":"api/articles/java/basic/basicjava2.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"《Java编程的逻辑》","slug":"《Java编程的逻辑》","count":6,"path":"api/tags/《Java编程的逻辑》.json"},{"name":"《写给大忙人看的Java核心技术》","slug":"《写给大忙人看的Java核心技术》","count":6,"path":"api/tags/《写给大忙人看的Java核心技术》.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{}}