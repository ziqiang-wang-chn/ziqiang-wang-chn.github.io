{"title":"Java复习篇：I/O - NIO","uid":"021047d7ebf14e407e0376e9917e9de6","slug":"java/basic/basicjava9","date":"2023-02-18T11:20:15.000Z","updated":"2023-02-19T08:12:53.334Z","comments":true,"path":"api/articles/java/basic/basicjava9.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>《Java高并发核心编程 卷一》</p></blockquote>\n<h1 id=\"NIO-Non-Blocking-IO\"><a href=\"#NIO-Non-Blocking-IO\" class=\"headerlink\" title=\"NIO (Non-Blocking IO)\"></a>NIO (Non-Blocking IO)</h1><ul>\n<li>核心部件： <code>Channel</code> ， <code>Buffer</code> ， <code>Selector</code> 。</li>\n<li>NIO的非阻塞是NIO使用了通道和通道的多路复用技术，NIO的实现是基于底层选择器的系统调用的，所以NIO需要底层操作系统提供支持。</li>\n</ul>\n<h2 id=\"Buffer\"><a href=\"#Buffer\" class=\"headerlink\" title=\"Buffer\"></a>Buffer</h2><h3 id=\"Buffer重要变量\"><a href=\"#Buffer重要变量\" class=\"headerlink\" title=\"Buffer重要变量\"></a>Buffer重要变量</h3><p><img src=\"/img/java/niobuffer.png\" alt=\"picture 1\">  </p>\n<ul>\n<li><p>非线程安全类，NIO Channel 的读写都要经过Buffer，所谓Channel的读取，就是将数据从Channel读取到Buffer中;所谓Channel的写入，就是将数据从Buffer写入Channel中。</p>\n</li>\n<li><p>Buffer本身并没有实现存储的功能，而是其子类有对应的存储数据的数组，比如<code>ByteBuffer</code>的底层是字节数组，<code>CharBuffer</code> 底层是<code>final char[] hb;</code>。</p>\n</li>\n<li><p>Buffer 有四个标识Buffer位置的重要变量：<code>capacity</code> ,<code>limit</code> ,<code>position</code>，<code>mark</code>。</p>\n<ol>\n<li>capacity属性表示内部容量的大小。一旦写入的对象数量超过了capacity，缓冲区就满了，不能再写入了。且一旦初始化，就不能再改变，因为底层是数组。</li>\n<li>position表示当前的位置。position属性的值与缓冲区的读写模式有关。<ul>\n<li>写模式：在刚进入写模式时，position值为0，表示当前的写入位置为从头开始。每当一个数据写到缓冲区之后，position会向后移动到下1个可写的位置。初始的position值为0，最大可写值为limit-1。当position值达到limit时，缓冲区就已经无空间可写了。</li>\n<li>读模式：当缓冲区刚开始进入读模式时，position会被重置为0。当从缓冲区读取时，也是从position位置开始读。读取数据后，position向前移动到下一个可读的位置。在读模式下，limit表示可读数据的上限。position的最大值为最大可读上限limit，当position达到limit时表明缓冲区已经无数据可读。通过 <code>flip()</code> 切换读写模式。</li>\n<li>在从写模式到读模式的翻转过程中，position和limit属性值会进行调整，limit属性被设置成写模式时的position值，表示可以读取的最大数据位置。position由原来的写入位置变成新的可读位置，也就是0表示可以从头开始读。</li>\n</ul>\n</li>\n<li>limit属性表示可以写入或者读取的数据最大上限，其属性值的具体含义也与缓冲区的读写模式有关。在不同的模式下，limit值的含义是不同的。<ul>\n<li>在写模式下，limit属性值的含义为可以写入的数据最大上限。在刚进入写模式时，limit的值会被设置成缓冲区的capacity值表示可以一直将缓冲区的容量写满。</li>\n<li>在读模式下，limit值的含义为最多能从缓冲区读取多少数据。</li>\n</ul>\n</li>\n<li>mark可以设置Buffer中一个位置，然后可以调用 <code>reset()</code> 让 position 恢复到mark 位置方便读取。</li>\n</ol>\n</li>\n</ul>\n<h3 id=\"Buffer重要方法\"><a href=\"#Buffer重要方法\" class=\"headerlink\" title=\"Buffer重要方法\"></a>Buffer重要方法</h3><p><img src=\"/img/java/niocoverRtoW.png\" alt=\"picture 2\">  </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 创建完成默认是写模式。\nallocate(int capacity);\n&#x2F;&#x2F; 把对象写入缓冲区，put得参数要与Buffer类型一致。\nput(各种类型);\n&#x2F;&#x2F; 读写转换\nfilp();\n&#x2F;&#x2F; 在读取完成后，将缓冲区切换成写模式可以调用Buffer.clear() 它们可以将缓冲区转换为写模式。\n&#x2F;&#x2F; (1)将position清零\n&#x2F;&#x2F; (2)limit设置为capacity最大容量值，可以一直写入，直到缓冲区写满\nclear();\n&#x2F;&#x2F; 每次从position的位置读取一个数据，并且进行相应的缓冲区属性的调整\nget(...);\n&#x2F;&#x2F; 已经读完的数据，如果需要再读一遍，可以调用rewind方法\nrewind();</code></pre>\n\n<h2 id=\"Channel\"><a href=\"#Channel\" class=\"headerlink\" title=\"Channel\"></a>Channel</h2><p><img src=\"/img/java/channel.png\" alt=\"picture 3\"> </p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; FileChannel 文件拷贝代码\n    private static void NIOCopyResource(String source, String dest) &#123;\n        try (FileChannel inChannel &#x3D; new FileInputStream(source).getChannel();\n             FileChannel outChannel &#x3D; new FileOutputStream(dest).getChannel()) &#123;\n            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024 * 500);\n            while (inChannel.read(buffer) !&#x3D; -1) &#123;\n                &#x2F;&#x2F; 到这表示有数据都进来了，需要进行读写模式转换，为写文件做准备\n                buffer.flip();\n                &#x2F;&#x2F; 写Buffer中数据到目标文件后，为下次循环转换到读模式\n                outChannel.write(buffer);\n                buffer.clear();\n            &#125;\n        &#125;catch (IOException e)&#123;\n            e.printStackTrace();\n        &#125;\n    &#125;</code></pre>\n\n\n<h2 id=\"Selector\"><a href=\"#Selector\" class=\"headerlink\" title=\"Selector\"></a>Selector</h2><ul>\n<li>Selector就是来实现IO多路复用的，主要工作就是注册监听轮询。一个Channel代表一个链接。</li>\n<li>只有继承了 SelectableChannel的Channel才可以注册到Selector后被监听。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 服务端 ServerSocketChannel 网络传输代码\nprivate static void startServer() throws Exception&#123;\n        Selector selector &#x3D; Selector.open();\n        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();\n        ServerSocket serverSocket &#x3D; serverSocketChannel.socket();\n        serverSocket.bind(new InetSocketAddress(host, port));\n        serverSocketChannel.configureBlocking(false);\n        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);\n        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024*1024*5);\n\n        while (true) &#123;\n            while (selector.select() &gt; 0) &#123;\n                Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();\n                while (iterator.hasNext()) &#123;\n                    SelectionKey key &#x3D; iterator.next();\n                    if (!key.isValid()) &#123;\n                        continue;\n                    &#125;\n                    SelectableChannel selectableChannel &#x3D; key.channel().configureBlocking(false);\n                    if (key.isAcceptable()) &#123;\n                        ServerSocketChannel ssc &#x3D; (ServerSocketChannel) selectableChannel;\n                        SocketChannel accept &#x3D; ssc.accept();\n                        if (accept &#x3D;&#x3D; null) continue;\n                        accept.configureBlocking(false);\n                        accept.register(selector, SelectionKey.OP_READ);\n                    &#125;\n                    if (key.isReadable()) &#123;\n                        SocketChannel sc &#x3D; (SocketChannel) selectableChannel;\n                        int length;\n                        while ((length &#x3D; sc.read(buffer) )!&#x3D; -1) &#123;\n                            buffer.flip();\n                            System.out.println(new String(buffer.array(), 0, length));\n                            buffer.clear();\n                        &#125;\n                    &#125;\n                    iterator.remove();\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n&#x2F;&#x2F; 客户端\n    private static void startClient() throws Exception&#123;\n        &#x2F;&#x2F; 1、获取通道（channel）\n        SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(Server.host, Server.port));\n        &#x2F;&#x2F; 2、切换成非阻塞模式\n        socketChannel.configureBlocking(false);\n        &#x2F;&#x2F;不断的自旋、等待连接完成，或者做一些其他的事情\n        while (!socketChannel.finishConnect()) &#123;\n        &#125;\n        &#x2F;&#x2F; 3、分配指定大小的缓冲区\n        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024*1024*5);\n        byteBuffer.put(&quot;hello world&quot;.getBytes());\n        byteBuffer.flip();\n        socketChannel.write(byteBuffer);\n        socketChannel.shutdownOutput();\n        socketChannel.close();\n    &#125;</code></pre>\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>《Java编程的逻辑》<br><a href=\"https://cloud.tencent.com/developer/article/1902272\">https://cloud.tencent.com/developer/article/1902272</a></p></blockquote>\n<h1 id=\"内存映射文件\"><a href=\"#内存映射文件\" class=\"headerlink\" title=\"内存映射文件\"></a>内存映射文件</h1><h2 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h2><ul>\n<li><p>所谓内存映射文件，就是将文件映射到内存，文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这种映射可以是映射文件全部区域，也可以是只映射一部分区域。不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。操作系统一般是按页加载的，页可以理解为就是一块，页的大小与操作系统和硬件相关，典型的配置可能是4K、8K等，当操作系统发现读写区域不在内存时，就会加载该区域对应的一个页到内存。这种按需加载的方式，使得内存映射文件可以方便高效地处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。但是同步时机是不确定的。</p>\n</li>\n<li><p>之前提到，在一般的文件读写中，会有两次数据复制，一次是从硬盘复制到操作系统内核，另一次是从操作系统内核复制到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次复制，<strong>且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间</strong>，这显然要比普通的读写效率更高。 正是内存映射的一次复制，避免掉了用户态与内核态的切换，所以对于超小文件的大批量读写是友好的。</p>\n</li>\n<li><p>内存映射文件的另一个重要特点是: 它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同<strong>应用程序之间的通信</strong>。</p>\n</li>\n<li><p>在操作系统中的应用，比如:</p>\n<ul>\n<li>按需加载代码，只有当前运行的代码在内存，其他暂时用不到的代码还在硬盘。</li>\n<li>同时启动多次同一个可执行文件，文件代码在内存也只有一份。</li>\n<li>不同应用程序共享的动态链接库代码在内存也只有一份。</li>\n</ul>\n</li>\n<li><p>内存映射文件也有<strong>局限性</strong>。比如，它不太适合处理小文件，它是按页分配内存的，对于<strong>小文件，会浪费空间</strong>。另外，映射文件要消耗一定的操作系统资源，<strong>初始化比较慢</strong>。</p>\n</li>\n<li><p><strong>总结</strong>：对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，那就可以考虑内存映射文件。</p>\n</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><ul>\n<li>首先要获得这条由应用程序直通内核的管道，可以通过<code>FileInputStream/FileOutputStreamo</code>与<code>RandomAccessFile</code> 获得。也可以通过 <code>FileChannel.open(..)</code> 得到。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 将1.txt 映射到内存后，对内存中的操作会同步到文件上。\n&#x2F;&#x2F; FileChannel.MapMode.READ_ONLY 只可读映射，如果进行写操作会抛出异常\n&#x2F;&#x2F; FileChannel.MapMode.READ_WRITE 读写映射，对缓存区的修改最终会写入文件\n&#x2F;&#x2F; FileChannel.MapMode.PRIVATE 读写映射，只对缓冲区修改，但是不会写入文件\nRandomAccessFile rw &#x3D; new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);\nFileChannel rwChannel &#x3D; rw.getChannel();\nMappedByteBuffer mappedByteBuffer &#x3D; rwChannel.map(FileChannel.MapMode.READ_WRITE, 0, 5);\nmappedByteBuffer.put(0, (byte)&#39;H&#39;);\nmappedByteBuffer.put(3, (byte)&#39;9&#39;);\nrw.close();\nrwChannel.close();</code></pre>","feature":true,"abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"java基础","slug":"java基础","count":9,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#NIO-Non-Blocking-IO\"><span class=\"toc-text\">NIO (Non-Blocking IO)</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Buffer\"><span class=\"toc-text\">Buffer</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Buffer%E9%87%8D%E8%A6%81%E5%8F%98%E9%87%8F\"><span class=\"toc-text\">Buffer重要变量</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Buffer%E9%87%8D%E8%A6%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">Buffer重要方法</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Channel\"><span class=\"toc-text\">Channel</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Selector\"><span class=\"toc-text\">Selector</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84%E6%96%87%E4%BB%B6\"><span class=\"toc-text\">内存映射文件</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"RocketMQ 基础概念","uid":"e1552f669f2d1fd29ba980d96a222d61","slug":"rocketmq/rocketmq1","date":"2023-02-19T13:35:32.000Z","updated":"2023-02-19T16:23:05.971Z","comments":true,"path":"api/articles/rocketmq/rocketmq1.json","keywords":null,"cover":"/img/rocketmq/t-k-9AxFJaNySB8-unsplash.jpg","text":"基础概念","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/tags/RocketMQ.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true},"next_post":{"title":"Java复习篇：抽象类，String，枚举","uid":"4a3de2f382252848e66f9fb50dc1dbc0","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","updated":"2023-02-02T10:10:38.637Z","comments":true,"path":"api/articles/java/basic/basicjava3.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":9,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true}}