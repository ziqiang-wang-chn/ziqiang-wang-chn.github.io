{"title":"Java复习篇：I/O 原理与模型","uid":"35c6854a999345df38f931b9ba2ffcae","slug":"java/basic/basicjava8","date":"2023-02-04T01:20:15.000Z","updated":"2023-02-18T10:38:17.428Z","comments":true,"path":"api/articles/java/basic/basicjava8.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>《Java高并发核心编程 卷一》</p></blockquote>\n<h1 id=\"底层原理\"><a href=\"#底层原理\" class=\"headerlink\" title=\"底层原理\"></a>底层原理</h1><h2 id=\"IO读写原理\"><a href=\"#IO读写原理\" class=\"headerlink\" title=\"IO读写原理\"></a>IO读写原理</h2><ul>\n<li>为了避免用户进程直接操作内核，保证内核安全，操作系统将内存(虚拟内存)划分为两部分：一部分是内核空间 (KernelSpace)，另一部分是用户空间(User-Space)。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态;用户程序运行在用户空间，对应的进程处于用户态。</li>\n</ul>\n<ul>\n<li>位于用户态的进程不可以直接访问硬件资源或系统调用，而内核态的进程是可以的，若用户态想进行系统调用，则用户态进程必须通过系统调用 (System Ca11)向内核发出指令，完成调用系统资源之类的操作。。</li>\n</ul>\n<ul>\n<li>用户的IO操作都是基于系统的read和write两大系统调用，操作系统层面的read系统调用并不是直接从物理设备把数据读取到应用的内存中，write系统调用也不是直接把数据写入物理设备。上层应用无论是调用操作系统的read还是调用操作系统的write都会涉及缓冲区。具体来说，上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，通过操作系统的write系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区。即应用程序的IO操作实际上不是物理设备级别的读写而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备之间的交换。这个底层的读写交换操作是由操作系统内核(Kernel) 来完成的。所以，在应用程序中，无论是对socket的IO操作还是对文件的IO操作，都属于上层应用的开发，它们在输入 (Input) 和输出 (Output) 维度上的执行流程是类似的，都是在内核缓冲区和进程缓冲区之间进行数据交换。</li>\n</ul>\n<h2 id=\"内存缓冲区和进程缓冲区\"><a href=\"#内存缓冲区和进程缓冲区\" class=\"headerlink\" title=\"内存缓冲区和进程缓冲区\"></a>内存缓冲区和进程缓冲区</h2><ul>\n<li>缓冲区的目的是减少与设备之间的频繁物理交换。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作通过这种机制来提升系统的性能。至于具体什么时候执行系统中断(包括读中断、写中断)则由操作系统的内核来决定，应用程序不需要关心。</li>\n</ul>\n<ul>\n<li>上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区(进程缓冲区);上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。</li>\n</ul>\n<h1 id=\"IO模型\"><a href=\"#IO模型\" class=\"headerlink\" title=\"IO模型\"></a>IO模型</h1><h2 id=\"同步阻塞IO\"><a href=\"#同步阻塞IO\" class=\"headerlink\" title=\"同步阻塞IO\"></a>同步阻塞IO</h2><p><img src=\"/img/java/IO1.png\" alt=\"picture 1\">  </p>\n<ul>\n<li>同步阻塞IO(Blocking I0) 指的是用户空间(或者线程)主动发起，需要等待内核I0操作彻底完成后才返回到用户空间的IO操作。在IO操作过程中，发起I0请求的用户进程(或者线程) 处于阻塞状态。</li>\n</ul>\n<h2 id=\"同步非阻塞\"><a href=\"#同步非阻塞\" class=\"headerlink\" title=\"同步非阻塞\"></a>同步非阻塞</h2><p><img src=\"/img/java/IO2.png\" alt=\"picture 1\">  </p>\n<ul>\n<li>同步非阻塞I0指的是用户进程主动发起，不需要等待内核IO操作彻底完成就能立即返回用户空间的IO操作。在I0操作过程中，发起IO请求的用户进程(或者线程) 处于非阻塞状态。</li>\n<li>一旦开始IO调用，会发生两种情况<ol>\n<li>在内核缓冲区中没有数据的情况下，系统调用会立即返回个调用失败的信息。</li>\n<li>在内核缓冲区中有数据的情况下，在数据的复制过程中系统调用是阻塞的，直到完成数据从内核缓冲区复制到用户缓冲区。复制完成后，系统调用返回成功，用户进程(或者线程) 可以开始处理用户空间的缓冲区数据。</li>\n</ol>\n</li>\n</ul>\n<ul>\n<li>非阻塞的实现也是基于不断的轮询查询内核状态，虽然每次查询不阻塞了，但是消耗也是非常大的。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>同步非阻塞IO也可以简称为NIO，但是它不是Java编程中的NI0。Java编程中的NIO 类库组件所归属的不是基础IO模型中的NIO模型，而是IO多路复用模型。</p></blockquote>\n<h2 id=\"IO多路复用\"><a href=\"#IO多路复用\" class=\"headerlink\" title=\"IO多路复用\"></a>IO多路复用</h2><p><img src=\"/img/java/IO3.png\" alt=\"picture 3\">  </p>\n<ul>\n<li>为了提高性能，操作系统引入了一种新的系统调用，专门用于查询I0文件描述符(含socket连接)的就绪状态。在Linux系统中，新的系统调用为select&#x2F;epoll系统调用。通过该系统调用，一个用户进程或者线程)可以监视多个文件描述符，一旦某个描述符就绪 (一般是内核缓冲区可读&#x2F;可写)，内核就能够将文件描述符的就绪状态返回给用户进程(或者线程)，用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。</li>\n<li>IO多路复用解决了同步非阻塞的轮询问题，目前支持I0多路复用的系统调用有select、epoll等。几乎所有的操作系统都支持select系统调用，它具有良好的跨平台特性。epoll是在Linux 2.6内核中提出的，是select系统调用的Linux增强版本。</li>\n<li>IO多路复用是从轮询内核发展到轮询socket网络连接，有IO就绪状态时就返回这些就绪的状态。</li>\n</ul>\n<ul>\n<li>I0多路复用模型建立在操作系统的基础设施之上，即操作系统的内核必须能够提供多路分离的系统调用select&#x2F;epoll。</li>\n</ul>\n<ul>\n<li>通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epo11系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。</li>\n<li>优点：一个选择器查询线程可以同时处理成于上万的网络连接，不必创建大量的线程，也不必维护这些线程，从而大大减少了系统的开销。与一个线程维护一个连接的阻塞I0模式相比，这一点是I0多路复用模型的最大优势。</li>\n<li>缺点：本质上select&#x2F;epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。</li>\n</ul>\n<h2 id=\"异步IO\"><a href=\"#异步IO\" class=\"headerlink\" title=\"异步IO\"></a>异步IO</h2><p><img src=\"/img/java/IO4.png\" alt=\"picture 4\">  </p>\n<ul>\n<li>异步IO(Asynchronous IO，AIO) 指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者。在异步I0模型中，当用户线程收到通知时，数据已经被内核读取完毕并放在了用户缓冲区内，内核在I0完成后通知用户线程直接使用即可，在整个内核的数据处理中都不需要用户阻塞。</li>\n</ul>\n<ul>\n<li>流程：用户发出read后立刻可以去做其他事情，当有IO请求时，内核负责准备数据，并且把数据拷贝到用户缓冲区后回调用户注册的函数后，用户开始IO操作。</li>\n</ul>\n<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>Linux操作系统中文件句柄数的限制。在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。原因是Linux系统的默认值为1024，也就是说，一个进程最多可以接受1024个socket连接，这是远远不够的。修改方式如下</p>\n<ul>\n<li>修改 <code>/etc/security/limits.conf</code></li>\n</ul>\n<pre class=\"line-numbers language-conf\" data-language=\"conf\"><code class=\"language-conf\">; soft nofile表示软性极限，hard nofile表示硬性极限。\n; 硬性极限值是实际的限制，就是最大可以是100万，不能再多了。\n; 软性极限值则是系统发出警告 (Warning)的极限值，超过这个极限值，内核会发出警告。\nsoft nofile 1000000 ;\nhard nofile 1000000 ;</code></pre>\n\n\n</div>\n","abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"2.8k","symbolsTime":"3 mins."},"categories":[{"name":"java基础","slug":"java基础","count":9,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">底层原理</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E8%AF%BB%E5%86%99%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">IO读写原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%86%85%E5%AD%98%E7%BC%93%E5%86%B2%E5%8C%BA%E5%92%8C%E8%BF%9B%E7%A8%8B%E7%BC%93%E5%86%B2%E5%8C%BA\"><span class=\"toc-text\">内存缓冲区和进程缓冲区</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#IO%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">IO模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E9%98%BB%E5%A1%9EIO\"><span class=\"toc-text\">同步阻塞IO</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%90%8C%E6%AD%A5%E9%9D%9E%E9%98%BB%E5%A1%9E\"><span class=\"toc-text\">同步非阻塞</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8\"><span class=\"toc-text\">IO多路复用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%82%E6%AD%A5IO\"><span class=\"toc-text\">异步IO</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java复习篇：字符与字节流","uid":"9c7ce237510431a1698beb3d7aef4793","slug":"java/basic/basicjava7","date":"2023-02-04T01:20:15.000Z","updated":"2023-02-18T10:38:20.288Z","comments":true,"path":"api/articles/java/basic/basicjava7.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"java基础","slug":"java基础","count":9,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Redis复习：基本命令","uid":"8e53ea792c68f7c08b10733cf876a7d7","slug":"redis/basic-redis1","date":"2023-02-03T04:17:32.000Z","updated":"2023-02-03T12:03:17.352Z","comments":true,"path":"api/articles/redis/basic-redis1.json","keywords":null,"cover":"/img/redis/redis-cover.jpg","text":"基础命令复习。","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}