{"title":"Java复习篇：List源码实现","uid":"1ecb0dcab298124399035c934d4bcb66","slug":"java/basic/basicjava5","date":"2023-01-27T01:57:16.000Z","updated":"2023-02-02T10:09:20.854Z","comments":true,"path":"api/articles/java/basic/basicjava5.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<p><img src=\"/img/java/CollectionClassMap-List.png\"></p>\n<ul>\n<li>紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。</li>\n<li>下面进行实现类的源码分析，主要是分析其实现类的主要功能。</li>\n</ul>\n<h1 id=\"List\"><a href=\"#List\" class=\"headerlink\" title=\"List\"></a>List</h1><h2 id=\"ArrayList\"><a href=\"#ArrayList\" class=\"headerlink\" title=\"ArrayList\"></a>ArrayList</h2><h3 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h3><ul>\n<li>从如下的得知，默认的空参构造并不会初始化一个数组，而是类似于懒加载的方式，当加入参数或者指定大小的时候才开始初始化数组大小。</li>\n<li>若 ArrayList 对象都是空实例，则都会指向一个数组对象，以便节约内存。</li>\n<li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 和  <code>EMPTY_ELEMENTDATA</code> 并不一样。<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 用于无参初始化，而 <code>EMPTY_ELEMENTDATA </code>用于优化创建ArrayList空实例时产生不必要的空数组。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 默认容量\nprivate static final int DEFAULT_CAPACITY &#x3D; 10;\ntransient Object[] elementData;\n&#x2F;&#x2F; 共享的空数组\nprivate static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;\n\n&#x2F;&#x2F; 空参构造，从这也可以看到出，ArrayList默认无参数初始化时，底层的数组长度是0，无元素\npublic ArrayList() &#123;\n    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n&#125;\n\npublic ArrayList(int initialCapacity) &#123;\n    if (initialCapacity &gt; 0) &#123;\n        &#x2F;&#x2F; 指定长度构造则只构造参数长度的数组对象。\n        this.elementData &#x3D; new Object[initialCapacity];\n    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 与无参的思路一样\n        this.elementData &#x3D; EMPTY_ELEMENTDATA;\n    &#125; else &#123;\n        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                            initialCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F; 参数为Collection的子类即可\npublic ArrayList(Collection&lt;? extends E&gt; c) &#123;\n    &#x2F;&#x2F; 将参数转为数组\n    Object[] a &#x3D; c.toArray();\n    &#x2F;&#x2F; 不为空\n    if ((size &#x3D; a.length) !&#x3D; 0) &#123;\n      &#x2F;&#x2F; 若构造参数也是ArrayList则直接赋值即可\n        if (c.getClass() &#x3D;&#x3D; ArrayList.class) &#123;\n            elementData &#x3D; a;\n        &#125; else &#123;\n          &#x2F;&#x2F; 否则还是执行下面的复制方法\n            elementData &#x3D; Arrays.copyOf(a, size, Object[].class);\n        &#125;\n    &#125; else &#123;\n        &#x2F;&#x2F; 如果传入参数没有元素，则赋值一个共享的空数组，以节约内存。\n        &#x2F;&#x2F; replace with empty array.\n        elementData &#x3D; EMPTY_ELEMENTDATA;\n    &#125;\n&#125;\npublic Object[] toArray() &#123;\n  &#x2F;&#x2F; a 数组内容，长度，a数组类型\n    return Arrays.copyOf(a, a.length, Object[].class);\n&#125;\npublic static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;\n    @SuppressWarnings(&quot;unchecked&quot;)\n    &#x2F;&#x2F; 由于ArrayList的底层就是使用的Object数组，则始终为true，返回一个新数组，新数组与传入参数的对象长度一样\n    &#x2F;&#x2F; 否则返回一个应有对象类型的数组。\n    &#x2F;&#x2F; 根据不同的参数，toArray的实现不一样的，比如若传入HashSet的实现类，则HashSet已经重写了toArray方法，则调用的是HashSet的实现方法，代码就不会执行到这里了\n    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    &#x2F;&#x2F; 数组复制，然后返回即可\n    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));\n    return copy;\n&#125;        </code></pre>\n\n<ul>\n<li>对于 <code>copyof</code> 方法的额外补充。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Object[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;\nObject[] strings &#x3D; Arrays.copyOf(str, 2);\n&#x2F;&#x2F; 此时上面copyof方法中的((Object)newType &#x3D;&#x3D; (Object)Object[].class) 为true\n&#x2F;&#x2F; 若换为String，或者其他类型的数组，则为false\n&#x2F;&#x2F; 如下，如果是Object数组，返回一个新Object数组，新数组与传入参数的规定长度一样\n    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n&#x2F;&#x2F; 否则就返回与实际相符的类型数组。\n    public static Object newInstance(Class&lt;?&gt; componentType, int length)\n        throws NegativeArraySizeException &#123;\n        return newArray(componentType, length);\n    &#125;\n&#x2F;&#x2F; out: class java.lang.String\n  String[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;\n  System.out.println(str.getClass().getComponentType());</code></pre>\n<h3 id=\"transient\"><a href=\"#transient\" class=\"headerlink\" title=\"transient\"></a>transient</h3><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.runoob.com/w3cnote/java-transient-keywords.html\">https://www.runoob.com/w3cnote/java-transient-keywords.html</a></p></blockquote>\n<ul>\n<li>被<code>transient</code>修饰的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。只需要实现<code>Serilizable</code>接口，将不需要序列化的属性前添加<code>transient</code>，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</li>\n<li>只能修饰变量，而不能修饰方法和类。变量如果是用户自定义类变量，则该类需要实现<code>Serializable</code>接口。</li>\n<li>被<code>transient</code>关键字修饰的变量不再能被序列化，一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。</li>\n</ul>\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><ul>\n<li>总结下来就是通过判断数组的大小与元素的数量，来返回合适的容量大小，以便创建合适的数组，在通过copyof方法进行复制元素。</li>\n<li>重点是<code>grow</code>方法的实现，我们可以从源码得到，若满了，则推荐的扩容大小是之前的 1.5呗，是通过 <code>oldCapacity &gt;&gt; 1</code> 实现的。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">protected transient int modCount &#x3D; 0;\n    public boolean add(E e) &#123;\n      &#x2F;&#x2F; 表示内部的修改次数，与迭代器配合，可以判断出迭代过程中是否被修改，防止多线程模式下安全问题\n        modCount++;\n        &#x2F;&#x2F; 添加元素\n        add(e, elementData, size);\n        return true;\n    &#125;\n    &#x2F;&#x2F; e要添加的参数，elementData是底层数组实现，s 已包含元素数量\n    private void add(E e, Object[] elementData, int s) &#123;\n      &#x2F;&#x2F; 数组无空闲地方存放待加入元素，则扩充数组大小，包括两种情况，一种是刚刚初始化完毕无空闲位置，一个是已满无空闲位置\n      &#x2F;&#x2F; 如果为false，即代表数组位置和数组内元素数量不一致，则不需要增长容量，因为有空闲位置。\n        if (s &#x3D;&#x3D; elementData.length)\n            elementData &#x3D; grow();\n        &#x2F;&#x2F; 插入值\n        elementData[s] &#x3D; e;\n        &#x2F;&#x2F; 容量+1\n        size &#x3D; s + 1;\n    &#125;\n    private Object[] grow() &#123;\n        return grow(size + 1);\n    &#125;\n    private Object[] grow(int minCapacity) &#123;\n      &#x2F;&#x2F; 保存原来长度\n        int oldCapacity &#x3D; elementData.length;\n        &#x2F;&#x2F; 如果不是空元素的ArrayList集合 或 刚初始化完成的\n        if (oldCapacity &gt; 0 || elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n          &#x2F;&#x2F; 计算新容量的大小\n            int newCapacity &#x3D; ArraysSupport.newLength(oldCapacity,\n                    minCapacity - oldCapacity, &#x2F;* minimum growth *&#x2F;\n                    oldCapacity &gt;&gt; 1           &#x2F;* preferred growth *&#x2F;);\n            &#x2F;&#x2F; 复制元素进去，返回的是新的数组，原数组引用丢失，会被之后当垃圾回收掉\n            return elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n        &#125; else &#123;\n          &#x2F;&#x2F; 代表ArrayList中已经是空的了，此时与默认初始化大小和目前元素个数+1 比较，两个数取大值，创建大值容量的Object数组\n            return elementData &#x3D; new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n        &#125;\n    &#125;\n    public static final int SOFT_MAX_ARRAY_LENGTH &#x3D; Integer.MAX_VALUE - 8;\n    &#x2F;&#x2F; 仅仅用来计算数组长度的\n    public static int newLength(int oldLength, int minGrowth, int prefGrowth) &#123;\n        &#x2F;&#x2F; 如果长度超过了Integer.MAX_VALUE，则异常发生OutOfMemoryError\n        &#x2F;&#x2F; 一般情况下选取prefGrowth，而当prefGrowth超过最大值而minGrowth没有超时，选取minGrowth\n        int prefLength &#x3D; oldLength + Math.max(minGrowth, prefGrowth); &#x2F;&#x2F; might overflow\n        if (0 &lt; prefLength &amp;&amp; prefLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;\n            return prefLength;\n        &#125; else &#123;\n            &#x2F;&#x2F; prefLength超了\n            &#x2F;&#x2F; put code cold in a separate method\n            return hugeLength(oldLength, minGrowth);\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 判断oldLength + minGrowth是否超过了SOFT_MAX_ARRAY_LENGTH，如果超了即为负数直接报错，\n    &#x2F;&#x2F; 如果没超过SOFT_MAX_ARRAY_LENGTH，则直接返回SOFT_MAX_ARRAY_LENGTH，否则返回minLength的计算值\n    private static int hugeLength(int oldLength, int minGrowth) &#123;\n        int minLength &#x3D; oldLength + minGrowth;\n        if (minLength &lt; 0) &#123; &#x2F;&#x2F; overflow\n            throw new OutOfMemoryError(\n                &quot;Required array length &quot; + oldLength + &quot; + &quot; + minGrowth + &quot; is too large&quot;);\n        &#125; else if (minLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;\n            return SOFT_MAX_ARRAY_LENGTH;\n        &#125; else &#123;\n            return minLength;\n        &#125;\n    &#125;</code></pre>\n\n\n<h3 id=\"get\"><a href=\"#get\" class=\"headerlink\" title=\"get\"></a>get</h3><ul>\n<li>没啥好分析的。首先判断下标是否合法，合法则直接取值。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public E get(int index) &#123;\n    &#x2F;&#x2F; 仅仅是检查下标是否越界\n    Objects.checkIndex(index, size);\n    return elementData(index);\n&#125;\nE elementData(int index) &#123;\n    return (E) elementData[index];\n&#125;</code></pre>\n\n<h3 id=\"set\"><a href=\"#set\" class=\"headerlink\" title=\"set\"></a>set</h3><ul>\n<li>检查下标是否合法，取出旧值并返回，新值替换就值。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public E set(int index, E element) &#123;\n    Objects.checkIndex(index, size);\n    E oldValue &#x3D; elementData(index);\n    elementData[index] &#x3D; element;\n    return oldValue;\n&#125;</code></pre>\n\n\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><ul>\n<li>指定位置删除十分简单，若是指定对象删除，实现逻辑就是循环遍历元素然后依旧通过<code>fastRemove</code>删除，通过<code>System.arraycopy</code>实现。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public E remove(int index) &#123;\n    &#x2F;&#x2F; 检查下标是否合法\n    Objects.checkIndex(index, size);\n    final Object[] es &#x3D; elementData;\n    @SuppressWarnings(&quot;unchecked&quot;) \n    E oldValue &#x3D; (E) es[index];\n    fastRemove(es, index);\n    return oldValue;\n&#125;\nprivate void fastRemove(Object[] es, int i) &#123;\n    modCount++;\n    final int newSize;\n    &#x2F;&#x2F; 如果为true，则代表要删除的指定位置并不是最后一个元素，则数组整体往前移一个位置\n    if ((newSize &#x3D; size - 1) &gt; i)\n        System.arraycopy(es, i + 1, es, i, newSize - i);\n    &#x2F;&#x2F; 到这条件为false，或者要删除的指定位置是最后一个元素，直接赋值null即可  \n    es[size &#x3D; newSize] &#x3D; null;\n&#125;</code></pre>\n\n<h3 id=\"removeAll\"><a href=\"#removeAll\" class=\"headerlink\" title=\"removeAll\"></a>removeAll</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public boolean removeAll(Collection&lt;?&gt; c) &#123;\n    return batchRemove(c, false, 0, size);\n&#125;\nboolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123;\n    &#x2F;&#x2F; 不为空，否则空指针\n    Objects.requireNonNull(c);\n    final Object[] es &#x3D; elementData;\n    int r;\n    for (r &#x3D; from;; r++) &#123;\n        &#x2F;&#x2F; 若循环到了最后一个，即证明了没有要删除的元素\n        if (r &#x3D;&#x3D; end)\n            return false;\n        &#x2F;&#x2F; 如果包含对应的元素则结束循环，结束循环的位置就是第一个元素出现的下标位置\n        if (c.contains(es[r]) !&#x3D; complement)\n            break;\n    &#125;\n    &#x2F;&#x2F; 第一个元素出现的下标位置记作w，r指向下一个位置\n    int w &#x3D; r++;\n    try &#123;\n        &#x2F;&#x2F; 从下一个位置开始判断，结束条件为末尾\n        for (Object e; r &lt; end; r++)\n            &#x2F;&#x2F; 如果剩下的未遍历的c中的元素中，该元素不是要删除的元素\n            if (c.contains(e &#x3D; es[r]) &#x3D;&#x3D; complement)\n                &#x2F;&#x2F; 则将要删除的元素用不需要删除元素的值顶替\n                es[w++] &#x3D; e;\n    &#125; catch (Throwable ex) &#123;\n        &#x2F;&#x2F; Preserve behavioral compatibility with AbstractCollection,\n        &#x2F;&#x2F; even if c.contains() throws.\n        System.arraycopy(es, r, es, w, end - r);\n        w +&#x3D; end - r;\n        throw ex;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 操作次数记录\n        modCount +&#x3D; end - w;\n        &#x2F;&#x2F; 经过上面操作，到这已经是将要删除的元素剔除完了，但是操作还没结束\n        &#x2F;&#x2F; 比如从12345中剔除24，则到这12345变为了13545，其中最后的45是要删除掉的\n        &#x2F;&#x2F; 则下面方法就是将后面多余元素删除的工作\n        shiftTailOverGap(es, w, end);\n    &#125;\n    return true;\n&#125;</code></pre>\n\n<h2 id=\"LinkedList\"><a href=\"#LinkedList\" class=\"headerlink\" title=\"LinkedList\"></a>LinkedList</h2><h3 id=\"定义\"><a href=\"#定义\" class=\"headerlink\" title=\"定义\"></a>定义</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class LinkedList&lt;E&gt;\n    extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre>\n\n<ul>\n<li>从定义也可以看出来，<code>LinkedList</code> 不仅可以做链表，还可以当作队列使用，以及堆栈，但是如果涉及到堆栈等操作，更合适用的是 <code>ArrayDeque</code></li>\n</ul>\n<h3 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h3><ul>\n<li><code>LinkedList</code>里面有一内部类<code>Node</code>，从这也可以看出<code>LinkedList</code>是一个双向链表。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">private static class Node&lt;E&gt; &#123;\n    E item;\n    Node&lt;E&gt; next;  \n    Node&lt;E&gt; prev;\n\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item &#x3D; element;\n        this.next &#x3D; next;\n        this.prev &#x3D; prev;\n    &#125;\n&#125;</code></pre>\n\n<h3 id=\"构造-1\"><a href=\"#构造-1\" class=\"headerlink\" title=\"构造\"></a>构造</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 元素个数\ntransient int size &#x3D; 0;\npublic LinkedList() &#123;\n&#125;\npublic LinkedList(Collection&lt;? extends E&gt; c) &#123;\n    this();\n    addAll(c);\n&#125;\npublic boolean addAll(Collection&lt;? extends E&gt; c) &#123;\n    return addAll(size, c);\n&#125;\npublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n    &#x2F;&#x2F; 内部实现就是简单的边界检查\n    checkPositionIndex(index);\n    &#x2F;&#x2F; 将参数转为数组，底层实现为Arrays.copyOf\n    Object[] a &#x3D; c.toArray();\n    &#x2F;&#x2F; 元素个数\n    int numNew &#x3D; a.length;\n    if (numNew &#x3D;&#x3D; 0)\n        return false;\n    &#x2F;&#x2F; 记录： pred前一个元素，succ 当前\n    Node&lt;E&gt; pred, succ;\n    &#x2F;&#x2F; 如果相等代表在最后追加\n    if (index &#x3D;&#x3D; size) &#123;\n        &#x2F;&#x2F; 若在最后追加，则last已经指向了最后一个元素，那么pred就应该是待添加元素的前驱节点\n        &#x2F;&#x2F; 即last即为待添加元素的前驱节点，所以pred&#x3D;last且当前节点succ未添加为空\n        succ &#x3D; null;\n        pred &#x3D; last;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这了就表示在链表中间插入新元素\n        &#x2F;&#x2F; 得到后继节点\n        succ &#x3D; node(index);\n        &#x2F;&#x2F; 再由后继节点得到前驱节点。\n        pred &#x3D; succ.prev;\n    &#125;\n    &#x2F;&#x2F; 遍历要插入得元素数组\n    for (Object o : a) &#123;\n        @SuppressWarnings(&quot;unchecked&quot;) \n        E e &#x3D; (E) o;\n        &#x2F;&#x2F; 创建一个待插入节点，此节点已经指向了前驱节点\n        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);\n        &#x2F;&#x2F; 前驱节点为空，即插入节点为头节点。\n        if (pred &#x3D;&#x3D; null)\n            first &#x3D; newNode;\n        else\n            &#x2F;&#x2F; 否则将前驱节点得后指针指向待插入节点\n            pred.next &#x3D; newNode;\n        &#x2F;&#x2F; 元素指针后移，为下次循环做准备\n        pred &#x3D; newNode;\n    &#125;\n    &#x2F;&#x2F; 如果在末尾追加，则succ由上面可知一定是null，且由于上面得for循环已经将pred指向了最后一个元素，则pred即为链表末尾\n    if (succ &#x3D;&#x3D; null) &#123;\n        last &#x3D; pred;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这则不代表在末尾追加，则一定是在头或中间追加，则succ为待插入位置的后面的链表的头引用\n        &#x2F;&#x2F; 此时链表的状态是，待插入位置前面的元素 + 已加入的新元素 。succ指向的待插入位置后面的原来的元素\n        &#x2F;&#x2F; 直接连接（待插入位置前面的元素 + 已加入的新元素）和succ，即完成添加\n        pred.next &#x3D; succ;\n        succ.prev &#x3D; pred;\n    &#125;\n    size +&#x3D; numNew;\n    modCount++;\n    return true;\n&#125;\ntransient Node&lt;E&gt; first;   &#x2F;&#x2F; 全局节点头指针\ntransient Node&lt;E&gt; last;     &#x2F;&#x2F; 尾指针\n&#x2F;&#x2F; 返回指定元素索引处的节点\nNode&lt;E&gt; node(int index) &#123;\n    &#x2F;&#x2F; 如果插入下标为链表元素的左半边\n    if (index &lt; (size &gt;&gt; 1)) &#123;\n        &#x2F;&#x2F; 记录头节点\n        Node&lt;E&gt; x &#x3D; first;\n        &#x2F;&#x2F; 从头遍历，因为是左半边，所以从头遍历比较快\n        &#x2F;&#x2F; 找到要插入位置的左边一个元素并返回\n        for (int i &#x3D; 0; i &lt; index; i++)\n            x &#x3D; x.next;\n        return x;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这表示要插入的元素为链表元素的右半边，所以从尾部往前遍历\n        Node&lt;E&gt; x &#x3D; last;\n        &#x2F;&#x2F; 直到遍历到要插入位置的右边一个位置\n        for (int i &#x3D; size - 1; i &gt; index; i--)\n            x &#x3D; x.prev;\n        return x;\n    &#125;\n    &#x2F;&#x2F; 无论for停留在左边还是右边，返回的都是指定元素索引处的元素\n&#125;</code></pre>\n\n<ul>\n<li>由于里面的诸如：addFirst,addLast,removeFirst等一系列方法都是在调用几个共同的方法，只是传入参数不同，则下面只分析几个调用较多的公共方法。</li>\n</ul>\n<h3 id=\"linkLast\"><a href=\"#linkLast\" class=\"headerlink\" title=\"linkLast\"></a>linkLast</h3><ul>\n<li>将e元素添加至末尾。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void linkLast(E e) &#123;\n    &#x2F;&#x2F; 保存原来的尾节点\n    final Node&lt;E&gt; l &#x3D; last;\n    &#x2F;&#x2F; 创建要插入的新节点\n    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);\n    &#x2F;&#x2F; 新节点设置为last节点\n    last &#x3D; newNode;\n    &#x2F;&#x2F; 若为真，则代表原来的链表为空\n    if (l &#x3D;&#x3D; null)\n        &#x2F;&#x2F; 则一共就元素，则首尾都是此新元素\n        first &#x3D; newNode;\n    else\n        &#x2F;&#x2F; 尾节点的下一个引用则为新节点\n        l.next &#x3D; newNode;\n    size++;\n    modCount++;\n&#125;</code></pre>\n\n\n<h3 id=\"linkBefore\"><a href=\"#linkBefore\" class=\"headerlink\" title=\"linkBefore\"></a>linkBefore</h3><ul>\n<li>将一个元素放置在一个元素的前面。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">void linkBefore(E e, Node&lt;E&gt; succ) &#123;\n    &#x2F;&#x2F;已经确保了succ不为空,在上面node方法中确保的\n    &#x2F;&#x2F;取出指定index索引上的元素的前一个元素引用\n    final Node&lt;E&gt; pred &#x3D; succ.prev;\n    &#x2F;&#x2F;创建新的元素,新元素的前一个元素就是目前指定index上的元素的前一个元素\n    &#x2F;&#x2F;下一个元素是index上面的元素\n    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);\n    &#x2F;&#x2F;将指定索引位置的原元素的前指针指向新元素\n    succ.prev &#x3D; newNode;\n    &#x2F;&#x2F;如果是在头部添加,那么当前元素的前一个元素肯定为空\n    if (pred &#x3D;&#x3D; null)\n    &#x2F;&#x2F;然后新元素就成为了头元素\n        first &#x3D; newNode;\n    else\n    &#x2F;&#x2F;否则就将index-1位置的元素的后指针指向新元素\n        pred.next &#x3D; newNode;\n    size++;\n    modCount++;\n&#125;</code></pre>\n<h3 id=\"unlink\"><a href=\"#unlink\" class=\"headerlink\" title=\"unlink\"></a>unlink</h3><ul>\n<li>将一个非空元素删除，即讲该元素的前后指针和前驱节点和后继节点的指针相连。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">E unlink(Node&lt;E&gt; x) &#123;\n    final E element &#x3D; x.item;\n    final Node&lt;E&gt; next &#x3D; x.next;\n    final Node&lt;E&gt; prev &#x3D; x.prev;\n    &#x2F;&#x2F; 无前驱元素，则就是头节点\n    if (prev &#x3D;&#x3D; null) &#123;\n        first &#x3D; next;\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则前驱节点的后指针指向该删除元素的后继节点\n        prev.next &#x3D; next;\n        &#x2F;&#x2F; 断开要删除元素的前指针\n        x.prev &#x3D; null;\n    &#125;\n    &#x2F;&#x2F; 无后继元素，就是末尾节点\n    if (next &#x3D;&#x3D; null) &#123;\n        last &#x3D; prev;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这就代表不是末尾节点，则该后继节点的前指针指向该删除元素的前驱节点\n        next.prev &#x3D; prev;\n        &#x2F;&#x2F; 断开要删除元素的后指针\n        x.next &#x3D; null;\n    &#125;\n    &#x2F;&#x2F; 赋值为空，方便回收\n    x.item &#x3D; null;\n    size--;\n    modCount++;\n    return element;\n&#125;</code></pre>\n\n<ul>\n<li>对于其他的方法，最后归到底基本都是在调用上面几个方法，且逻辑比较简单，就不一一分析了。</li>\n</ul>\n","abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"14 mins."},"categories":[{"name":"java基础","slug":"java基础","count":8,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":8,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#List\"><span class=\"toc-text\">List</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#ArrayList\"><span class=\"toc-text\">ArrayList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">构造</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#transient\"><span class=\"toc-text\">transient</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#add\"><span class=\"toc-text\">add</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#get\"><span class=\"toc-text\">get</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#set\"><span class=\"toc-text\">set</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#remove\"><span class=\"toc-text\">remove</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#removeAll\"><span class=\"toc-text\">removeAll</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#LinkedList\"><span class=\"toc-text\">LinkedList</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E5%AE%9A%E4%B9%89\"><span class=\"toc-text\">定义</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">结构</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0-1\"><span class=\"toc-text\">构造</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linkLast\"><span class=\"toc-text\">linkLast</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#linkBefore\"><span class=\"toc-text\">linkBefore</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#unlink\"><span class=\"toc-text\">unlink</span></a></li></ol></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java复习篇：Map源码实现","uid":"cfeb076eceaa089663cf2e1f4248e9ee","slug":"java/basic/basicjava6","date":"2023-01-29T01:56:01.000Z","updated":"2023-02-03T02:26:10.991Z","comments":true,"path":"api/articles/java/basic/basicjava6.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":8,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":8,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":5,"path":"api/tags/todo.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Java复习篇：泛型","uid":"216c1df589f41fe3d75a0e63e395221b","slug":"java/basic/basicjava4","date":"2023-01-17T01:58:04.000Z","updated":"2023-02-02T10:08:50.240Z","comments":true,"path":"api/articles/java/basic/basicjava4.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"java基础","slug":"java基础","count":8,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":8,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":5,"path":"api/tags/todo.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}