{"title":"Java基础复习篇 {四}","uid":"8fdce377ebe536fa0275321f1d32f6a0","slug":"java/basic/basicjava4","date":"2023-01-17T01:58:04.000Z","updated":"2023-01-18T07:28:41.143Z","comments":true,"path":"api/articles/java/basic/basicjava4.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  本文内容来自书籍 ： 《写给大忙人看的JAVA核心技术》，《Java编程的逻辑》</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<h1 id=\"泛型\"><a href=\"#泛型\" class=\"headerlink\" title=\"泛型\"></a>泛型</h1><ul>\n<li>通过使用泛型， 可以最大程度的保证其类型安全。</li>\n<li>加入泛型的代码是更加的灵活的，避免了硬编码。</li>\n<li>由于泛型是运行时被擦除的，所以类泛型不可应用于静态变量方法中。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>《写给大忙人看的JAVA核心技术》一书中对于泛型的解释相当详细，值得多次翻阅   @todo </p></blockquote>\n<h2 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h2><ul>\n<li>编译器在编译期间，会将使用泛型的类直接擦去泛型代码，转换为普通的非泛型代码。比如<code> MyFactory &lt;T,U&gt;</code> 直接就擦除成了<code>MyFactory</code>，替换为Object类型，由于不知道确切的类型了，则还需要加入强制类型转换。在虚拟机执行的时候是不知道泛型是啥的，只知道这是一个通过强制类型转换达到目的的普通代码。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyFactory&lt;K extends String, V extends Set&gt;&#123;\n    private K key;\n    private V sets;\n&#125;\n&#x2F;&#x2F; 擦除后\npublic class MyFactory&#123;\n    private String key;\n    private Set sets;\n&#125;</code></pre>\n\n\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><h2 id=\"泛型类\"><a href=\"#泛型类\" class=\"headerlink\" title=\"泛型类\"></a>泛型类</h2><ul>\n<li>接口中使用泛型与泛型类中是类似的。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class MyFactory &lt;T,U&gt;&#123;\n    public MyFactory() &#123;\n    &#125;\n    public MyFactory(T first, U second) &#123;\n        this.first &#x3D; first;\n        this.second &#x3D; second;\n    &#125;\n    private T first;\n    private U second;\n    public T getFirst() &#123;\n        return first;\n    &#125;\n    public U getSecond() &#123;\n        return second;\n    &#125;\n    public static void main(String[] args) &#123;\n        MyFactory&lt;Integer, String&gt; factory &#x3D; new MyFactory&lt;&gt;(1,&quot;ohbug.cn&quot;);\n        System.out.println(factory.getFirst());\n        System.out.println(factory.getSecond());\n    &#125;\n&#125;\n&#x2F;&#x2F;out\n1\nohbug.cn</code></pre>\n\n<h2 id=\"泛型方法\"><a href=\"#泛型方法\" class=\"headerlink\" title=\"泛型方法\"></a>泛型方法</h2><ul>\n<li>泛型方法不一定非要使用在泛型类中。声明泛型方法的时候，必须在返回值前面加上泛型声明<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 返回值为T的second方法\npublic static &lt;T,Y&gt; T second(T i, Y j) &#123;&#125;\n&#x2F;&#x2F; 返回值为void的first方法\npublic static &lt;T,Y&gt; void first(T i, Y j) &#123;&#125;</code></pre></li>\n</ul>\n<h2 id=\"泛型参数限定\"><a href=\"#泛型参数限定\" class=\"headerlink\" title=\"泛型参数限定\"></a>泛型参数限定</h2><h3 id=\"extends\"><a href=\"#extends\" class=\"headerlink\" title=\"extends\"></a>extends</h3><ul>\n<li><p><code>&lt;T extends AutoCloseable&gt;</code>上界为<code>AutoCloseable</code>。即传入的参数必须是<code>AutoCloseable</code>以及子类。</p>\n</li>\n<li><p><code>&lt;T extends Runnable &amp; AutoCloseable&gt;</code>多重限定，但只可以有一个是类，且如果是类必须放在最前面。</p>\n</li>\n<li><p><code>Son[]</code>可直接赋值给<code>Father[]</code>，这称为协变，数组随元素类型变化而变化。但是<code>ArrayList&lt;Son&gt;</code>并不可以赋值给<code>ArrayList&lt;Father&gt;</code>。</p>\n</li>\n<li><p><code>&lt;T extends A&gt;</code>和<code>&lt;? extends A&gt;</code>的区别</p>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public &lt;T extends String&gt; void  fun1(ArrayList&lt;T&gt; list) &#123;\n    for (T t : list) &#123;\n        System.out.println(t);\n    &#125;\n    T t &#x3D; list.get(1);\n    list.add((T) &quot;fun1&quot;);\n&#125;\npublic void fun2(ArrayList&lt;? extends String&gt; list)&#123;\n    for (String s : list) &#123;\n        System.out.println(s);\n    &#125;\n    String s &#x3D; list.get(1);\n    list.add((String)&quot;fun1&quot;); &#x2F;&#x2F;error\n&#125;\n&#x2F;** 从这也可以看出来，T可以直接当作一个类型在其作用域内使用，返回值更加灵活，且可以对形参进行增删操作\n    而?类型不可以在作用域内使用，返回值更加确定，且不可对形参操作\n    由此可以得出结论：如果不希望形参被修改则需用? 类型，否则T类型更加灵活。\n    *&#x2F;</code></pre></li>\n</ul>\n<h3 id=\"super\"><a href=\"#super\" class=\"headerlink\" title=\"super\"></a>super</h3><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 任何类型的数组都适用的方法\n    public static  &lt;T&gt; void filter(T[] arrs, Predicate&lt;? super T&gt; test) &#123;\n        for (T arr : arrs) &#123;\n            if (test.test(arr)) &#123;\n                System.out.println(arr);\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;use\n    Integer[] arr &#x3D; &#123;21,52,0,1,63,52,91,2,4,2,3,9,8,1,100,22&#125;;\n    &#x2F;&#x2F; 打印arr中大于10的元素\n    filter(arr,e -&gt; e&gt;10);</code></pre>\n<ul>\n<li><code>Predicate&lt;? super T&gt;</code>，先想象T为一个具体类型Son，他是Father的子类，这里写为了<code>Predicate&lt;T&gt;</code>也是可以运行的，但是方法签名就将实参限制的太死了，若传入是Son数组，则后面只能是Son类型的函数时接口，如果我们需要使用父类的时候，而前面是子类数组，这样就行不通了。所以改为<code>Predicate&lt;? super T&gt;</code>，此时传入子类数组，依旧可以传入父类的判断逻辑。</li>\n</ul>\n<h2 id=\"通配符捕获\"><a href=\"#通配符捕获\" class=\"headerlink\" title=\"通配符捕获\"></a>通配符捕获</h2><ul>\n<li>之前提到了T可以作为一个类型来定义变量，而? 是不可以的，如果就是用? 定义该怎么来。</li>\n<li>如下通过添加一个其他的泛型方法，其他的泛型方法中的T就会捕获?的真是类型，从而可以使用T进行定义变量。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void get(List&lt;? extends Father&gt; list, int i) &#123;\n    &#x2F;&#x2F;error\n    &#x2F;&#x2F; ? f &#x3D; list.get(0);\n    Father father &#x3D; swap(list, i);\n    System.out.println(father);\n&#125;\nprivate static &lt;T&gt; T swap(List&lt;T&gt; list, int i) &#123;\n    T e &#x3D; list.get(i);\n    return e;\n&#125;\npublic static void main(String[] args) &#123;\n    List&lt;Father&gt; fathers &#x3D; Arrays.asList(new Father(&quot;Qidai&quot;));\n    get(fathers, 0);\n&#125;\n&#x2F;&#x2F; out Father&#123;name&#x3D;&#39;Qidai&#39;&#125;</code></pre>","abstracts":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"3.8k","symbolsTime":"3 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"《Java编程的逻辑》","slug":"《Java编程的逻辑》","count":6,"path":"api/tags/《Java编程的逻辑》.json"},{"name":"《写给大忙人看的Java核心技术》","slug":"《写给大忙人看的Java核心技术》","count":6,"path":"api/tags/《写给大忙人看的Java核心技术》.json"},{"name":"todo","slug":"todo","count":2,"path":"api/tags/todo.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B\"><span class=\"toc-text\">泛型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%8E%9F%E7%90%86\"><span class=\"toc-text\">原理</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E7%B1%BB\"><span class=\"toc-text\">泛型类</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">泛型方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B3%9B%E5%9E%8B%E5%8F%82%E6%95%B0%E9%99%90%E5%AE%9A\"><span class=\"toc-text\">泛型参数限定</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#extends\"><span class=\"toc-text\">extends</span></a></li><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#super\"><span class=\"toc-text\">super</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%80%9A%E9%85%8D%E7%AC%A6%E6%8D%95%E8%8E%B7\"><span class=\"toc-text\">通配符捕获</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java基础复习篇 {三}","uid":"82da61710b73b902fb02b5751a6b056e","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","updated":"2023-01-16T15:27:04.855Z","comments":true,"path":"api/articles/java/basic/basicjava3.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于《Java编程的逻辑》，《写给大忙人看的Java核心技术》以及自己的拓展总结，以书为纲，对知识点进行全面拓展，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"17k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"《Java编程的逻辑》","slug":"《Java编程的逻辑》","count":6,"path":"api/tags/《Java编程的逻辑》.json"},{"name":"《写给大忙人看的Java核心技术》","slug":"《写给大忙人看的Java核心技术》","count":6,"path":"api/tags/《写给大忙人看的Java核心技术》.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true},"next_post":{"title":"MySQL必知必会 {一}","uid":"8d49f1dff289c8a88e72afa0d38a120a","slug":"mysql/mysqlmustknow","date":"2023-01-16T13:08:37.000Z","updated":"2023-01-24T12:50:37.286Z","comments":true,"path":"api/articles/mysql/mysqlmustknow.json","keywords":null,"cover":"/img/mysql/mysqlmust.jpg","text":"以《MySQL必知必会》为纲，学习MySQL的常用操作的学习笔记。文中也会参考极客时间课程《MySQL实战45讲》。","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"MySQL基础","slug":"MySQL基础","count":1,"path":"api/categories/MySQL基础.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","count":1,"path":"api/tags/《MySQL必知必会》.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}