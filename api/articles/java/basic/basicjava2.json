{"title":"Java复习篇：继承，接口","uid":"a24485c2a08f5a5922225dff3c3d2ee2","slug":"java/basic/basicjava2","date":"2023-01-11T01:47:37.000Z","updated":"2023-02-02T10:06:34.937Z","comments":true,"path":"api/articles/java/basic/basicjava2.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<h1 id=\"继承\"><a href=\"#继承\" class=\"headerlink\" title=\"继承\"></a>继承</h1><ul>\n<li>子类不可访问父类的私有属性和方法。</li>\n<li>super只是一个关键字，用来指定访问父类的方法和变量以及构造方法，而this是实实在在的对象。</li>\n<li>当一个类继承的父类和实现的接口中有同名方法，则类优先。</li>\n<li>子类重写了父类的方法时，子类的返回值是可更改的。</li>\n<li>多态会确定对象的真实类型进行方法调用。这样写法的弊端是只能调用<code>Father</code>中的方法，如果要调用子类方法，则可以使用<code>instanceof</code>判断，将父类转为子类使用。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">Son son &#x3D; new Son();\nFather father &#x3D; son;\nfather.getMoneny();  &#x2F;&#x2F; 子类的重写将被执行\nif(father instanceof Son) &#123;\n  Son son1 &#x3D; (Son)father;\n  son1.sonMethod();\n&#125;</code></pre>\n<h2 id=\"构造器\"><a href=\"#构造器\" class=\"headerlink\" title=\"构造器\"></a>构造器</h2><ul>\n<li>子类初始化，默认调用父类无参构造器，若父类中没有，子类必须在自己的构造器中调用<code>super(params)</code>进行初始化，否则编译出错。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Father &#123;\n  public Father() &#123;\n    test();\n  &#125;\n  public void test() &#123;\n  &#125;\n&#125;\nclass Son extends Father &#123;\n  private int a &#x3D; 123;\n  public Son() &#123;&#125;\n  @Override\n  public void test() &#123;\n    System.out.println(a);\n  &#125;\n&#125;\n&#x2F;&#x2F; 使用\nSon son &#x3D; new Son();\nson.test();\n&#x2F;&#x2F; out  0   123 </code></pre>\n<ul>\n<li><code>Son</code>初始化的时候调用父类构造器，父类构造器内调用<code>tes()</code>方法，但是此时<code>Son</code>内的a变量并没被赋值，此时<code>Son</code>继承<code>Father</code>，且实际的类型为<code>Son</code>，则调用重写后的<code>test()</code>方法，输出为<code>0</code>，<code>Father</code>初始化完毕后，子类初始化，<code>a</code>变量得以赋值为<code>123</code>，此时<code>Son son = new Son()</code>执行完毕，<code>son.test()</code>输出<code>123</code>。这是一种不好的代码实践。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Father &#123;\n  public static String str &#x3D; &quot;father_base&quot;;\n  public String a &#x3D; &quot;fbase&quot;;\n  public static void test() &#123;\n    System.out.println(&quot;fbase--&gt; &quot; + str);\n  &#125;\n\n&#125;\nclass Son extends Father &#123;\n  public static String str &#x3D; &quot;son_base&quot;;\n  public String a &#x3D; &quot;sbase&quot;;\n  public static void test() &#123;\n    System.out.println(&quot;sbase--&gt; &quot; + str);\n  &#125;\n&#125;\n&#x2F;&#x2F;use\n  public static void main(String[] args) &#123;\n    Son son &#x3D; new Son();\n    System.out.println(son.a);\n    System.out.println(son.str);\n    son.test();\n    Father father &#x3D; son;\n    System.out.println(father.a);\n    System.out.println(father.str);\n    father.test();\n  &#125;\n&#x2F;&#x2F; out\nsbase\nson_base\nsbase--&gt; son_base\nfbase\nfather_base\nfbase--&gt; father_base</code></pre>\n<ul>\n<li><p>上面叫做静态绑定，实例变量，静态变量，静态方法，<code>private</code>方法都是静态绑定的，在编译的时候已经确定下来的。</p>\n</li>\n<li><p><code>protested</code>只可被子类访问，不可被外部类访问，可以被同包内类访问。</p>\n</li>\n</ul>\n<h2 id=\"细节\"><a href=\"#细节\" class=\"headerlink\" title=\"细节\"></a>细节</h2><ul>\n<li>类加载是从要加载的类的父类开始将其加载到内存的，Java的类加载是动态的。</li>\n<li>类的初始化流程：父类静态代码块，子类静态代码块，父类实例代码块，父类构造方法，子类实例代码块，子类构造方法的顺序进行初始化。</li>\n<li>JVM虚拟机的栈，堆，方法区<ul>\n<li>栈：当方法调用时会产生方法压栈，且存放函数的局部变量等。</li>\n<li>方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。</li>\n<li>堆：实例化对象存放的地方</li>\n</ul>\n</li>\n<li>初始化过程中，<ul>\n<li>对象的创建要进行分配内存，包括父类和子类的所有实例变量，不包括静态变量。</li>\n<li>对所有实例变量赋默认值，这一步在初始化之前已经完成。</li>\n<li>执行实例化初始化代码。<code>Person p = new Person()</code>，则<code>Person</code>类信息放入了方法区，<code>p</code>对象引用放入了栈内，而<code>new Person()</code>所创建的对象则放入了堆中，<code>p</code>指向堆中的对象，对象保留了方法区内的类信息的引用。</li>\n</ul>\n</li>\n<li>运行实例方法的时候是根据真实对象来找对于的方法进行执行的，若没有才找父类中的对应方法。</li>\n</ul>\n<h2 id=\"弊端\"><a href=\"#弊端\" class=\"headerlink\" title=\"弊端\"></a>弊端</h2><ul>\n<li>破坏封装，若父类更改或者增加了公开方法，则可能直接影响子类的行为，甚至导致逻辑出错。相反，子类也限制了父类随意更改实现的自由。</li>\n<li>在应用到现实生活中时，也并不是一定是严丝合缝的符合实际，鸟都会飞，那继承鸟类之后的企鹅不会飞。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>尽量少使用继承，使用继承时应将父类尽量抽象，将真正公共行为放入父类，也应考虑清楚哪些可以用final修饰以防止子类继承，进而得到更高父类的代码修改的自由度，且部分的功能可以用实现接口来实现比继承更加方便。</p></blockquote>\n<h1 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h1><ul>\n<li><p>所有方法默认为<code>public</code>。定义的变量默认为<code>public static final</code>。</p>\n</li>\n<li><p>接口允许多继承接口。类允许继承多个接口。</p>\n</li>\n<li><p>不能<code>new</code>接口，只能通过实现类来创建对象。</p>\n</li>\n<li><p>自我理解，接口更多的使用在为某一个类增加一种或多种特殊能力，而继承更像是一种模板。</p>\n</li>\n<li><p>类中 <code>extends</code> 在 <code>implements</code> 关键字之前。</p>\n</li>\n<li><p>在一些框架中，若直接用子类实现接口对象，则称面向具体编程，应避免这种情况，而采用面向接口编程。</p>\n<h2 id=\"静态方法\"><a href=\"#静态方法\" class=\"headerlink\" title=\"静态方法\"></a>静态方法</h2><ul>\n<li>通过<code>interfaceName.method()</code>限定调用。无需子类实现。<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Demo &#123;\n  public static boolean hasNext() &#123;\n    return true;\n  &#125;\n&#125;</code></pre></li>\n</ul>\n<h2 id=\"默认方法\"><a href=\"#默认方法\" class=\"headerlink\" title=\"默认方法\"></a>默认方法</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Demo &#123;\n  default boolean hasNext() &#123;\n    return true;\n  &#125;\n&#125;</code></pre>\n\n<ul>\n<li>通过子类对象调用。无需子类刻意实现。可被子类重写。</li>\n<li>例子：默认方法的使用。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\nclass Son implements Father &#123;&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\n&#x2F;&#x2F;out father</code></pre>\n\n<ul>\n<li>例子：默认方法的重写，由下代码可看出若子类调用父类的方法用<code>Father.super.method()</code>方式。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\nclass Son implements Father &#123;\n  @Override\n  public void callMe() &#123;\n    Father.super.callMe();\n    System.out.println(&quot;son&quot;);\n  &#125;\n&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\n&#x2F;&#x2F;out -&gt; father son</code></pre>\n\n<ul>\n<li>例子：当两个接口中有一样的默认方法时，必须由子类重写。即使一个提供了默认实现，另一个接口仅仅是定义的同名抽象方法。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\ninterface Mother &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;mother&quot;);\n  &#125;\n&#125;\nclass Son implements Father, Mother &#123;\n  @Override\n  public void callMe() &#123;\n    Father.super.callMe();\n  &#125;\n&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\nFather father &#x3D; new Son();\nfather.callMe();\nMother mother &#x3D; new Son();\nmother.callMe();\n&#x2F;&#x2F;out -&gt; father father father</code></pre></li>\n</ul>\n","abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"4.5k","symbolsTime":"4 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%BB%A7%E6%89%BF\"><span class=\"toc-text\">继承</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0%E5%99%A8\"><span class=\"toc-text\">构造器</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%BB%86%E8%8A%82\"><span class=\"toc-text\">细节</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BC%8A%E7%AB%AF\"><span class=\"toc-text\">弊端</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">接口</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">静态方法</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E9%BB%98%E8%AE%A4%E6%96%B9%E6%B3%95\"><span class=\"toc-text\">默认方法</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Spring6 视频学习笔记","uid":"adc2bfcc2ad0706d0cd90ba63505fb2d","slug":"spring/powernode-spring6-1","date":"2023-01-12T00:51:17.000Z","updated":"2023-01-16T15:34:38.515Z","comments":true,"path":"api/articles/spring/powernode-spring6-1.json","keywords":null,"cover":"/img/spring/OG-Spring.png","text":"来自B站中动力节点机构的教学视频学习笔记。","link":"","photos":[],"count_time":{"symbolsCount":"5.9k","symbolsTime":"5 mins."},"categories":[{"name":"Spring6","slug":"Spring6","count":1,"path":"api/categories/Spring6.json"}],"tags":[{"name":"Spring6","slug":"Spring6","count":1,"path":"api/tags/Spring6.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Java复习篇：内部类","uid":"1a10fb860efe72fabf13abf525b82b1c","slug":"java/basic/basicjava1","date":"2023-01-10T13:06:07.000Z","updated":"2023-02-02T10:07:00.863Z","comments":true,"path":"api/articles/java/basic/basicjava1.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"5.8k","symbolsTime":"5 mins."},"categories":[{"name":"java基础","slug":"java基础","count":6,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":6,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":2,"path":"api/tags/todo.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}