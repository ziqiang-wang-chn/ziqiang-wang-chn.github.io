{"title":"Java复习篇：抽象类，String，枚举","uid":"4a3de2f382252848e66f9fb50dc1dbc0","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","updated":"2023-02-02T10:10:38.637Z","comments":true,"path":"api/articles/java/basic/basicjava3.json","keywords":null,"cover":"/img/java/basicjava.jpg","content":"<div class=\"custom-quote tip\">\n<span class=\"custom-quote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06\"></path>\n<path stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M11.99 18H12.01\"></path>\n</svg></span>\n<p class=\"custom-quote-title\">注意</p>\n<p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p>\n</div>\n<h1 id=\"抽象类\"><a href=\"#抽象类\" class=\"headerlink\" title=\"抽象类\"></a>抽象类</h1><ul>\n<li>定义</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public abstract class Person &#123;\n    public abstract void call();\n&#125;</code></pre>\n\n<ul>\n<li>子类继承抽象类，则必须实现抽象类的抽象方法，或者使得子类也定义为抽象类。接口中同样有这样的规定。</li>\n<li>需要注意的是，虽然说的类，但依旧不可以使用抽象类实例化对象，必须使用其子类来创建对象，或者使用如下方法。接口中有同样的规定。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">\nPerson p &#x3D; new Person() &#123;\n    @Override\n    public void call() &#123;\n        System.out.println(&quot;person call method&quot;);\n    &#125;\n&#125;;\np.call(); \n&#x2F;&#x2F; out -&gt;   person call method</code></pre>\n<h2 id=\"抽象类和接口\"><a href=\"#抽象类和接口\" class=\"headerlink\" title=\"抽象类和接口\"></a>抽象类和接口</h2><ul>\n<li>在Java8更新后，接口中同样可以实现方法体了，这样使得抽象类与接口基本没啥不一样的了，但是还有几点不同<ul>\n<li>接口中只能定义常量， 而抽象类中可以定义实例变量。</li>\n<li>一个普通类只可以继承一个抽象类，而可以实现多个接口。</li>\n<li>抽象类的使用更多的是一种语法限制一种默认实现，使得编程的时候减少错误的发生。而接口更多的是一种能力的实现。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"枚举\"><a href=\"#枚举\" class=\"headerlink\" title=\"枚举\"></a>枚举</h1><ul>\n<li>枚举常量在静态成员之前构造，所以不能在枚举构造器中引用之外的静态变量。</li>\n<li>枚举的构造器都是私有的。</li>\n</ul>\n<h1 id=\"异常\"><a href=\"#异常\" class=\"headerlink\" title=\"异常\"></a>异常</h1><p><img src=\"/img/java/error.png\" alt=\"error\"></p>\n<h2 id=\"finally-代码块\"><a href=\"#finally-代码块\" class=\"headerlink\" title=\"finally 代码块\"></a>finally 代码块</h2><ul>\n<li>最终都会执行，当try正常执行后finally执行。若try中有异常被捕获后，进入catch执行后finally执行。若try中有异常没有被捕获，则finally在异常抛出前被捕获。</li>\n<li>catch非必须。</li>\n<li>finally中的return会覆盖掉之前的所有返回值，并且会覆盖掉所有异常。</li>\n<li>若在finally中抛出异常，则也会覆盖掉之前抛出的异常。</li>\n<li>return若出现在try或者catch中，则finally执行完毕后才执行return。如下在执行return时会将ret暂时保存起来，而finally修改的值并不会被修改。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    System.out.println(Main.getRet());\n&#125;\npublic static int getRet() &#123;\n    int ret &#x3D; 0;\n    try&#123;\n        System.out.println(&quot;try ...&quot;);\n        return ret;\n    &#125;finally &#123;\n        System.out.println(&quot;finally...&quot;);\n        ret &#x3D; 2;\n    &#125;\n&#125;\n&#x2F;&#x2F; out \ntry ...\nfinally...\n0</code></pre>\n\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static int getRet() &#123;\n    int ret &#x3D; 0;\n    try&#123;\n        ret &#x3D; 1&#x2F;0;\n    &#125;finally &#123;\n        System.out.println(&quot;finally...&quot;);\n        return ret &#x3D; 2;\n    &#125;\n&#125;\n&#x2F;&#x2F;out \nfinally...\n2</code></pre>\n\n<h2 id=\"try自动释放资源\"><a href=\"#try自动释放资源\" class=\"headerlink\" title=\"try自动释放资源\"></a>try自动释放资源</h2><ul>\n<li>位于<code>try()</code>括号中的资源将在try执行完毕后自动关闭。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">try(FileInputStream in &#x3D; new FileInputStream(&quot;filename&quot;))&#123;\n\n&#125; catch (Exception e) &#123;\n    throw new RuntimeException(e);\n&#125; </code></pre>\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>包装类<code>Integer</code>之类的应使用<code>valueOf()</code>，因为除了<code>Float</code>和<code>Double</code>，其他包装类都会缓存一些包装类对象，使用<code>valueOf()</code>更高效。</p></blockquote>\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><h2 id=\"构造\"><a href=\"#构造\" class=\"headerlink\" title=\"构造\"></a>构造</h2><ul>\n<li>在构造器<code>String(String)</code>的注释上找到一句话<code> the newly created string is a copy of the argument string.</code>，即使用构造方法创建的对象是一个副本，也就是说如下代码。s1是不等于s2的。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;A&quot;;\nString s2 &#x3D; new String(&quot;A&quot;);</code></pre>\n\n<ul>\n<li>下面则看一个比较被常调用的构造过程，总体的思路是循环判断每个字符是否可单字节编码，只要有一个不可以单字节编码，则整体切换为双字节编码。如下是详细调用过程</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">    public static void main(String[] args) &#123;\n        char[] chars &#x3D; &#123;&#39;Q&#39;,&#39;i&#39;,&#39;D&#39;,&#39;a&#39;,&#39;i&#39;&#125;;\n        String s &#x3D; new String(chars, 2, 2);\n        System.out.println(s);\n    &#125;\n    &#x2F;&#x2F; 下标从0开始算，offset&#x3D;2且count&#x3D;2，即从char数组中的第三个字母和第四个字母组成字符串返回\n    public String(char value[], int offset, int count) &#123;\n        this(value, offset, count, rangeCheck(value, offset, count));\n    &#125;\n    &#x2F;&#x2F; 这里的Void sig表示接受一次方法，此方法是无返回值的 ,此处的rangeCheck是来检查参数不出界的。\n    String(char[] value, int off, int len, Void sig) &#123;\n        if (len &#x3D;&#x3D; 0) &#123;\n            this.value &#x3D; &quot;&quot;.value;\n            this.coder &#x3D; &quot;&quot;.coder;\n            return;\n        &#125;\n        &#x2F;&#x2F; COMPACT_STRINGS默认为true\n        if (COMPACT_STRINGS) &#123;\n            &#x2F;&#x2F; 若此时返回为空，代表char数组中必有需要双字节编码的字符\n            &#x2F;&#x2F; 不为空的话，则代表char数组中字符都可以单字节编码，且已经都从char数组转换为了byte数组\n            byte[] val &#x3D; StringUTF16.compress(value, off, len);\n            if (val !&#x3D; null) &#123;\n              &#x2F;&#x2F; 转换好的数组直接赋值即可是String的底层实现。\n                this.value &#x3D; val;\n                this.coder &#x3D; LATIN1;\n                return;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 到这就是需要处理char中的双字符编码了\n        this.coder &#x3D; UTF16;\n        &#x2F;&#x2F;\n        this.value &#x3D; StringUTF16.toBytes(value, off, len);\n    &#125;\n    public static byte[] compress(char[] val, int off, int len) &#123;\n        byte[] ret &#x3D; new byte[len];\n        &#x2F;&#x2F; 若compress返回的与len参数相同，证明char中都是可单字节编码的且已经转换为byte数组，可直接用于String的底层实现了\n        &#x2F;&#x2F; 否则不同表示必须是有双字节编码了，直接返回null，再由上层函数进行下一步处理。\n        if (compress(val, off, ret, 0, len) &#x3D;&#x3D; len) &#123;\n            return ret;\n        &#125;\n        return null;\n    &#125;\n    &#x2F;&#x2F; compressedCopy char[] -&gt; byte[]\n    &#x2F;&#x2F; 整体方法思路就是循环判断每个字符是否是可以单字节编码的，如果可以，则该位置的字符直接从char转为byte，否则的话就结束本方法返回0\n    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) &#123;\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            char c &#x3D; src[srcOff];\n            &#x2F;&#x2F; 单字符可编码，即是2的八次方即0到255内的字符内的字符\n            &#x2F;&#x2F; c&gt;0xff就是循环判断每个char是否是单字节可编码的\n            if (c &gt; 0xFF) &#123;\n              &#x2F;&#x2F; 进来后表示char数组中此位置的字符必须双字节编码的字符，则len&#x3D;0，中止循环，return 0\n                len &#x3D; 0;\n                break;\n            &#125;\n            &#x2F;&#x2F; 到这表示此位置的字符是单字节可编码的，则将char转byte\n            dst[dstOff] &#x3D; (byte)c;\n            srcOff++;\n            dstOff++;\n        &#125;\n        return len;\n    &#125;\n    &#x2F;&#x2F; 双字节的字符转byte的处理方法\n&#96;&#96;    public static byte[] toBytes(char[] value, int off, int len) &#123;\n        byte[] val &#x3D; newBytesFor(len);\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            putChar(val, i, value[off]);\n            off++;\n        &#125;\n        return val;\n    &#125;\n    &#x2F;&#x2F; 得到一个存储双字符编码长度的数组\n    public static byte[] newBytesFor(int len) &#123;\n        if (len &lt; 0) &#123;\n            throw new NegativeArraySizeException();\n        &#125;\n        if (len &gt; MAX_LENGTH) &#123;\n            throw new OutOfMemoryError(&quot;UTF16 String size is &quot; + len +\n                                       &quot;, should be less than &quot; + MAX_LENGTH);\n        &#125;\n        &#x2F;&#x2F; 返回你指定字符个数的二倍大小的数组\n        return new byte[len &lt;&lt; 1];\n    &#125;\n    static void putChar(byte[] val, int index, int c) &#123;\n      &#x2F;&#x2F; 边界检查，index&gt;&#x3D;0且小于字符数\n        assert index &gt;&#x3D; 0 &amp;&amp; index &lt; length(val) : &quot;Trusted caller missed bounds check&quot;;\n        &#x2F;&#x2F; index &#x3D; index&lt;&lt;1 ，即index*2\n        index &lt;&lt;&#x3D; 1;\n        &#x2F;&#x2F; 这里是将char中的双字符一个个的进行处理，因为要双字符则是16位二进制，一个字符八个二进制\n        &#x2F;&#x2F; 这里移位就是将高位和低位分别放入byte数组中。\n        val[index++] &#x3D; (byte)(c &gt;&gt; HI_BYTE_SHIFT);\n        val[index]   &#x3D; (byte)(c &gt;&gt; LO_BYTE_SHIFT);\n    &#125;\n    static final int HI_BYTE_SHIFT;  &#x2F;&#x2F;0 \n    static final int LO_BYTE_SHIFT;  &#x2F;&#x2F;8</code></pre>\n\n\n\n<h2 id=\"存储实现\"><a href=\"#存储实现\" class=\"headerlink\" title=\"存储实现\"></a>存储实现</h2><ul>\n<li>在Java8及之前，底层存储还是<code>private final char value[]</code>， 自从9版本开始，底层实现更改了<code>private final byte[] value;</code>。其原因是：若存储字符串由英文字符组成，则在编码的时候可以使用一个byte的大小就可以表示，而存储汉字的时候，是由两个byte来实现的，对比之前的char存储实现，在最理想情况下，byte数组要比char数组要节省一半的空间。</li>\n</ul>\n<h2 id=\"length\"><a href=\"#length\" class=\"headerlink\" title=\"length( )\"></a>length( )</h2><ul>\n<li>因为其存储为字节数组，之前字符数组的时候，String的长度是计算char的个数，而现在的length的实现有些许变化。</li>\n</ul>\n  <pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">  @Native static final byte LATIN1 &#x3D; 0;\n  @Native static final byte UTF16  &#x3D; 1;\n  public int length() &#123;\n      return value.length &gt;&gt; coder();\n  &#125;\n  byte coder() &#123;\n      return COMPACT_STRINGS ? coder : UTF16;   &#x2F;&#x2F; coder 变量可取值 UTF-16和LATIN1\n  &#125;\n  static final boolean COMPACT_STRINGS;\n  static &#123;\n      COMPACT_STRINGS &#x3D; true;\n  &#125;\n&#x2F;&#x2F; use\n  System.out.println(&quot;Qidai&quot;.length());   &#x2F;&#x2F; 5 其中coder()&#x3D;0\n  System.out.println(&quot;期待&quot;.length());   &#x2F;&#x2F; 2  其中coder()&#x3D;1\n</code></pre>\n\n\n<ul>\n<li>如上有一个很重要的方法就是<code>coder()</code>，里面一个关键的字段为：<code>COMPACT_STRINGS</code>，其意思是字符串是否采用压缩存储，默认为true，若为false，则字符串始终采用<code>UTF-16</code>编码，否则就是默认开始字符串压缩，这个值是由JVM启动时注入的。</li>\n<li><code>coder()</code>方法中的<code>coder</code>变量是用来标识字符串是否为可以都用单字节编码，可以的话值为<code>LATIN1</code>，否则<code>UTF-16</code>。</li>\n<li>所以<code>coder()</code>方法的逻辑就是看是否采用字符串压缩，是的话则返回<code>coder</code>值，否则返回<code>UTF-16</code>，即返回<code>1</code>。</li>\n<li>解析：如上两个使用，第一个<code>Qidai</code>中每个字符都是可以单字节编码解决的，则<code>coder</code>变量为<code>LATIN1=0</code>，<code>COMPACT_STRINGS=true</code>，则<code>coder()</code>方法返回0，则<code>value.length</code>不变返回5。类似的，第二个使用，期待则<code>coder</code>变量返回1，由于汉字的俩字节编码的，则期待二次的<code>value.length=4</code>，最终<code>coder()</code>方法返回1，<code>4&gt;&gt;1=2</code>，则最终为2。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>String的底层实现的变动进而影响的相关类的实现，比如StringBuffer和StringBuilder的实现。其父类均为AbstractStringBuilder，其内部实现也改为了byte[]，coder的实现方式。</p></blockquote>\n<h2 id=\"不变性\"><a href=\"#不变性\" class=\"headerlink\" title=\"不变性\"></a>不变性</h2><ul>\n<li>String类的注释为：<code>Strings are constant; their values cannot be changed after they are created</code>，即字符串被创建后就不能改变了。</li>\n<li>无论从字符串的不变性从其类的final防止继承，各种私有变量，还是各种常用方法的具体实现就可以看出，都是为了保证String的不可变，常用方法对于String的每次操作都是返回一个新字符串，拿subString方法举例，来说明</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">&#x2F;&#x2F; 最终的实现都是newString，足以说明之前的字符串是不会动的，而只是返回了一个新的字符串对象。\npublic String substring(int beginIndex, int endIndex) &#123;\n    int length &#x3D; length();\n    checkBoundsBeginEnd(beginIndex, endIndex, length);\n    if (beginIndex &#x3D;&#x3D; 0 &amp;&amp; endIndex &#x3D;&#x3D; length) &#123;\n        return this;\n    &#125;\n    int subLen &#x3D; endIndex - beginIndex;\n    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                      : StringUTF16.newString(value, beginIndex, subLen);\n&#125;</code></pre>\n\n\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.zhihu.com/question/55994121\">https://www.zhihu.com/question/55994121</a><br><a href=\"http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/\">http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a></p></blockquote>\n<h2 id=\"常量池\"><a href=\"#常量池\" class=\"headerlink\" title=\"常量池\"></a>常量池</h2><ul>\n<li>常量池分，静态常量池，运行常量池，以及字符串常量池<ul>\n<li>静态常量池：当java被编译之后，通过javap可以看到属于单独类文件的常量池信息，包括字面量和符号引用。字面量包括字符串，final常量，其他数据类型的值。符号引用包括类和结构的完全限定名，字段名称和描述符，方法名称和描述符。</li>\n<li>运行时常量池：当完成类加载后，将编译成的一个个class文件加载入内存，一个class文件在方法区也对应一个独立的class的区域，其中class文件中的字符串常量将存入字符串常量池，而跟其他的分开。</li>\n<li>字符串常量池：位于方法区外面，为类中的编译期可确定的字符串，后期使用的时候也会加入新的字符串，是全局共享的。创建字符串时首先会从字符串常量池中查找是否有一样的字符串，有则直接返回引用，否则创建一个放入池中。这种操作仅限于<code>String str = &quot;xx&quot;</code>方式，对于<code>String str = new String(&quot;xx&quot;)</code>方式还略有不同。</li>\n</ul>\n</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public static void main(String[] args) &#123;\n    String sxx1 &#x3D; &quot;QIDAI&quot;;\n    String sxx2 &#x3D; new String(&quot;Qidai&quot;);\n    double d1 &#x3D; 1.2;\n    Animal animal &#x3D; new Animal();\n&#125;</code></pre>\n\n<ul>\n<li>如下，类编译后的详细信息，可以看到里面确实包含了一些常量信息，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</li>\n<li>有一个有意思的是double类型的也加入了常量池，但是如果我们修改代码为<code>double d1 = 1.0D</code>，则常量池中就找不到double的信息了，而在最下面的main的汇编代码中就会多一条<code>dconst_1</code>，若是<code>double d1 = 2.0D</code>，则多一个<code>dconst_2</code>，对于float也是如此，我猜测是jvm的优化吧，由于大部分小数是不可完全的精确表示的，所以干脆直接的放入了常量池，而对于这种<code>1.0</code>整的小数，jvm会认出来并直接使用了，这仅仅是个人猜测。</li>\n</ul>\n<pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">E:\\projects\\untitled\\target\\classes\\org\\example&gt;javap -v -c Main.class\nClassfile &#x2F;E:&#x2F;projects&#x2F;untitled&#x2F;target&#x2F;classes&#x2F;org&#x2F;example&#x2F;Main.class\n  Last modified 2023年1月16日; size 653 bytes\n  SHA-256 checksum 9a66102117f2905bdc9235cd77869b0de6f0e57cd3d953b8f19ea6b361a5d422\n  Compiled from &quot;Main.java&quot;\npublic class org.example.Main\n  minor version: 0\n  major version: 61\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #21                         &#x2F;&#x2F; org&#x2F;example&#x2F;Main\n  super_class: #2                         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类\n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool:                                                                     &#x2F;&#x2F; 静态常量池信息\n   #1 &#x3D; Methodref          #2.#3          &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         &#x2F;&#x2F; 父类的构造方法，符号引用#2,#3\n   #2 &#x3D; Class              #4             &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类object\n   #3 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V                          &#x2F;&#x2F; 引用5，6，表示无参构造\n   #4 &#x3D; Utf8               java&#x2F;lang&#x2F;Object\n   #5 &#x3D; Utf8               &lt;init&gt;\n   #6 &#x3D; Utf8               ()V\n   #7 &#x3D; String             #8             &#x2F;&#x2F; QIDAI                       &#x2F;&#x2F; 字符串常量符号引用\n   #8 &#x3D; Utf8               QIDAI                                         &#x2F;&#x2F; 字符串常量\n   #9 &#x3D; Class              #10            &#x2F;&#x2F; java&#x2F;lang&#x2F;String            \n  #10 &#x3D; Utf8               java&#x2F;lang&#x2F;String\n  #11 &#x3D; String             #12            &#x2F;&#x2F; Qidai                       &#x2F;&#x2F; 字符串常量符号引用\n  #12 &#x3D; Utf8               Qidai                                        &#x2F;&#x2F; 字符串常量\n  #13 &#x3D; Methodref          #9.#14         &#x2F;&#x2F; java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V   &#x2F;&#x2F; 字符串引用的狗崽方法\n  #14 &#x3D; NameAndType        #5:#15         &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V\n  #15 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V                          &#x2F;&#x2F; 字符串的有参构造\n  #16 &#x3D; Double             1.2d                                         &#x2F;&#x2F; 数值常量\n  #18 &#x3D; Class              #19            &#x2F;&#x2F; org&#x2F;example&#x2F;Animal         &#x2F;&#x2F; animal 的符号引用\n  #19 &#x3D; Utf8               org&#x2F;example&#x2F;Animal                           &#x2F;&#x2F; animal 的真实类型\n  #20 &#x3D; Methodref          #18.#3         &#x2F;&#x2F; org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V   &#x2F;&#x2F; animal 的无参构造\n  #21 &#x3D; Class              #22            &#x2F;&#x2F; org&#x2F;example&#x2F;Main\n  #22 &#x3D; Utf8               org&#x2F;example&#x2F;Main\n  #23 &#x3D; Utf8               Code\n  #24 &#x3D; Utf8               LineNumberTable\n  #25 &#x3D; Utf8               LocalVariableTable\n  #26 &#x3D; Utf8               this\n  #27 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Main;\n  #28 &#x3D; Utf8               main\n  #29 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V\n  #30 &#x3D; Utf8               args\n  #31 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;\n  #32 &#x3D; Utf8               sxx1                               &#x2F;&#x2F; 对象名\n  #33 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;\n  #34 &#x3D; Utf8               sxx2                               &#x2F;&#x2F; 对象名\n  #35 &#x3D; Utf8               d1\n  #36 &#x3D; Utf8               D \n  #37 &#x3D; Utf8               animal                       &#x2F;&#x2F; 对象名 \n  #38 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Animal;\n  #39 &#x3D; Utf8               SourceFile\n  #40 &#x3D; Utf8               Main.java\n&#123;\n  public org.example.Main();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1\n         0: aload_0\n         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 10: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lorg&#x2F;example&#x2F;Main;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack&#x3D;3, locals&#x3D;6, args_size&#x3D;1\n         0: ldc           #7                  &#x2F;&#x2F; String QIDAI\n         2: astore_1\n         3: new           #9                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String\n         6: dup\n         7: ldc           #11                 &#x2F;&#x2F; String Qidai\n         9: invokespecial #13                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V\n        12: astore_2\n        13: ldc2_w        #16                 &#x2F;&#x2F; double 1.2d\n        16: dstore_3\n        17: new           #18                 &#x2F;&#x2F; class org&#x2F;example&#x2F;Animal\n        20: dup\n        21: invokespecial #20                 &#x2F;&#x2F; Method org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V\n        24: astore        5\n        26: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 3\n        line 14: 13\n        line 15: 17\n        line 16: 26\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      27     0  args   [Ljava&#x2F;lang&#x2F;String;\n            3      24     1  sxx1   Ljava&#x2F;lang&#x2F;String;\n           13      14     2  sxx2   Ljava&#x2F;lang&#x2F;String;\n           17      10     3    d1   D\n           26       1     5 animal   Lorg&#x2F;example&#x2F;Animal;\n&#125;\nSourceFile: &quot;Main.java&quot;</code></pre>\n\n\n\n<h2 id=\"示例\"><a href=\"#示例\" class=\"headerlink\" title=\"示例\"></a>示例</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String str &#x3D; new String(&quot;1&quot;);\nString n &#x3D; &quot;1&quot;;\n&#x2F;&#x2F;str !&#x3D; n</code></pre>\n\n<ul>\n<li>上面说创建字符串时会在常量池中寻找,那么<code>new String(&quot;1&quot;)</code>为啥不等于<code>String str = &quot;1&quot;</code>呢？new操作其实是创建了一个真正的对象，所以这个new出来的对象1一定会在堆内存，new出来的对象是引用常量池中的对象的，如果常量池中没有这个对象，new操作就会先在常量池中新建一个常量，然后再引用他。</li>\n</ul>\n<p><img src=\"/img/java/Stringpool.png\"></p>\n<h2 id=\"intern\"><a href=\"#intern\" class=\"headerlink\" title=\"intern\"></a>intern</h2><ul>\n<li>当调用intern方法时，如果池中已经包含一个由equals方法确定的与此string对象相等的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。因此，对于任意两个字符串s和t，<code>s.intern（）==t.intern</code>为真，当且仅当<code>s.equals（t）</code>为真。</li>\n</ul>\n<h2 id=\"拼接\"><a href=\"#拼接\" class=\"headerlink\" title=\"拼接\"></a>拼接</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">String s1 &#x3D; &quot;&#39;A&quot; + &quot;B&quot;;\nString s2 &#x3D; &quot;&#39;A&quot; + new String(&quot;B&quot;);\nString s3 &#x3D; new String(&quot;A&quot;) + new String(&quot;B&quot;);\n</code></pre>\n<ul>\n<li>从javap中只发现了一个常量即”A”+”B”，在编译期间可直接确定，并放入了常量池。</li>\n<li>其他的我们可以看到的实现是用到了<code>StringConcatFactory</code>类中的<code>makeConcatWithConstants</code>拼接方法。而并非之前的<code>StringBuilder</code>实现了。</li>\n</ul>\n","feature":true,"abstracts":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"16k","symbolsTime":"15 mins."},"categories":[{"name":"java基础","slug":"java基础","count":7,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB\"><span class=\"toc-text\">抽象类</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8A%BD%E8%B1%A1%E7%B1%BB%E5%92%8C%E6%8E%A5%E5%8F%A3\"><span class=\"toc-text\">抽象类和接口</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%9A%E4%B8%BE\"><span class=\"toc-text\">枚举</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%BC%82%E5%B8%B8\"><span class=\"toc-text\">异常</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#finally-%E4%BB%A3%E7%A0%81%E5%9D%97\"><span class=\"toc-text\">finally 代码块</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#try%E8%87%AA%E5%8A%A8%E9%87%8A%E6%94%BE%E8%B5%84%E6%BA%90\"><span class=\"toc-text\">try自动释放资源</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#String\"><span class=\"toc-text\">String</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%9E%84%E9%80%A0\"><span class=\"toc-text\">构造</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E5%AE%9E%E7%8E%B0\"><span class=\"toc-text\">存储实现</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#length\"><span class=\"toc-text\">length( )</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%8D%E5%8F%98%E6%80%A7\"><span class=\"toc-text\">不变性</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E9%87%8F%E6%B1%A0\"><span class=\"toc-text\">常量池</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%A4%BA%E4%BE%8B\"><span class=\"toc-text\">示例</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#intern\"><span class=\"toc-text\">intern</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%8B%BC%E6%8E%A5\"><span class=\"toc-text\">拼接</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Redis复习：基本命令","uid":"8e53ea792c68f7c08b10733cf876a7d7","slug":"redis/basic-redis1","date":"2023-02-03T04:17:32.000Z","updated":"2023-02-03T12:03:17.352Z","comments":true,"path":"api/articles/redis/basic-redis1.json","keywords":null,"cover":"/img/redis/redis-cover.jpg","text":"基础命令复习。","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true},"next_post":{"title":"红黑树 VS AVL","uid":"fab60566d104e206f93915adac60dea5","slug":"datastructure/redblacktree-avl","date":"2023-02-02T02:07:00.000Z","updated":"2023-02-02T10:09:48.370Z","comments":true,"path":"api/articles/datastructure/redblacktree-avl.json","keywords":null,"cover":"/img/datastructure/redblacktree.png","text":"红黑树以及AVL的介绍及对比。","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"红黑树","slug":"红黑树","count":1,"path":"api/tags/红黑树.json"},{"name":"AVL","slug":"AVL","count":1,"path":"api/tags/AVL.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}