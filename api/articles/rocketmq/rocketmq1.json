{"title":"RocketMQ 基础概念","uid":"e1552f669f2d1fd29ba980d96a222d61","slug":"rocketmq/rocketmq1","date":"2023-02-19T13:35:32.000Z","updated":"2023-02-19T16:23:05.971Z","comments":true,"path":"api/articles/rocketmq/rocketmq1.json","keywords":null,"cover":"/img/rocketmq/t-k-9AxFJaNySB8-unsplash.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://rocketmq.apache.org/zh/docs/introduction/02concepts\">https://rocketmq.apache.org/zh/docs/introduction/02concepts</a></p></blockquote>\n<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p><img src=\"/img/rocketmq/topic.png\" alt=\"picture 1\">  </p>\n<ul>\n<li><strong>主题（Topic）</strong>：用于标识同一类业务逻辑的消息，所有消息资源的定义都在主题内部完成，但主题是一个逻辑概念，并不是实际的消息容器。主题通过TopicName来做唯一标识和区分。作用主要如下：<ul>\n<li>定义数据的分类隔离： 不同业务类型的数据拆分到不同的主题中管理，通过主题实现存储的隔离性和订阅隔离性。</li>\n<li>定义数据的身份和权限： 消息本身是匿名无身份的，但是可以对同一分类的消息使用相同的主题来做身份识别和权限管理。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>消息类型（MessageType）</strong>：按照消息传输特性的不同而定义的分类，用于类型管理和安全校验。支持的消息类型有普通消息、顺序消息、事务消息和定时&#x2F;延时消息。</li>\n</ul>\n<ul>\n<li><strong>消息队列（MessageQueue）</strong>：队列是 RocketMQ 中消息存储和传输的实际容器，也是消息的最小存储单元。  RocketMQ 的所有主题都是由多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。队列通过QueueId来做唯一标识和区分。主要作用如下：<ul>\n<li>存储顺序性：队列天然具备顺序性，即消息按照进入队列的顺序写入存储，同一队列间的消息天然存在顺序关系，队列头部为最早写入的消息，队列尾部为最新写入的消息。消息在队列中的位置和消息之间的顺序通过位点（Offset）进行标记管理。</li>\n<li>流式操作语义：RocketMQ 基于队列的存储模型可确保消息从任意位点读取任意数量的消息，以此实现类似聚合读取、回溯读取等特性。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><strong>消息（Message）</strong>：消息是  RocketMQ 中的最小数据传输单元。生产者将业务数据的负载和拓展属性包装成消息发送到服务端，服务端按照相关语义将消息投递到消费端进行消费。具备如下特点：<ul>\n<li>消息不可变性：消息本质上是已经产生并确定的事件，一旦产生后，消息的内容不会发生改变。即使经过传输链路的控制也不会发生变化，消费端获取的消息都是只读消息视图。</li>\n<li>消息持久化：RocketMQ 会默认对消息进行持久化，即将接收到的消息存储到  RocketMQ 服务端的存储文件中，保证消息的可回溯性和系统故障场景下的可恢复性。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><strong>消息视图（MessageView）</strong>：是面向开发视角提供的一种消息只读接口。通过消息视图可以读取消息内部的多个属性和负载信息，但是不能对消息本身做任何修改。</p>\n</li>\n<li><p><strong>消息标签（MessageTag）</strong>： 消息标签是Apache RocketMQ 提供的细粒度消息分类属性，可以在主题层级之下做消息类型的细分。消费者通过订阅特定的标签来实现细粒度过滤，根据过滤条件进行筛选匹配，将符合条件的消息投递给消费者进行消费。支持Tag标签过滤和SQL属性过滤。<br><img src=\"/img/rocketmq/message.png\" alt=\"picture 2\">  </p>\n</li>\n<li><p><strong>消息过滤</strong>：消费者可以通过订阅指定消息标签（Tag）对消息进行过滤，确保最终只接收被过滤后的消息合集。过滤规则的计算和匹配在Apache RocketMQ 的服务端完成。</p>\n</li>\n<li><p><strong>消息位点（MessageQueueOffset）</strong>：消息是按到达  RocketMQ 服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。</p>\n</li>\n<li><p><strong>消费位点（ConsumerOffset）</strong>：一条消息被某个消费者消费完成后不会立即从队列中删除， RocketMQ 会基于每个消费者分组记录。消费过的最新一条消息的位点，即消费位点。</p>\n</li>\n<li><p><strong>消息索引（MessageKey）</strong>：通过设置的消息索引可以快速查找到对应的消息内容。</p>\n</li>\n<li><p><strong>生产者（Producer）</strong>：生产者是   RocketMQ 系统中用来构建并传输消息到服务端的运行实体。生产者通常被集成在业务系统中，将业务消息按照要求封装成消息并发送至服务端。生产者和主题的关系为多对多关系，即同一个生产者可以向多个主题发送消息，对于平台类场景如果需要发送消息到多个主题，并不需要创建多个生产者；同一个主题也可以接收多个生产者的消息，以此可以实现生产者性能的水平扩展和容灾。</p>\n</li>\n<li><p><strong>事务检查器（TransactionChecker）</strong>：RocketMQ 中生产者用来执行本地事务检查和异常事务恢复的监听器。事务检查器应该通过业务侧数据的状态来检查和判断事务消息的状态。</p>\n</li>\n<li><p><strong>事务状态（TransactionResolution）</strong>：RocketMQ 中事务消息发送过程中，事务提交的状态标识，服务端通过事务状态控制事务消息是否应该提交和投递。事务状态包括事务提交、事务回滚和事务未决。</p>\n</li>\n<li><p><strong>事务消息</strong>：是   RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p>\n</li>\n<li><p><strong>消费者分组（ConsumerGroup）</strong>：消费者分组是  RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组。和消费者不同，消费者分组并不是运行实体，而是一个逻辑资源。在  RocketMQ 中，通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。</p>\n</li>\n<li><p><strong>消费者（Consumer）</strong>：消费者是  RocketMQ 中用来接收并处理消息的运行实体。消费者通常被集成在业务系统中，从服务端获取消息，并将消息转化成业务可理解的信息，供业务逻辑处理。</p>\n</li>\n<li><p><strong>消费结果（ConsumeResult）</strong>：用来标识本次消息是否正确处理。消费结果包含消费成功和消费失败。</p>\n</li>\n<li><p><strong>订阅关系（Subscription）</strong>：订阅关系是Apache RocketMQ 系统中消费者获取消息、处理消息的规则和状态配置。订阅关系由消费者分组动态注册到服务端系统，并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护。</p>\n</li>\n<li><p><strong>定时&#x2F;延时消息</strong>：定时&#x2F;延时消息是   RocketMQ 提供的一种高级消息类型，消息被发送至服务端后，在指定时间后才能被消费者消费。通过设置一定的定时时间可以实现分布式场景的延时调度触发效果。</p>\n</li>\n<li><p><strong>顺序消息</strong>：顺序消息是   RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。</p>\n</li>\n</ul>\n<h1 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://juejin.cn/post/7109262212350345224\">https://juejin.cn/post/7109262212350345224</a></p></blockquote>\n<p><img src=\"/img/rocketmq/all.png\" alt=\"picture 3\">  </p>\n<h2 id=\"Nameserver\"><a href=\"#Nameserver\" class=\"headerlink\" title=\"Nameserver\"></a>Nameserver</h2><ul>\n<li>Nameserver 集群，topic 的路由注册中心，为客户端根据 Topic 提供路由服务，从而引导客户端向 Broker 发送消息。Nameserver 之间的节点不通信。路由信息在Nameserver 集群中保持一致， NameServer 起来后监听 端口，等待 Broker、Producer、Consumer 连上来，NameServer 是集群元数据管理中心。</li>\n</ul>\n<h2 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h2><ul>\n<li>消息存储服务器，分为两种角色: Master 与 Slave，上图中呈现的就是2主2从的部署架构，在 RocketMQ 中，主服务承担读写操作，从服务器作为一个备份，当主服务器存在压力时，从服务器可以承担读服务。所有 Broker，包含 Slave 服务器每隔30s 会向Nameserver 发送心跳包，心跳包中会包含存在在 Broker 上所有的 topic 的路由信息。</li>\n<li>可以同时部署多个 Master Broker和多个 Slave Broker，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master。Master 与 Slave 需要有相同的 BrokerName，不同的 BrokerId 。BrokerId 为 0 表示 Master，非 0 表示 Slave，但只有 BrokerId&#x3D;1 的从服务器才会参与消息的读负载。</li>\n</ul>\n<h2 id=\"Client\"><a href=\"#Client\" class=\"headerlink\" title=\"Client\"></a>Client</h2><ul>\n<li>消息客户端，包括Producer(消息发送者)和Consumer(消费消费者)，客户端在同一时间只会连接一台nameserver，只有在连接出现异常时才会向尝试连接另外一台。客户端每隔 30s向Nameserver 发起topic 的路由信息查询。Nameserver是在内存中存储Topic 的路由信息，持久化Topic 路由信息的地方是在 Broker中。</li>\n</ul>\n<h3 id=\"Consumer\"><a href=\"#Consumer\" class=\"headerlink\" title=\"Consumer\"></a>Consumer</h3><ul>\n<li>在rocketMQ中，支持两种消费模式<ul>\n<li><strong>广播模式</strong>：一个消费组内的所有消费者每一个都会处理 topic 中的每一条消息，通常用于刷新内存缓存。</li>\n<li><strong>集群模式</strong>：一个消费组内的所有消费者共同消费一个topic 中的消息，即分工协作，一个消费者消费一部分数据，启动负载均衡。</li>\n</ul>\n</li>\n<li>消息的分配问题，涉及到两种最常用的算法<ul>\n<li>平均分配</li>\n<li>轮流分配</li>\n</ul>\n</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>在MQ领域有一个不成文的约定: 同一个消费者同一时间可以分配多个队列，但一个队列同一时间只会分配给一个消费者</p></blockquote>\n<h2 id=\"消费队列重平衡机制\"><a href=\"#消费队列重平衡机制\" class=\"headerlink\" title=\"消费队列重平衡机制\"></a>消费队列重平衡机制</h2><ul>\n<li>在RocketMQ 客户端中会每隔20s 去查询当前 topic 的所有队列、消费者的个数，运用队列负载算法进行重新分配，然后与上一次的分配结果进行对比，如果发生了变化，则进行队列重新分配。如果没有发生变化，则忽略。比如之前三个消费者，之后新增了一个消费者，则队列会均匀的分配到这四个消费者上。</li>\n</ul>\n<h2 id=\"消费模型\"><a href=\"#消费模型\" class=\"headerlink\" title=\"消费模型\"></a>消费模型</h2><ul>\n<li><strong>并发消费</strong>：对一个队列中消息，每一个消费者内部都会创建一个线程池，对队列中的消息多线程处理。</li>\n<li><strong>顺序消费</strong>： 在RocketMQ中提供了基于队列的顺序消费模型，即尽管一个消费组中的消费者会创建一个多线程，但针对同一个 Queue，会加锁。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>并发消费模型中，消息消费失败默认会重试 16 次，每一次的间隔时间不一样。而顺序消费，如果一条消息消费失败，则会一直消费，直到消费成功。故在顺序消费的使用过程中，应用程序需要区分系统异常、业务异常，如果是不符合业务规则导致的异常则重试多少次都无法消费成功，这个时候一定要告警机制，及时进行人为干预，否则消费会积压。</p></blockquote>\n","feature":true,"abstracts":"基础概念","text":"基础概念","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":1,"path":"api/tags/RocketMQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5\"><span class=\"toc-text\">基本概念</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9E%B6%E6%9E%84\"><span class=\"toc-text\">架构</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Nameserver\"><span class=\"toc-text\">Nameserver</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Broker\"><span class=\"toc-text\">Broker</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#Client\"><span class=\"toc-text\">Client</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#Consumer\"><span class=\"toc-text\">Consumer</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E8%B4%B9%E9%98%9F%E5%88%97%E9%87%8D%E5%B9%B3%E8%A1%A1%E6%9C%BA%E5%88%B6\"><span class=\"toc-text\">消费队列重平衡机制</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E6%B6%88%E8%B4%B9%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">消费模型</span></a></li></ol></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"Java复习篇：I/O - NIO","uid":"021047d7ebf14e407e0376e9917e9de6","slug":"java/basic/basicjava9","date":"2023-02-18T11:20:15.000Z","updated":"2023-02-19T08:12:53.334Z","comments":true,"path":"api/articles/java/basic/basicjava9.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"7k","symbolsTime":"6 mins."},"categories":[{"name":"java基础","slug":"java基础","count":9,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":9,"path":"api/tags/java.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true}}