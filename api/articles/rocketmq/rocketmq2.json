{"title":"RocketMQ 消息","uid":"36e1e3e5ba9cb5123131543205c11d74","slug":"rocketmq/rocketmq2","date":"2023-02-20T14:17:32.000Z","updated":"2023-02-20T14:17:41.881Z","comments":true,"path":"api/articles/rocketmq/rocketmq2.json","keywords":null,"cover":"/img/rocketmq/t-k-9AxFJaNySB8-unsplash.jpg","content":"<h1 id=\"安装RocketMQ\"><a href=\"#安装RocketMQ\" class=\"headerlink\" title=\"安装RocketMQ\"></a>安装RocketMQ</h1><ul>\n<li>首先调整<code>bin/runbroker</code>和<code>bin/runserver</code>的内存占用大小，后在<code>conf/broker.conf</code>中加入 <code>namesrvAddr=127.0.0.1:9876</code>。</li>\n<li>安装RocketMQ5.0.0的一个大坑，就是必须先修改掉bin&#x2F;mqbroker脚本中的代码<pre class=\"line-numbers language-bash\" data-language=\"bash\"><code class=\"language-bash\"># 之前是双括号，要将双括号改成单括号  while [ $# -gt 0 ];\n# ...\nwhile [[ $# -gt 0 ]]; do\n  case $1 in\n# ...</code></pre></li>\n</ul>\n<details class=\"custom-details\">\n<summary>隐藏内容</summary>\n<p><pre class=\"line-numbers language-markup\" data-language=\"markup\"><code class=\"language-markup\">&lt;dependency&gt;\n    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;\n    &lt;artifactId&gt;rocketmq-client&lt;&#x2F;artifactId&gt;\n    &lt;version&gt;5.0.0&lt;&#x2F;version&gt;\n&lt;&#x2F;dependency&gt;</code></pre>\n</p>\n</details>\n<h1 id=\"普通消息\"><a href=\"#普通消息\" class=\"headerlink\" title=\"普通消息\"></a>普通消息</h1><h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li>一般应用于微服务解耦、事件驱动、数据集成等场景，要求数据传输通道具有<strong>可靠传输的能力</strong>，且对消息的<strong>处理时机、处理顺序没有特别要求</strong>。支持生产者和消费者的异步解耦通信。<ul>\n<li>微服务异步解耦：电商交易场景，上层订单系统产生的消息供下游系统使用，实现解耦。</li>\n<li>数据集成传输：离线的日志收集场景，不做任何处理，将日志顺序传送至下游系统使用。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"生命周期\"><a href=\"#生命周期\" class=\"headerlink\" title=\"生命周期\"></a>生命周期</h2><ul>\n<li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li>\n<li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li>\n<li>消费中：消息被消费者获取并按业务进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ会对消息进行重试处理。</li>\n<li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。  RocketMQ默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li>\n<li>消息删除：RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li>\n<li><strong>建议</strong>：设置全局唯一业务索引键，方便问题追踪。</li>\n</ul>\n<h2 id=\"使用\"><a href=\"#使用\" class=\"headerlink\" title=\"使用\"></a>使用</h2><pre class=\"line-numbers language-java\" data-language=\"java\"><code class=\"language-java\">public class Producer &#123;\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F; 1.创建一个发送消息的对象Producer\n        DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;group1&quot;);  &#x2F;&#x2F; 入参为自定义组名\n        &#x2F;&#x2F; 2.设定发送的命名服务器地址\n        producer.setNamesrvAddr(&quot;192.168.137.29:9876&quot;);\n        &#x2F;&#x2F; 设置发送消息超时时间（默认为3000）\n        producer.setSendMsgTimeout(60000);\n        &#x2F;&#x2F; 3.启动发送的服务\n        producer.start();\n        &#x2F;&#x2F; 4.创建要发送的消息对象,指定topic和body\n        Message msg &#x3D; new Message(&quot;topic1&quot;, &quot;test-tag&quot;,\n                &quot;业务ID&quot;, &quot;hello rocketmq&quot;.getBytes(&quot;UTF-8&quot;));\n        &#x2F;&#x2F; 5.发送单条消息\n        SendResult result &#x3D; producer.send(msg);\n        &#x2F;&#x2F; 打印返回消息\n        System.out.println(&quot;返回结果：&quot;+result);\n        &#x2F;&#x2F; 6.关闭连接\n        producer.shutdown();\n    &#125;\n&#125;\npublic class Consumer &#123;\n    public static void main(String[] args) throws Exception &#123;\n        &#x2F;&#x2F; 1.创建一个接收消息的对象Consumer\n        DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;group1&quot;);  &#x2F;&#x2F; 入参为自定义组名\n        &#x2F;&#x2F; 2.设定接收的命名服务器地址\n        consumer.setNamesrvAddr(&quot;192.168.137.29:9876&quot;);\n        &#x2F;&#x2F; 3.设置接收消息对应的topic，对应的sub标签为任意*\n        consumer.subscribe(&quot;topic1&quot;, &quot;*&quot;);\n        &#x2F;&#x2F; 4.开启监听，用于接收消息\n        consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeConcurrentlyContext) -&gt; &#123;\n            &#x2F;&#x2F; 遍历消息\n            for(MessageExt msg : list)&#123;\n                System.out.println(&quot;消息：&quot; + new String(msg.getBody()));\n            &#125;\n            &#x2F;&#x2F; 成功处理后，mq 收到该标记，则相同的消息将不会再次发给消费者\n            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;\n        &#125;);\n        &#x2F;&#x2F; 5.启动接收消息的服务\n        consumer.start();  &#x2F;&#x2F; 开启多线程监控消息，会持续运行\n        System.out.println(&quot;接收消息服务已开启运行&quot;);\n    &#125;\n&#125;\n</code></pre>\n<h1 id=\"\"><a href=\"#\" class=\"headerlink\" title=\"\"></a></h1>","feature":true,"abstracts":"消息使用","text":"消息使用","link":"","photos":[],"count_time":{"symbolsCount":"3k","symbolsTime":"3 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/tags/RocketMQ.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AE%89%E8%A3%85RocketMQ\"><span class=\"toc-text\">安装RocketMQ</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%99%AE%E9%80%9A%E6%B6%88%E6%81%AF\"><span class=\"toc-text\">普通消息</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF\"><span class=\"toc-text\">应用场景</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F\"><span class=\"toc-text\">生命周期</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%BD%BF%E7%94%A8\"><span class=\"toc-text\">使用</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\"><span class=\"toc-text\"></span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{},"next_post":{"title":"RocketMQ 基础概念","uid":"e1552f669f2d1fd29ba980d96a222d61","slug":"rocketmq/rocketmq1","date":"2023-02-19T13:35:32.000Z","updated":"2023-02-19T16:23:05.971Z","comments":true,"path":"api/articles/rocketmq/rocketmq1.json","keywords":null,"cover":"/img/rocketmq/t-k-9AxFJaNySB8-unsplash.jpg","text":"基础概念","link":"","photos":[],"count_time":{"symbolsCount":"4.1k","symbolsTime":"4 mins."},"categories":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/categories/RocketMQ.json"}],"tags":[{"name":"RocketMQ","slug":"RocketMQ","count":2,"path":"api/tags/RocketMQ.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"feature":true}}