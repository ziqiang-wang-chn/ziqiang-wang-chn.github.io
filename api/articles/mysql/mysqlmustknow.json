{"title":"MySQL必知必会 {一}","uid":"8d49f1dff289c8a88e72afa0d38a120a","slug":"mysql/mysqlmustknow","date":"2023-01-16T13:08:37.000Z","updated":"2023-01-24T12:50:37.286Z","comments":true,"path":"api/articles/mysql/mysqlmustknow.json","keywords":null,"cover":"/img/mysql/mysqlmust.jpg","content":"<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>所有操作的数据源来自《MySQL必知必会》，使用MySQL 8.0 进行学习</p></blockquote>\n<p><img src=\"/img/mysql/mysqlstruc.png#pic_center\"></p>\n<ul>\n<li>MySQL 可以分为 Server 层和存储引擎层两部分<ul>\n<li>Server 层包括连接器、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li>\n<li>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"Select过程\"><a href=\"#Select过程\" class=\"headerlink\" title=\"Select过程\"></a>Select过程</h1><ul>\n<li>连接器：如果用户名密码认证通过，连接器会得到相对应登入用户的该有权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</li>\n<li>分析器：MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</li>\n<li>优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。以达到最高的执行效率。</li>\n<li>执行器：负责SQL的执行。</li>\n</ul>\n<h1 id=\"Update过程\"><a href=\"#Update过程\" class=\"headerlink\" title=\"Update过程\"></a>Update过程</h1><ul>\n<li>大致与SELECT的过程是一样的，中间不一样的涉及到了两个重要的日志模块，redo log（重做日志）和 binlog（归档日志）。</li>\n</ul>\n<h2 id=\"redo-Log-（InnoDB特有）\"><a href=\"#redo-Log-（InnoDB特有）\" class=\"headerlink\" title=\"redo Log （InnoDB特有）\"></a>redo Log （InnoDB特有）</h2><ul>\n<li>在 MySQL里若每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了先写入日志文件后将日志中的条目总和一并写入磁盘中的思路来提升更新效率。</li>\n<li>先写日志再写磁盘的就是MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging。比如当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。若更新相当频繁以至于redo log写满了，则需要先暂停更新操作，将一部分redo log写入磁盘以腾出新空间来供新的更新操作记录。</li>\n<li>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，类似一个循环队列。</li>\n<li>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</li>\n</ul>\n<h2 id=\"bin-log\"><a href=\"#bin-log\" class=\"headerlink\" title=\"bin log\"></a>bin log</h2><ul>\n<li>处理InnoDB特有的，Server层自己的日志叫做 bin log。bin log日志只能用于归档。</li>\n</ul>\n<h2 id=\"redo-log与bin-log-区别\"><a href=\"#redo-log与bin-log-区别\" class=\"headerlink\" title=\"redo log与bin log 区别\"></a>redo log与bin log 区别</h2><ul>\n<li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li>\n<li>redo log 是循环写的，空间固定会用完；bin log 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li>\n</ul>\n<h2 id=\"update内部流程\"><a href=\"#update内部流程\" class=\"headerlink\" title=\"update内部流程\"></a>update内部流程</h2><ul>\n<li>先找主键，id是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li>\n<li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li>\n<li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li>\n<li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li>\n<li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li>\n</ul>\n<h2 id=\"redo-log两段提交\"><a href=\"#redo-log两段提交\" class=\"headerlink\" title=\"redo log两段提交\"></a>redo log两段提交</h2><ul>\n<li>redo log 和 bin log 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</li>\n</ul>\n<details class=\"custom-details\">\n<summary>不采用两段式提交的结果</summary>\n<p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p>\n<p>仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p>\n<p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。<br>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。<br>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p>\n</details>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。<br><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p></blockquote>\n<ul>\n<li><code>show columns from customers;</code> 快捷语句 ：<code>describe customers;</code>。</li>\n<li>查看表的创建语句 <code>show create tables customers;</code>。</li>\n</ul>\n<h1 id=\"SELECT\"><a href=\"#SELECT\" class=\"headerlink\" title=\"SELECT\"></a>SELECT</h1><ul>\n<li>去重：<code>select distinct vend_id from products;</code>，<code>distinct</code>应用于所有列，即把要查询字段当作一个整体去重。</li>\n<li>限制：<code>select * from customers limit 5;</code> 零到五行，<code>limit 3,5</code>，从第3个往后5个。</li>\n<li>排序：<code>select prod_name from products order by prod_price ;</code>，<code>order by</code>后可以是显示列也可以是其他列，也可以是按照多个列排序。<code>DESC</code>降序，默 认为升序<code>ASC</code>。 <code>order by</code> 应位于<code>where</code>之后。</li>\n<li>where：与串对比时需要加单引号。<ul>\n<li>比较运算符：<code>&gt;</code>， <code>&lt;</code>，<code>=</code> ，<code>is null</code> …</li>\n<li>逻辑运算符：<code>and</code> ，<code>or</code> ,<code>and</code> 优先级高于 <code>or</code>。<code>in</code>是一个范围，<code>in</code>一般比<code>or</code>执行快。<code>not</code>可对<code>in</code>，<code>exists</code>，<code>between</code>取反。</li>\n<li><code>like</code>：<code>%</code>任意字符任意次数，搜索区分大小写，<code>%</code>不可匹配<code>null</code>。<code>_</code>单个字符。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.runoob.com/mysql/mysql-functions.html\">https://www.runoob.com/mysql/mysql-functions.html</a></p></blockquote>\n<ul>\n<li><code>avg</code> 自动忽略null。</li>\n<li><code>count(*)</code>不忽略null，<code>count(column)</code>忽略null。</li>\n</ul>\n<h1 id=\"Group-by\"><a href=\"#Group-by\" class=\"headerlink\" title=\"Group by\"></a>Group by</h1><ul>\n<li>可以包含任意多的列名，数据将在最后的列上进行分组汇总。</li>\n<li>Group by中出现的列必须是检索列，Select中除聚集计算外，每个列必须在group by中给出。</li>\n<li>null值作为单独一个分组返回。</li>\n<li>必须位于where之后。 order by之前。</li>\n<li>with rollup，得到每个分组的汇总信息。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; select vend_id,count(*) as num_prods from products group by vend_id with rollup;\n+---------+-----------+\n| vend_id | num_prods |\n+---------+-----------+\n|    1001 |         3 |\n|    1002 |         2 |\n|    1003 |         7 |\n|    1005 |         2 |\n|    NULL |        14 |\n+---------+-----------+\n5 rows in set (0.29 sec)\n\nmysql&gt; select vend_id,count(*) as num_prods from products group by vend_id;\n+---------+-----------+\n| vend_id | num_prods |\n+---------+-----------+\n|    1001 |         3 |\n|    1002 |         2 |\n|    1003 |         7 |\n|    1005 |         2 |\n+---------+-----------+\n4 rows in set (0.00 sec)</code></pre>\n\n<h1 id=\"having\"><a href=\"#having\" class=\"headerlink\" title=\"having\"></a>having</h1><ul>\n<li>where针对行过滤，having针对分组过滤。WHERE 在数据分组前进行过滤， HAVING在数据分组后进行过滤。</li>\n<li><strong>子查询</strong>：列必须匹配在WHERE子句中使用子查询， 应该保证SELECT语句具有与WHERE子句中相同数目的列。 通常子查询将返回单个列并且与单个列匹配， 但如果需要也可以使用多个列。</li>\n</ul>\n<h1 id=\"UNION\"><a href=\"#UNION\" class=\"headerlink\" title=\"UNION\"></a>UNION</h1><ul>\n<li>UNION 中的每个查询必须包含相同的列、 表达式或聚集函数（不过各个列不需要以相同的次序列出） 。</li>\n<li>UNION 从查询结果集中自动去除了重复的行，如果想返回所有匹配行， 可使用UNION ALL。</li>\n<li>在用UNION 组合查询时， 只能使用一条ORDER BY 子句， 它必须出现在最后一条SELECT 语句之后。</li>\n</ul>\n<h1 id=\"视图\"><a href=\"#视图\" class=\"headerlink\" title=\"视图\"></a>视图</h1> <pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE VIEW productcustomers AS SQL</code></pre>\n<ul>\n<li>视图是虚拟的表。 与包含数据的表不一样， 视图只包含使用时动态检索数据的查询。视图本身不包含数据， 因此它们返回的数据是从其他表中检索出来的。</li>\n<li>在添加或更改这些表中的数据时， 视图将返回改变过的数据。</li>\n<li>视图可以嵌套， 即可以利用从其他视图中检索数据的查询来构造一个视图。</li>\n<li>视图不能索引， 也不能有关联的触发器或默认值。</li>\n<li>视图可以和表一起使用。 例如， 编写一条联结表和视图的SELECT 语句。</li>\n</ul>\n<h1 id=\"存储过程\"><a href=\"#存储过程\" class=\"headerlink\" title=\"存储过程\"></a>存储过程</h1><blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.yiibai.com/mysql/stored-procedure.html#article-start\">https://www.yiibai.com/mysql/stored-procedure.html#article-start</a><br><a href=\"https://blog.csdn.net/whf_a/article/details/114871866\">https://blog.csdn.net/whf_a/article/details/114871866</a><br>SQLSTATE状态码：<a href=\"https://blog.csdn.net/cao478208248/article/details/27647419\">https://blog.csdn.net/cao478208248/article/details/27647419</a></p></blockquote>\n<ul>\n<li>简单、 安全、 高性能，因为存储过程得创建是编译后再存储的，所以使用存储过程比使用单独的SQL语句要快。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 声明变量的语法\nDECLARE variable_name datatype(size) DEFAULT default_value;\n-- 设置变量值\nSET total_count &#x3D; 10;\n-- 也可以用into方式设置变量值\nSELECT COUNT(*) INTO total_products FROM products</code></pre>\n\n\n\n\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 模板，当使用图形化界面时，可省略DELIMITER\nDELIMITER &#x2F;&#x2F;\n CREATE PROCEDURE GetAllProducts()\n   BEGIN\n   SELECT *  FROM products;\n   END &#x2F;&#x2F;\nDELIMITER ;</code></pre>\n\n<ul>\n<li><code>DELIMITER \\\\</code>语句将标准分隔符 <code>;</code>更改为：<code>//</code>。<code>BEGIN </code>和<code>END</code>之间的部分称为存储过程的主体。</li>\n</ul>\n<p>MySQL游标只能用于存储过程（和函数） </p>\n<h1 id=\"触发器\"><a href=\"#触发器\" class=\"headerlink\" title=\"触发器\"></a>触发器</h1><ul>\n<li>创建触发器需要四条信息：触发器名；触发器关联的表；触发器应该响应的活动（DELETE 、 INSERT 或UPDATE ） ；触发器何时执行（处理之前或之后） 。</li>\n<li>触发器名称应遵循命名约定<code>[trigger time]_[table name]_[trigger event]</code>，例如<code>before_employees_update</code>.</li>\n<li>只有表才支持触发器， 视图不支持，每个表每个事件每次只允许一个触发器。单一触发器不能与多个事件或多个表关联。</li>\n<li>如果before触发器执行失败，sql也会执行失败，sql在执行失败时，after型触发器不会执行，如果after触发器执行失败，sql会回滚。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">CREATE TRIGGER trigger_name trigger_time trigger_event\n ON table_name\n FOR EACH ROW\n BEGIN\n ...\n END;</code></pre>\n\n<h2 id=\"INSERT\"><a href=\"#INSERT\" class=\"headerlink\" title=\"INSERT\"></a>INSERT</h2><ul>\n<li>在INSERT 触发器代码内， 可引用一个名为 <code>NEW</code> 的虚拟表， 访问被插入的行；</li>\n<li>在BEFORE INSERT 触发器中， <code>NEW</code> 中的值也可以被更新（允许更改被插入的值） ；</li>\n<li>对于<code>AUTO_INCREMENT</code> 列， <code>NEW</code> 在INSERT 执行之前包含0 ， 在INSERT 执行之后包含新的自动生成值。</li>\n<li><strong>实例：</strong>从下面可以看到可以从 <code>new</code> 虚拟表中获得自增后的最新值。且注意在MySQL8中，触发器不再支持由SELECT方式的返回值，只能将结果放入一个变量中带回。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">mysql&gt; desc orders;\n+------------+----------+------+-----+---------+----------------+\n| Field      | Type     | Null | Key | Default | Extra          |\n+------------+----------+------+-----+---------+----------------+\n| order_num  | int      | NO   | PRI | NULL    | auto_increment |\n| order_date | datetime | NO   |     | NULL    |                |\n| cust_id    | int      | NO   | MUL | NULL    |                |\n+------------+----------+------+-----+---------+----------------+\n3 rows in set (0.00 sec)\nmysql&gt; select * from orders;\n+-----------+---------------------+---------+\n| order_num | order_date          | cust_id |\n+-----------+---------------------+---------+\n|     20005 | 2005-09-01 00:00:00 |   10001 |\n|     20006 | 2005-09-12 00:00:00 |   10003 |\n|     20007 | 2005-09-30 00:00:00 |   10004 |\n|     20008 | 2005-10-03 00:00:00 |   10005 |\n|     20009 | 2005-10-08 00:00:00 |   10001 |\n|     20011 | 2006-02-23 00:00:00 |   10001 |\n|     20012 | 2006-02-23 00:00:00 |   10001 |\n+-----------+---------------------+---------+\n7 rows in set (0.00 sec)\nmysql&gt; create trigger after_insert_orders after insert on orders for each row select new.order_num into @a;\nQuery OK, 0 rows affected (1.64 sec)\n\nmysql&gt; select @a;\n+------------+\n| @a         |\n+------------+\n| NULL       |\n+------------+\n1 row in set (0.00 sec)\nmysql&gt; insert into orders(order_Date,cust_id) values(&#39;2006-05-23 00:00:00&#39;,10001);\nQuery OK, 1 row affected (0.05 sec)\n\nmysql&gt; select @a;\n+-------+\n| @a    |\n+-------+\n| 20013 |\n+-------+\n1 row in set (0.00 sec)</code></pre>\n\n<h2 id=\"DELETE\"><a href=\"#DELETE\" class=\"headerlink\" title=\"DELETE\"></a>DELETE</h2><ul>\n<li>在DELETE 触发器代码内， 你可以引用一个名为 <code>OLD</code> 的虚拟表， 访问被删除的行；<code>OLD</code> 中的值全都是只读的， 不能更新。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 从info中删除的信息插入info_copy表中。\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  1 | Ricky Simmons |  867 |\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n5 rows in set (0.00 sec)\n\nmysql&gt; select * from info_copy;\nEmpty set (0.00 sec)\n\nmysql&gt; create trigger before_delete_info before delete on info for each row insert into info_copy(no,name,age) values (old.no,old.name,old.age);\nQuery OK, 0 rows affected (0.11 sec)\n\nmysql&gt; delete from info where no&#x3D;1;\nQuery OK, 1 row affected (0.03 sec)\n\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n4 rows in set (0.00 sec)\n\nmysql&gt; select * from info_copy;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  1 | Ricky Simmons |  867 |\n+----+---------------+------+\n1 row in set (0.00 sec)</code></pre>\n\n<h2 id=\"UPDATE\"><a href=\"#UPDATE\" class=\"headerlink\" title=\"UPDATE\"></a>UPDATE</h2><ul>\n<li>在UPDATE 触发器代码中， 你可以引用一个名为<code>OLD </code>的虚拟表访问以前（UPDATE 语句前） 的值， 引用一个名为<code>NEW </code>的虚拟表访问新更新的值；</li>\n<li>在BEFORE UPDATE 触发器中， <code>NEW </code>中的值可能也被更新（允许更改将要用于UPDATE 语句中的值） ；</li>\n<li><code>OLD </code>中的值全都是只读的， 不能更新。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 在更新的时候，将指定no的一行信息的名字改为 Qidai。\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n4 rows in set (0.00 sec)\n\nmysql&gt; update info set age&#x3D;11 where no&#x3D;2;\nQuery OK, 1 row affected (0.09 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nmysql&gt; select * from info;\n+----+-------------+------+\n| no | name        | age  |\n+----+-------------+------+\n|  2 | Qidai       |   11 |\n|  3 | Ueda Kenta  |  950 |\n|  4 | Ikeda Akina |  681 |\n|  5 | Fan Yunxi   |  583 |\n+----+-------------+------+\n4 rows in set (0.00 sec)</code></pre>\n\n<h1 id=\"事务\"><a href=\"#事务\" class=\"headerlink\" title=\"事务\"></a>事务</h1><ul>\n<li>开始一个事务：<code>START TRANSACTION;</code>。</li>\n<li>回滚一个事务：<code>ROLLBACK</code>。</li>\n<li>设置保存点：<code>SAVEPOINT delete1;</code>。</li>\n<li>混滚至具体的保存点：<code>ROLLBACK TO delete1;</code>。</li>\n<li>设置不自动提交：<code>SET autocommit=0;</code>。</li>\n<li>事务处理用来管理 <code>INSERT</code> 、 <code>UPDATE</code> 和 <code>DELETE</code> 语句。</li>\n<li>保留点在事务处理完成（执行一条 <code>ROLLBACK</code> 或 <code>COMMIT</code> ） 后自动释放 ，也可以用<code>RELEASE SAVEPOINT</code> 明确地释放保留点。</li>\n<li><code>autocommit</code> 标志是针对每个连接而不是服务器的。</li>\n</ul>\n","abstracts":"以《MySQL必知必会》为纲，学习MySQL的常用操作的学习笔记。文中也会参考极客时间课程《MySQL实战45讲》。","text":"以《MySQL必知必会》为纲，学习MySQL的常用操作的学习笔记。文中也会参考极客时间课程《MySQL实战45讲》。","link":"","photos":[],"count_time":{"symbolsCount":"10k","symbolsTime":"9 mins."},"categories":[{"name":"MySQL基础","slug":"MySQL基础","count":1,"path":"api/categories/MySQL基础.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/tags/MySQL.json"},{"name":"《MySQL必知必会》","slug":"《MySQL必知必会》","count":1,"path":"api/tags/《MySQL必知必会》.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Select%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Select过程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Update%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">Update过程</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redo-Log-%EF%BC%88InnoDB%E7%89%B9%E6%9C%89%EF%BC%89\"><span class=\"toc-text\">redo Log （InnoDB特有）</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#bin-log\"><span class=\"toc-text\">bin log</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redo-log%E4%B8%8Ebin-log-%E5%8C%BA%E5%88%AB\"><span class=\"toc-text\">redo log与bin log 区别</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#update%E5%86%85%E9%83%A8%E6%B5%81%E7%A8%8B\"><span class=\"toc-text\">update内部流程</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#redo-log%E4%B8%A4%E6%AE%B5%E6%8F%90%E4%BA%A4\"><span class=\"toc-text\">redo log两段提交</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#SELECT\"><span class=\"toc-text\">SELECT</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%87%BD%E6%95%B0\"><span class=\"toc-text\">函数</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Group-by\"><span class=\"toc-text\">Group by</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#having\"><span class=\"toc-text\">having</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#UNION\"><span class=\"toc-text\">UNION</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%86%E5%9B%BE\"><span class=\"toc-text\">视图</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B\"><span class=\"toc-text\">存储过程</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E8%A7%A6%E5%8F%91%E5%99%A8\"><span class=\"toc-text\">触发器</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#INSERT\"><span class=\"toc-text\">INSERT</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#DELETE\"><span class=\"toc-text\">DELETE</span></a></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#UPDATE\"><span class=\"toc-text\">UPDATE</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E4%BA%8B%E5%8A%A1\"><span class=\"toc-text\">事务</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java复习篇：泛型","uid":"216c1df589f41fe3d75a0e63e395221b","slug":"java/basic/basicjava4","date":"2023-01-17T01:58:04.000Z","updated":"2023-02-02T10:08:50.240Z","comments":true,"path":"api/articles/java/basic/basicjava4.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"3.7k","symbolsTime":"3 mins."},"categories":[{"name":"java基础","slug":"java基础","count":7,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":4,"path":"api/tags/todo.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Spring6-注入方式","uid":"451e8b3038f6c87fffb50c6a654b133c","slug":"spring/spring6-1","date":"2023-01-12T00:51:17.000Z","updated":"2023-02-06T05:26:49.006Z","comments":true,"path":"api/articles/spring/spring6-1.json","keywords":null,"cover":"/img/spring/OG-Spring.png","text":"来自教学视频学习笔记。","link":"","photos":[],"count_time":{"symbolsCount":"19k","symbolsTime":"17 mins."},"categories":[{"name":"Spring6","slug":"Spring6","count":1,"path":"api/categories/Spring6.json"}],"tags":[{"name":"Spring6","slug":"Spring6","count":1,"path":"api/tags/Spring6.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}