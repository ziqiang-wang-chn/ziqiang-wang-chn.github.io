{"title":"MySQL - 索引","uid":"db4d44c0ea1308c9e8989aac4272f703","slug":"mysql/mysql1","date":"2023-02-08T14:58:37.000Z","updated":"2023-02-15T12:38:26.492Z","comments":true,"path":"api/articles/mysql/mysql1.json","keywords":null,"cover":"/img/mysql/mysqlmust.jpg","content":"<h1 id=\"常用索引模型\"><a href=\"#常用索引模型\" class=\"headerlink\" title=\"常用索引模型\"></a>常用索引模型</h1><ul>\n<li>哈希表：既然涉及到了Hash，则最快的效率一定是直接可以根据Hash进行定位。但是难免会有冲突的时候，冲突的时候会链接成链表，此时若链表很长，且若链表内的信息都无序，若要查找一个特定的值，或查找一个区间内的值，则只能遍历，则查询效率也是很低的。所以<strong>哈希表这种结构适用于只有等值查询的场景</strong>。</li>\n<li>有序数组：<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>，因为是有序的，所以查找一个值可以用二分查找，若再区间内查值，因为是有序的，则也可以使用二分查找，但是对于数据频繁插入的时期下，数组元素的移动是相当耗费时间的。所以<strong>有序数组索引只适用于静态存储引擎</strong>。</li>\n<li>搜索树：最直接的就想到了二叉平衡查找树，但是若树深20，则每次查找一个值，都平均需要比较20次才会找到一个值，查询效率也不是很高，所以引入了多叉树，越多叉越能够减少比较次数。所以多叉树广泛应用到数据库中。</li>\n</ul>\n<h1 id=\"InnoDB的索引模型\"><a href=\"#InnoDB的索引模型\" class=\"headerlink\" title=\"InnoDB的索引模型\"></a>InnoDB的索引模型</h1><ul>\n<li>InnoDB中使用了 B+ 树，每个索引在 InnoDB 中都对应一颗树。</li>\n<li>B+树的叶子节点是page （页），一个页里面可以存多个行。页内部有个有序数组，二分法进行查找匹配行。</li>\n<li>比如下面一张表</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">create table T(\nid int primary key,\nk int not null,\nindex (k))engine&#x3D;InnoDB;\n-- data: (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)</code></pre>\n\n<ul>\n<li>对应的结构为</li>\n</ul>\n<p><img src=\"/img/mysql/innodb-index.png\" alt=\"picture 1\">  </p>\n<h2 id=\"主键索引和普通索引\"><a href=\"#主键索引和普通索引\" class=\"headerlink\" title=\"主键索引和普通索引\"></a>主键索引和普通索引</h2><ul>\n<li><strong>主键索引</strong>：只要搜索ID这个B+ Tree即可拿到数据。</li>\n<li><strong>普通索引</strong>：先搜索索引拿到主键值，再到主键搜索ID索引树搜索一次(回表)。共查询两次。</li>\n</ul>\n<p><img src=\"/img/mysql/b+tree.png\"></p>\n<h3 id=\"思考\"><a href=\"#思考\" class=\"headerlink\" title=\"思考\"></a>思考</h3><p><img src=\"/img/mysql/innodb-index.png\" alt=\"picture 1\">  </p>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p> 数据如上，结构与上面建表语句一致，问 select * from T where k between 3 and 5 ; 有几次id树的搜索操作。</p></blockquote>\n<ul>\n<li>解析：<ul>\n<li>当查询3时，搜索k树找到ID为300，回表搜索id树，记一次。</li>\n<li>当查询4时，k树中无值。无操作。</li>\n<li>当查询5时，搜索k树找到ID为500，回表搜索id树，记一次。共两次ID树的搜索操作。</li>\n</ul>\n</li>\n<li>优化：若想减少回表操作，则可以使用 <code>select id from T where k between 3 and 5 ;</code>，因为在k树中搜索到了相应的k值后，k值得叶子会直接拿到ID值。</li>\n</ul>\n<h2 id=\"索引维护\"><a href=\"#索引维护\" class=\"headerlink\" title=\"索引维护\"></a>索引维护</h2><ul>\n<li>因为B+树的特性，如果索引是比较有序的，如数据库中得自增ID，则B+树每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，这样效率是很高的。</li>\n<li>若索引插入是比较无序的，比如某个业务的id作为索引，会造成数据的频繁挪动，甚至分裂出其他的分支，这个过程称为页分裂。页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li>\n<li><strong>综上</strong>，则插入的索引有序是十分有利的。<strong>自增主键往往是更合理的选择，且建议设置为bigint unsigned</strong>。</li>\n<li>如果删除再新建主键索引，它会使得所有的二级索引都失效，并且会用ROWID来作主键索引，性能消耗比较大。删除再重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。</li>\n</ul>\n<h1 id=\"最左前缀原则\"><a href=\"#最左前缀原则\" class=\"headerlink\" title=\"最左前缀原则\"></a>最左前缀原则</h1><p><img src=\"/img/mysql/left.png\" alt=\"picture 2\">  </p>\n<ul>\n<li>如上建立了一个name&amp;age得联合索引，当name定义在左侧时，mysql是按照name进行排序的，所以可以看出索引项是按照索引定义里面出现的字段顺序排序的。当查找张三的时候，会定位到ID4，此时从ID4往右侧依次遍历，直到name不是张三，则得到name为张三的所有结果。</li>\n<li>若查询姓张的依旧可以使用上述的规则，找到姓张的使用<code>like 张%</code>，定位到ID3，此时从ID3往右侧依次遍历，直到name不是张打头，则得到name为姓张的所有结果。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。</li>\n<li>知道了最左前缀的用处，那如何<strong>安排联合索引的字段顺序</strong>呢？<ul>\n<li>增强索引的复用能力，一般最左侧的字段就不需要为其单独的建立索引的，而是根据需求建立其他字段的索引。所以<strong>第一原则</strong>是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。例如<code>(a,b)</code>联合，a就不需要单独创建索引，而b是需要的，因为b是利用不上这个联合索引的。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"索引下推\"><a href=\"#索引下推\" class=\"headerlink\" title=\"索引下推\"></a>索引下推</h1><ul>\n<li>继最左前缀原则后，若要查询姓张且是男生的话，就需要这样写 <code>select * from T where name like &#39;张%&#39; and ismale=1 ;</code>，这条语句的like中依旧利用了最左前缀原则，但是还有性别的判断条件，难道还要通过回表来查询是否为男性吗？mysql后加入的针对此问题的优化叫做索引下推，mysql在定位到张姓开头的时候，会自动的判断 <code>ismale</code> 字段，过滤掉不必要的回表操作。</li>\n</ul>\n<center>\n\n<p><img src=\"/img/mysql/index-get.png\" alt=\"picture 3\">  </p>\n</center>","abstracts":"参考极客时间课程《MySQL实战45讲》的学习笔记。","text":"参考极客时间课程《MySQL实战45讲》的学习笔记。","link":"","photos":[],"count_time":{"symbolsCount":"2k","symbolsTime":"2 mins."},"categories":[{"name":"MySQL","slug":"MySQL","count":1,"path":"api/categories/MySQL.json"}],"tags":[{"name":"MySQL","slug":"MySQL","count":2,"path":"api/tags/MySQL.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%B8%B8%E7%94%A8%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">常用索引模型</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#InnoDB%E7%9A%84%E7%B4%A2%E5%BC%95%E6%A8%A1%E5%9E%8B\"><span class=\"toc-text\">InnoDB的索引模型</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E5%92%8C%E6%99%AE%E9%80%9A%E7%B4%A2%E5%BC%95\"><span class=\"toc-text\">主键索引和普通索引</span></a><ol class=\"toc-child\"><li class=\"toc-item toc-level-3\"><a class=\"toc-link\" href=\"#%E6%80%9D%E8%80%83\"><span class=\"toc-text\">思考</span></a></li></ol></li><li class=\"toc-item toc-level-2\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E7%BB%B4%E6%8A%A4\"><span class=\"toc-text\">索引维护</span></a></li></ol></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E6%9C%80%E5%B7%A6%E5%89%8D%E7%BC%80%E5%8E%9F%E5%88%99\"><span class=\"toc-text\">最左前缀原则</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%B4%A2%E5%BC%95%E4%B8%8B%E6%8E%A8\"><span class=\"toc-text\">索引下推</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Dockerfile","uid":"75603112ad785d198fb30f0b34b1d632","slug":"docker/docker2","date":"2023-02-13T14:27:41.000Z","updated":"2023-02-14T09:11:19.572Z","comments":true,"path":"api/articles/docker/docker2.json","keywords":null,"cover":"/img/docker/docker-cover.png","text":"Dockerfile知识总结","link":"","photos":[],"count_time":{"symbolsCount":"2.4k","symbolsTime":"2 mins."},"categories":[{"name":"Docker","slug":"Docker","count":4,"path":"api/categories/Docker.json"}],"tags":[{"name":"Docker","slug":"Docker","count":4,"path":"api/tags/Docker.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"Spring6-AOP","uid":"30fb76edd6cb328c4c2c75f78ac58f78","slug":"spring/spring6-4","date":"2023-02-08T02:31:46.000Z","updated":"2023-02-08T07:46:36.424Z","comments":true,"path":"api/articles/spring/spring6-4.json","keywords":null,"cover":"/img/spring/OG-Spring.png","text":"AOP概念及注解使用。","link":"","photos":[],"count_time":{"symbolsCount":"4k","symbolsTime":"4 mins."},"categories":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/categories/Spring6.json"}],"tags":[{"name":"Spring6","slug":"Spring6","count":4,"path":"api/tags/Spring6.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}