{"title":"Redis复习：基本命令","uid":"8e53ea792c68f7c08b10733cf876a7d7","slug":"redis/basic-redis1","date":"2023-02-03T04:17:32.000Z","updated":"2023-02-03T12:03:17.352Z","comments":true,"path":"api/articles/redis/basic-redis1.json","keywords":null,"cover":"/img/redis/redis-cover.jpg","content":"<h1 id=\"特性\"><a href=\"#特性\" class=\"headerlink\" title=\"特性\"></a>特性</h1><ul>\n<li>键值 (key-value)型，value支持多种不同数据结构，功能丰富。</li>\n<li>单线程，每个命令具备原子性。</li>\n<li>低延迟，速度快(基于内存、10多路复用、良好的编码)。</li>\n<li>支持数据持久化。</li>\n<li>支持主从集群、分片集群。</li>\n</ul>\n<h1 id=\"登入\"><a href=\"#登入\" class=\"headerlink\" title=\"登入\"></a>登入</h1><ul>\n<li><code>redis-cli -h host -p port -a password</code>，登入成功后，输入ping，后返回pong。</li>\n</ul>\n<blockquote><span class=\"custom-blockquote-svg\"><svg width=\"24\" height=\"24\" viewBox=\"0 0 24 24\" fill=\"\" xmlns=\"http://www.w3.org/2000/svg\" data-reactroot=\"\">\n<path fill=\"\" d=\"M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\" undefined=\"1\"></path>\n<path fill=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\" undefined=\"1\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z\"></path>\n<path stroke-linejoin=\"round\" stroke-linecap=\"round\" stroke-miterlimit=\"10\" stroke-width=\"2\" stroke=\"\" d=\"M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z\"></path>\n</svg>\n</span><p><a href=\"https://www.redis.com.cn/redis-keys.html\">https://www.redis.com.cn/redis-keys.html</a><br><a href=\"https://redis.io/docs/data-types/\">https://redis.io/docs/data-types/</a></p></blockquote>\n<h1 id=\"基础命令\"><a href=\"#基础命令\" class=\"headerlink\" title=\"基础命令\"></a>基础命令</h1><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 除了以下命令，还有好多命令参考上面文档\n127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3\nOK\n-- KEYS:查看符合模板的所有key，不建议在生产环境设备上使用  : keys [正则]\n127.0.0.1:6379&gt; keys *\n1) &quot;k1&quot;\n2) &quot;k3&quot;\n3) &quot;k2&quot;\n127.0.0.1:6379&gt; keys *1\n1) &quot;k1&quot;\n127.0.0.1:6379&gt; keys k*\n1) &quot;k1&quot;\n2) &quot;k3&quot;\n3) &quot;k2&quot;\n-- DEL:删除一个指定的key : del [key...]\n127.0.0.1:6379&gt; del k1\n(integer) 1\n127.0.0.1:6379&gt; keys *\n1) &quot;k3&quot;\n2) &quot;k2&quot;\n-- EXISTS:判断key是否存在，0不存在，1存在\n127.0.0.1:6379&gt; EXISTS k1\n(integer) 0\n127.0.0.1:6379&gt; EXISTS k2\n(integer) 1\n-- TTL:查看一个KEY的剩余有效期，被删除-2，若永久返回-1\n127.0.0.1:6379&gt; TTL k1\n(integer) -2\n127.0.0.1:6379&gt; TTL k2\n(integer) -1\n-- EXPIRE:给一个key设置有效期，有效期到期时该key会被自动删除，设置k2在20秒后过期\n127.0.0.1:6379&gt; EXPIRE k2 20\n(integer) 1\n127.0.0.1:6379&gt; TTL k2 \n-- 剩余13秒 \n(integer) 13\n127.0.0.1:6379&gt; TTL k2\n-- 剩余5秒 \n(integer) 5\n-- 过期被删除\n127.0.0.1:6379&gt; TTL k2\n(integer) -2</code></pre>\n\n<h1 id=\"String\"><a href=\"#String\" class=\"headerlink\" title=\"String\"></a>String</h1><ul>\n<li>Redis字符串存储字节序列，包括文本、序列化对象和二进制数组。它们通常用于缓存，但它们支持额外的功能，允许实现计数器并执行按位操作。</li>\n<li>最大不超过512MB。</li>\n<li>大部分操作都是O(1)操作，但是一些随机命令可能会达到O(n)级别。比如 <code>SUBSTR</code>, <code>GETRANGE</code>,  <code>SETRANGE</code></li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- SET\t设置指定 key 的值\n-- GET\t获取指定 key 的值\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;\n-- GETRANGE\t返回 key 中字符串值的子字符\n127.0.0.1:6379&gt; GETRANGE name 0 2\n&quot;qid&quot;\n-- SETRANGE\t从偏移量 offset 开始用 value 覆写给定 key 所储存的字符串值\n127.0.0.1:6379&gt; SETRANGE name 1 ohbug\n(integer) 6\n127.0.0.1:6379&gt; get name\n&quot;qohbug&quot;\n-- SETEX\t设置 key 的值为 value 同时将过期时间设为 seconds\n127.0.0.1:6379&gt; SETEX name 20 ooo\nOK\n127.0.0.1:6379&gt; get name\n&quot;ooo&quot;\n127.0.0.1:6379&gt; ttl name\n(integer) 12\n127.0.0.1:6379&gt; ttl name\n(integer) 11\n-- SETNX\t只有在 key 不存在时设置 key 的值\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; SETNX name ohbug\n(integer) 0\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;\n-- STRLEN\t返回 key 所储存的字符串值的长度\n127.0.0.1:6379&gt; STRLEN name\n(integer) 5\n-- INCR\t将 key 中储存的数字值增一\n-- INCRBY\t将 key 所储存的值加上给定的增量值 ( increment )\n127.0.0.1:6379&gt; set age 1\nOK\n127.0.0.1:6379&gt; get age\n&quot;1&quot;\n127.0.0.1:6379&gt; INCR age\n(integer) 2\n127.0.0.1:6379&gt; get age\n&quot;2&quot;\n127.0.0.1:6379&gt; INCRBY age 5   -- 每次加五\n(integer) 7\n127.0.0.1:6379&gt; get age\n&quot;7&quot;</code></pre>\n\n<h1 id=\"key-结构\"><a href=\"#key-结构\" class=\"headerlink\" title=\"key 结构\"></a>key 结构</h1><pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- 设置一个key名为name，值为qidai\nset name qidai\n-- 为了区分name，那么可以使用前缀方式，分隔符为分号 :  ，\n-- 类似于分表操作\n127.0.0.1:6379&gt; set ohbug:src:name qidai\nOK\n127.0.0.1:6379&gt; set ohbug:cls:name red22\nOK\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; keys *\n1) &quot;ohbug:src:name&quot;\n3) &quot;ohbug:cls:name&quot;\n4) &quot;name&quot;\n127.0.0.1:6379&gt; get ohbug:src:name\n&quot;qidai&quot;\n127.0.0.1:6379&gt; get ohbug:cls:name\n&quot;red22&quot;\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;</code></pre>\n\n<ul>\n<li>命令行看不出啥，来看看图形界面。明显看出单独的name和其他有限定的name的不同。</li>\n</ul>\n<p><img src=\"/img/redis/redis-keystruct.png\" alt=\"picture 1\">  </p>\n<h1 id=\"Lists\"><a href=\"#Lists\" class=\"headerlink\" title=\"Lists\"></a>Lists</h1><ul>\n<li>基于链表实现，可以用来实现堆栈和队列，以及为后台工作系统构建队列管理。</li>\n<li>最长长度限制 ： 2^{32} -1</li>\n<li>由于是基于链表实现，所以对头尾操作是O(1)，而对于某些插入命令，设值LSET复杂度是O(n)的。</li>\n</ul>\n<p><img src=\"/img/redis/redis-lists.png\" alt=\"picture 2\">  </p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- BLPOP\t移出并获取列表的第一个元素，如果列表内为空，则阻塞\n-- BLMOVE 将一个元素移入另一个list中，如果原list中为空，则阻塞\n\n-- BRPOP\t移出并获取列表的最后一个元素\n-- LINDEX\t通过索引获取列表中的元素\n-- LINSERT\t在列表的元素前或者后插入元素\n-- LLEN\t获取列表长度\n-- LPOP\t移出并获取列表的第一个元素\n-- LPUSH\t将一个或多个值插入到列表头部\n-- RPUSH\t在列表中添加一个或多个值\n-- RPUSHX\t为已存在的列表添加值\n-- LREM\t移除列表元素\n-- LSET\t通过索引设置列表元素的值\n-- LTRIM\t对一个列表进行修剪(trim)\n-- RPOP\t移除并获取列表最后一个元素\n-- LPUSHX\t将一个值插入到已存在的列表头部\n-- BRPOPLPUSH\t从列表中弹出一个值，并将该值插入到另外一个列表中并返回它\n-- RPOPLPUSH\t移除列表的最后一个元素，并将该元素添加到另一个列表并返回</code></pre>\n\n<h1 id=\"Sets\"><a href=\"#Sets\" class=\"headerlink\" title=\"Sets\"></a>Sets</h1><ul>\n<li>无序且元素唯一，可用于跟踪记录唯一的元素，比如IP地址，执行常见的集合操作，如交集、并集和差集。</li>\n<li>可用于查找共同好友之类的操作。</li>\n<li>最多2^32-1 个元素。</li>\n<li>大部分命令都是<code>O(1)</code>级别，但是对于元素多的时候，要当心  <code>SMEMBERS</code> 操作，这个操作的级别是<code>O(n)</code>级别，它会返回所有set元素。作为替换操作，可以考虑 <code>SSCAN</code>  ，<code>SSCAN</code> 允许迭代地检索集合的所有成员。</li>\n</ul>\n<p><img src=\"/img/redis/redis-sets.png\" alt=\"picture 3\">  </p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- SADD\t向集合添加一个或多个成员\n-- SCARD\t获取集合的成员数\n-- SDIFF\t返回给定所有集合的差集\n-- SDIFFSTORE\t返回给定所有集合的差集并存储在 destination 中\n-- SINTER\t返回给定所有集合的交集\n-- SINTERSTORE\t返回给定所有集合的交集并存储在 destination 中\n-- SISMEMBER\t判断 member 元素是否是集合 key 的成员\n-- SMEMBERS\t返回集合中的所有成员\n-- SMOVE\t将 member 元素从 source 集合移动到 destination 集合\n-- SPOP\t移除并返回集合中的一个随机元素\n-- SRANDMEMBER\t返回集合中一个或多个随机数\n-- SREM\t移除集合中一个或多个成员\n-- SUNION\t返回所有给定集合的并集\n-- SUNIONSTORE\t所有给定集合的并集存储在 destination 集合中\n-- SSCAN\t迭代集合中的元素</code></pre>\n\n<h1 id=\"Sorted-Sets\"><a href=\"#Sorted-Sets\" class=\"headerlink\" title=\"Sorted Sets\"></a>Sorted Sets</h1><ul>\n<li>string 类型元素的集合，且不允许重复的成员，每个元素都会关联一个名为score的 double 类型的分数，根据score进行排序。</li>\n<li>通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。但大部分是logn级别的复杂度</li>\n<li>可用于排名应用，可取出前几名，后几名，中间几名。</li>\n<li>默认range返回的是根据score返回的升序。</li>\n</ul>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">127.0.0.1:6379&gt; zadd math 100 qidai\n(integer) 1\n127.0.0.1:6379&gt; zadd math 12 liming\n(integer) 1\n127.0.0.1:6379&gt; zadd math 23 xiaohong\n(integer) 1\n127.0.0.1:6379&gt; ZADD math 66 zhangsan\n(integer) 1\n127.0.0.1:6379&gt; ZRANGE math 0 1\n1) &quot;liming&quot;\n2) &quot;xiaohong&quot;\n127.0.0.1:6379&gt; ZRANGE math 0 1 withscores\n1) &quot;liming&quot;\n2) &quot;12&quot;\n3) &quot;xiaohong&quot;\n4) &quot;23&quot;\n-- ZADD\t向有序集合添加一个或多个成员，或者更新已存在成员的分数\n-- ZCARD\t获取有序集合的成员数\n-- ZCOUNT\t计算在有序集合中指定区间分数的成员数\n-- ZINCRBY\t有序集合中对指定成员的分数加上增量 increment\n-- ZINTERSTORE\t计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n-- ZLEXCOUNT\t在有序集合中计算指定字典区间内成员数量\n-- ZRANGE\t通过索引区间返回有序集合成指定区间内的成员\n-- ZRANGEBYLEX\t通过字典区间返回有序集合的成员\n-- ZRANGEBYSCORE\t通过分数返回有序集合指定区间内的成员\n-- ZRANK\t返回有序集合中指定成员的索引\n-- ZREM\t移除有序集合中的一个或多个成员\n-- ZREMRANGEBYLEX\t移除有序集合中给定的字典区间的所有成员\n-- ZREMRANGEBYRANK\t移除有序集合中给定的排名区间的所有成员\n-- ZREMRANGEBYSCORE\t移除有序集合中给定的分数区间的所有成员\n-- ZREVRANGE\t返回有序集中指定区间内的成员，通过索引，分数从高到底\n-- ZREVRANGEBYSCORE\t返回有序集中指定分数区间内的成员，分数从高到低排序\n-- ZREVRANK\t返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n-- ZSCORE\t返回有序集中，成员的分数值\n-- ZUNIONSTORE\t计算一个或多个有序集的并集，并存储在新的 key 中\n-- ZSCAN\t迭代有序集合中的元素（包括元素成员和元素分值）</code></pre>\n\n<h1 id=\"Hashes\"><a href=\"#Hashes\" class=\"headerlink\" title=\"Hashes\"></a>Hashes</h1><ul>\n<li>结构为key - (file-value)，即一个key标识一个file-value对。适用存储对象。</li>\n<li>大部分操作时间复杂度是O(1)，其中 <code>HKEYS</code>, <code>HVALS</code>, <code>HGETALL</code> 是O(n) 级别。</li>\n<li>例如：<code> hset user name qidai sex man age 12</code>，则结构如下图</li>\n</ul>\n<p><img src=\"/img/redis/redis-hash.png\" alt=\"picture 4\">  </p>\n<pre class=\"line-numbers language-sql\" data-language=\"sql\"><code class=\"language-sql\">-- HDEL\t删除一个或多个哈希表字段\n-- HEXISTS\t查看哈希表 key 中，指定的字段是否存在\n-- HGET\t获取存储在哈希表中指定字段的值\n-- HGETALL\t获取在哈希表中指定 key 的所有字段和值\n-- HINCRBY\t为哈希表 key 中的指定字段的整数值加上增量 increment\n-- HINCRBYFLOAT\t为哈希表 key 中的指定字段的浮点数值加上增量 increment\n-- HKEYS\t获取所有哈希表中的字段\n-- HLEN\t获取哈希表中字段的数量\n-- HMGET\t获取所有给定字段的值\n-- HMSET\t同时将多个 field-value (域-值)对设置到哈希表 key 中\n-- HSET\t将哈希表 key 中的字段 field 的值设为 value\n-- HSETNX\t只有在字段 field 不存在时，设置哈希表字段的值\n-- HVALS\t获取哈希表中所有值\n-- HSCAN\t迭代哈希表中的键值对\n-- HSTRLEN\t返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度</code></pre>\n","abstracts":"基础命令复习。","text":"基础命令复习。","link":"","photos":[],"count_time":{"symbolsCount":"6.1k","symbolsTime":"6 mins."},"categories":[{"name":"redis","slug":"redis","count":1,"path":"api/categories/redis.json"}],"tags":[{"name":"redis","slug":"redis","count":1,"path":"api/tags/redis.json"}],"toc":"<ol class=\"toc\"><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%89%B9%E6%80%A7\"><span class=\"toc-text\">特性</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E7%99%BB%E5%85%A5\"><span class=\"toc-text\">登入</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#%E5%9F%BA%E7%A1%80%E5%91%BD%E4%BB%A4\"><span class=\"toc-text\">基础命令</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#String\"><span class=\"toc-text\">String</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#key-%E7%BB%93%E6%9E%84\"><span class=\"toc-text\">key 结构</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Lists\"><span class=\"toc-text\">Lists</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Sets\"><span class=\"toc-text\">Sets</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Sorted-Sets\"><span class=\"toc-text\">Sorted Sets</span></a></li><li class=\"toc-item toc-level-1\"><a class=\"toc-link\" href=\"#Hashes\"><span class=\"toc-text\">Hashes</span></a></li></ol>","author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}},"mapped":true,"prev_post":{"title":"Java复习篇：I/O","uid":"29f930df39026468dc3eb2d13ae05591","slug":"java/basic/basicjava7","date":"2023-02-04T01:20:15.000Z","updated":"2023-02-05T08:53:03.460Z","comments":true,"path":"api/articles/java/basic/basicjava7.json","keywords":null,"cover":"/img/java/basicjava.jpg","text":"内容来自于自己的拓展总结，对知识点进行总结，不过多涉及基础语法，例如定义循环等。文中部分的引用的来源见文章开头。","link":"","photos":[],"count_time":{"symbolsCount":"5.1k","symbolsTime":"5 mins."},"categories":[{"name":"java基础","slug":"java基础","count":7,"path":"api/categories/java基础.json"}],"tags":[{"name":"java","slug":"java","count":7,"path":"api/tags/java.json"},{"name":"todo","slug":"todo","count":4,"path":"api/tags/todo.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}},"next_post":{"title":"红黑树 VS AVL","uid":"fab60566d104e206f93915adac60dea5","slug":"datastructure/redblacktree-avl","date":"2023-02-02T02:07:00.000Z","updated":"2023-02-02T10:09:48.370Z","comments":true,"path":"api/articles/datastructure/redblacktree-avl.json","keywords":null,"cover":"/img/datastructure/redblacktree.png","text":"红黑树以及AVL的介绍及对比。","link":"","photos":[],"count_time":{"symbolsCount":"2.1k","symbolsTime":"2 mins."},"categories":[{"name":"数据结构","slug":"数据结构","count":1,"path":"api/categories/数据结构.json"}],"tags":[{"name":"红黑树","slug":"红黑树","count":1,"path":"api/tags/红黑树.json"},{"name":"AVL","slug":"AVL","count":1,"path":"api/tags/AVL.json"}],"author":{"name":"Qidai","slug":"blog-author","avatar":"/img/v2-b98d05a15e22949b1a1c70d453fb71ed_720w.jpg","link":"/","description":"吃喝，死宅，折腾","socials":{"github":"https://github.com/ziqiang-wang-chn","twitter":"","stackoverflow":"","wechat":"","qq":"","weibo":"","zhihu":"","csdn":"","juejin":"","customs":{"bilibili":{"icon":"/svg/bilibili.svg","link":"https://space.bilibili.com/291152218"},"mail":{"icon":"/svg/mail.svg","link":"mailto:ziqiang_wang_chn@163.com"},"rss":{"icon":"/svg/RSS.svg","link":"https://ohbug.cn/atom.xml"}}}}}}