[{"id":"7de900b2cf533ef3e8fa2a5e99f915a4","title":"Spring6 - Bean","content":"\n\n\n\n\n\n内容来源\n基于Oracle openJDK 17 ， Spring6\n\nBean的获取方式@Data\npublic class User &#123;\n    public User() &#123;\n        System.out.println(&quot;wucan&quot;);\n    &#125;\n    private String name;\n&#125;\n\n构造方法实例化&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;Qidai&quot;&#x2F;&gt;\n\n简单工厂模式实例化@Data\npublic class UserFactory &#123;\n    public static User get() &#123;\n        return new User();\n    &#125;\n&#125;\n\n\n由于 UserFactory 是中get是静态方法，所以可以直接在创建对象后直接通过factory-method调用方法，以返回User对象。\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.UserFactory&quot; factory-method&#x3D;&quot;get&quot;&#x2F;&gt;\n\nfactory-bean实例化@Data\npublic class UserFactory &#123;\n    public User get() &#123;\n        return new User();\n    &#125;\n&#125;\n\n\n与上面的简单工厂不同的是，这里是实例方法，实例方法的调用是依赖于对象的，所以要先将UserFactory的对象交予Spring管理，在配置调用此对象的方法。\n\n&lt;bean id&#x3D;&quot;userFactory&quot; class&#x3D;&quot;cn.ohbug.UserFactory&quot; &#x2F;&gt;\n&lt;bean id&#x3D;&quot;user&quot; factory-bean&#x3D;&quot;userFactory&quot; factory-method&#x3D;&quot;get&quot;&#x2F;&gt;\n\nFactoryBean接口实例化@Data\npublic class UserFactory implements FactoryBean&lt;User&gt; &#123;\n    @Override\n    public User getObject() throws Exception &#123;\n        return new User();\n    &#125;\n    @Override\n    public Class&lt;?&gt; getObjectType() &#123;\n        return User.class;\n    &#125;\n&#125;\n\n\n由于实现了接口并抽象方法，所以一定存在getObject方法，所以Spring会自动的调用getObject方法来获取返回对象。\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.UserFactory&quot; &#x2F;&gt;\n\nBean生命周期  \n\n如上是Bean的整个生命周期的流程图，对于Aware相关结论这里列举了一些。下面为实现代码。\n\n\n\n@ToString\npublic class User &#123;\n    private String name;\n    public User() &#123;\n        System.out.println(&quot;Bean实例化 无参&quot;);\n    &#125;\n\n    public void setName(String name) &#123;\n        System.out.println(&quot;Bean属性赋值&quot;);\n        this.name &#x3D; name;\n    &#125;\n    public void init() &#123;\n        System.out.println(&quot;初始化Bean&quot;);\n    &#125;\n\n    public void destroy() &#123;\n        System.out.println(&quot;销毁Bean&quot;);\n    &#125;\n&#125;\npublic class MyBeanPostProcess implements BeanPostProcessor, BeanNameAware, BeanClassLoaderAware, BeanFactoryAware, InitializingBean, DisposableBean &#123;\n    @Override\n    public void setBeanClassLoader(ClassLoader classLoader) &#123;\n        System.out.println(&quot;Bean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanClassLoaderAware.setBeanClassLoader&quot;);\n    &#125;\n    @Override\n    public void setBeanFactory(BeanFactory beanFactory) throws BeansException &#123;\n        System.out.println(&quot;Bean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanFactoryAware.setBeanFactory&quot;);\n    &#125;\n    @Override\n    public void setBeanName(String name) &#123;\n        System.out.println(&quot;Bean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanNameAware.setBeanName&quot;);\n    &#125;\n    @Override\n    public void afterPropertiesSet() throws Exception &#123;\n        System.out.println(&quot;Bean的初始化方法之后 ：Bean是否实现了InitializingBean接口 ：InitializingBean.afterPropertiesSet&quot;);\n    &#125;\n    @Override\n    public void destroy() throws Exception &#123;\n        System.out.println(&quot;是否实现DisposableBean接口 ： destroy&quot;);\n    &#125;\n    @Override\n    public Object postProcessBeforeInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;-- 初始化Bean之前&quot;);\n        return BeanPostProcessor.super.postProcessBeforeInitialization(bean, beanName);\n    &#125;\n    @Override\n    public Object postProcessAfterInitialization(Object bean, String beanName) throws BeansException &#123;\n        System.out.println(&quot;-- 初始化Bean之后&quot;);\n        return BeanPostProcessor.super.postProcessAfterInitialization(bean, beanName);\n    &#125;\n&#125;\n    @Test\n    public void test() &#123;\n        ClassPathXmlApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;beans.xml&quot;);\n        User user &#x3D; context.getBean(&quot;user&quot;, User.class);\n        System.out.println(&quot;使用Bean &#x3D; &quot; + user);\n        context.close();\n    &#125;\n\n\n\n\n\n\ndestroy-method 指定Bean的销毁方法， init-method 指定Bean的初始化方法。\n\n&lt;bean class&#x3D;&quot;cn.ohbug.MyBeanPostProcess&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;Qidai&quot; destroy-method&#x3D;&quot;destroy&quot; init-method&#x3D;&quot;init&quot;&#x2F;&gt;\n\n\nconsole out\nBean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanNameAware.setBeanName\nBean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanClassLoaderAware.setBeanClassLoader\nBean的初始化方法之前 ：Bean是否实现了Aware相关接口 ： BeanFactoryAware.setBeanFactory\nBean的初始化方法之后 ：Bean是否实现了InitializingBean接口 ：InitializingBean.afterPropertiesSet\nBean实例化 无参\nBean属性赋值\n-- 初始化Bean之前\n初始化Bean\n-- 初始化Bean之后\n使用Bean &#x3D; User(name&#x3D;Qidai)\n销毁Bean\n是否实现DisposableBean接口 ： destroy\n\n\n","slug":"spring/spring6-2","date":"2023-02-06T05:29:19.000Z","categories_index":"Spring6","tags_index":"Spring6","author_index":"Qidai"},{"id":"29f930df39026468dc3eb2d13ae05591","title":"Java复习篇：I/O","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n\n\n\n\n\n\n\n\n\nhttps://juejin.cn/post/6844903993844432909\n\n\n\n\n\n\n\n\n\n基本常识是: 一般读写文件需要两次数据复制，比如读文件，需要先从硬盘复制到操作系统内核，再从内核复制到应用程序分配的内存中。操作系统运行所在的环境和应用程序是不一样的，操作系统所在的环境是内核态，应用程序是用户态，应用程序调用操作系统的功能，需要两次环境的切换，先从用户态切到内核态，再从内核态切到用户态。这种用户态&#x2F;内核态的切换是有开销的，应尽量减少这种切换。为提升效率可以使用缓冲区。\n\n\n  \n\n\n\n流分类\n基本分与三类，首先适用于读写二进制形式的流为 inputStream&#x2F;outputStream 类，适用于读写文字内容的 reader&#x2F;writer 类。还有网络IO的 Socket 类。\n\n二进制文件和字节流InputStream\n这是二进制文件字节流的基类，是抽象类\n\n&#x2F;&#x2F; 读方法，返回0到255，如果因为读到末尾后导致的无信息可读返回 -1 . 否则就一直阻塞到有信息可读为止\npublic abstract int read() throws IOException;\n&#x2F;&#x2F; 返回流中不阻塞的字节的估计大小\npublic int available() throws IOException &#123;...&#125;\n&#x2F;&#x2F; 跳读，\npublic long skip(long n) throws IOException &#123;...&#125;\n&#x2F;&#x2F; 回头读，但不是每个实现类都可以实现回头重读，需要先通过markSupported方法测试后才可以知道\n&#x2F;&#x2F; mark 先标记一处，往下读后调用reset即可回到mark位置。readlimit表示从mark处最多往后读多少字节，\n&#x2F;&#x2F; 若往后超了，则mark位置失效。\npublic synchronized void mark(int readlimit) &#123;&#125;\npublic synchronized void reset() throws IOException &#123;...&#125;\npublic boolean markSupported() &#123;...&#125;\npublic void close() throws IOException &#123;&#125;\n&#x2F;&#x2F; java 9中加入的默认实现，里面用到了一个Buffer数组，默认DEFAULT_BUFFER_SIZE是8192字节。\npublic long transferTo(OutputStream out) throws IOException &#123;...&#125;\n...\nOutputStream\nclose 之前一般先调用flush，但每个子类的flush有些不同，需要分别对待。\n\npublic abstract void write(int b) throws IOException;\npublic void flush() throws IOException &#123; &#x2F;* NULL *&#x2F; &#125;\npublic void close() throws IOException &#123; &#x2F;* NULL *&#x2F; &#125;\n...\n\n\nFileIn&#x2F;FileOut\n输入源和输出目标是文件的流。\n\nFileOutputStream 没有缓冲，没有重写fush方法，调用fush方法没有任何效果，即调用的 OutputStream 的空方法 ，数据只是传递给了操作系统，但操作系统什么时候保存到硬盘上，这是不一定的。要确保数据保存到了硬盘上，可以调用FileOutputStream中的特有方法 sync 。\n\n\n\n&#x2F;&#x2F; 同步仅影响此文件描述符下游的缓冲区。\n&#x2F;&#x2F; 若想sync有效，则必须首先调用flush刷新，将缓存刷新到系统后，再sync，系统才会同步到磁盘。然后数据才会受到同步的影响。\nnew FileOutputStream(&quot;out.txt&quot;).getFD().sync();\n\n\nfush方法只能将应用程序缓冲的数据写到操作系统，sync方法则确保数据写到硬盘，不过一般情况下，我们并不需要手工调用它，只要操作系统和硬件设备没问题，数据迟早会写入。\n\n基本使用FileInputStream inputStream &#x3D; new FileInputStream(&quot;sourceFile&quot;);\nFileOutputStream targetFile &#x3D; new FileOutputStream(&quot;targetFile&quot;);\nint length;\nbyte[] buffer &#x3D; new byte[4];\nwhile ((length&#x3D; inputStream.read(buffer))!&#x3D;-1)&#123;\n    targetFile.write(buffer, 0 , length);\n&#125;\ninputStream.close();\ntargetFile.close();\n\n\n其他基本类似，略\nByteArrayInputStream&#x2F;ByteArrayOutputStream: 输入源和输出目标是字节数组的流\nDataInputStream&#x2F;DataOutputStream: 装饰类，按基本类型和字符串而非只是字节读写流。\nBufferedInputStream&#x2F;BufferedOutputStream: 装饰类，对输入输出流提供缓冲功能。\n\n文本字符流编码\nutf-8：英文和数字字符每个占一个字节，而每个中文占三个字节。\ngb18030：英文和数字字符每个占一个字节，而每个中文占2个字节。\nutf-16be：无论是英文还是中文字符，每个字符都占两人字节。UTF-16BE也是Java内存中对字符的编码方式。\n\n基本类\nReader&#x2F;Writer: 字符流的基类，它们是抽象类。\nFileReader&#x2F;FileWriter: 输入源和输出目标是文件的字符流。\nCharArrayReader&#x2F;CharArrayWriter: 输入源和输出目标是char数组的字符流。\nStringReader&#x2F;StringWriter: 输入源和输出目标是String的字符流。\nBufferedReader&#x2F;BufferedWriter: 装饰类，对输入&#x2F;输出流提供缓冲，以及按行读写功能。\nPrintWriter: 装饰类，可将基本类型和对象转换为其字符串形式输出的类。\nInputStreamReader&#x2F;OutputStreamWriter: 适配器类，将字节流转换为字符流。\n\ntry(\n        FileReader in &#x3D; new FileReader(&quot;sourceFile&quot;, Charset.forName(&quot;utf-8&quot;));\n        BufferedReader reader &#x3D; new BufferedReader(in);\n        PrintStream writer &#x3D; new PrintStream(&quot;target&quot;, Charset.forName(&quot;utf-8&quot;));\n    )\n&#123;\n    while (reader.ready()) &#123;\n        writer.println(reader.readLine());\n    &#125;\n&#125;catch (IOException e) &#123;\n    e.printStackTrace();\n&#125;\n\n\nFileReader&#x2F;FileWriter是没有缓冲的，也不能按行读写，所以，一般应该在它们的外面包上对应的缓冲类。\n\n总结：写文件时，可以优先考虑PrintWriter，因为它使用方便，支持自动缓冲、指定编码类型、类型转换等。读文件时。\n\n如果指定编码类型，需要使用InputStreamReader; 如果不需要，可使用FileReader，但都应该考虑在外面包上缓冲类BufferedReader。\n\n\n字符与字节的区别\n字节流是按字节读取的，而字符流则是按char读取的，一个char在文件中保存的是几个字节与编码有关，但字符流封装了这种细节，我们操作的对象就是char。\n一个char不完全等同于一个字符，对于绝大部分字符，一个字符就是一个char，根据utf-16be编码不同，对于增补字符集中的字符，需要两个char表示，对于这种字符，Java中的字符流是按char而不是一个完整字符处理的。\n\n\n\n\n\n\n\n\n\n\n《Java编程的逻辑》https://cloud.tencent.com/developer/article/1902272\n内存映射文件基本概念\n所谓内存映射文件，就是将文件映射到内存，文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这种映射可以是映射文件全部区域，也可以是只映射一部分区域。不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。操作系统一般是按页加载的，页可以理解为就是一块，页的大小与操作系统和硬件相关，典型的配置可能是4K、8K等，当操作系统发现读写区域不在内存时，就会加载该区域对应的一个页到内存。这种按需加载的方式，使得内存映射文件可以方便高效地处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的大存释放。但是同步时机是不确定的。\n\n之前提到，在一般的文件读写中，会有两次数据复制，一次是从硬盘复制到操作系统内核，另一次是从操作系统内核复制到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次复制，且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间，这显然要比普通的读写效率更高。\n\n正是内存映射的一次复制，避免掉了用户态与内核态的切换，所以对于超小文件的大批量读写是友好的。\n\n内存映射文件的另一个重要特点是: 它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同应用程序之间的通信。\n\n在操作系统中的应用，比如:\n\n按需加载代码，只有当前运行的代码在内存，其他暂时用不到的代码还在硬盘。\n同时启动多次同一个可执行文件，文件代码在内存也只有一份。\n不同应用程序共享的动态链接库代码在内存也只有一份。\n\n\n内存映射文件也有局限性。比如，它不太适合处理小文件，它是按页分配内存的，对于小文件，会浪费空间。另外，映射文件要消耗一定的操作系统资源，初始化比较慢。\n\n总结：对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，那就可以考虑内存映射文件。\n\n\n使用\n首先要获得这条由应用程序直通内核的管道，可以通过FileInputStream/FileOutputStreamo与RandomAccessFile 获得。也可以通过 FileChannel.open(..) 得到。\n\ntodo : nio aio \n","slug":"java/basic/basicjava7","date":"2023-02-04T01:20:15.000Z","categories_index":"java基础","tags_index":"java,todo","author_index":"Qidai"},{"id":"4a3de2f382252848e66f9fb50dc1dbc0","title":"Java复习篇：抽象类，String，枚举","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n抽象类\n定义\n\npublic abstract class Person &#123;\n    public abstract void call();\n&#125;\n\n\n子类继承抽象类，则必须实现抽象类的抽象方法，或者使得子类也定义为抽象类。接口中同样有这样的规定。\n需要注意的是，虽然说的类，但依旧不可以使用抽象类实例化对象，必须使用其子类来创建对象，或者使用如下方法。接口中有同样的规定。\n\n\nPerson p &#x3D; new Person() &#123;\n    @Override\n    public void call() &#123;\n        System.out.println(&quot;person call method&quot;);\n    &#125;\n&#125;;\np.call(); \n&#x2F;&#x2F; out -&gt;   person call method\n抽象类和接口\n在Java8更新后，接口中同样可以实现方法体了，这样使得抽象类与接口基本没啥不一样的了，但是还有几点不同\n接口中只能定义常量， 而抽象类中可以定义实例变量。\n一个普通类只可以继承一个抽象类，而可以实现多个接口。\n抽象类的使用更多的是一种语法限制一种默认实现，使得编程的时候减少错误的发生。而接口更多的是一种能力的实现。\n\n\n\n枚举\n枚举常量在静态成员之前构造，所以不能在枚举构造器中引用之外的静态变量。\n枚举的构造器都是私有的。\n\n异常\nfinally 代码块\n最终都会执行，当try正常执行后finally执行。若try中有异常被捕获后，进入catch执行后finally执行。若try中有异常没有被捕获，则finally在异常抛出前被捕获。\ncatch非必须。\nfinally中的return会覆盖掉之前的所有返回值，并且会覆盖掉所有异常。\n若在finally中抛出异常，则也会覆盖掉之前抛出的异常。\nreturn若出现在try或者catch中，则finally执行完毕后才执行return。如下在执行return时会将ret暂时保存起来，而finally修改的值并不会被修改。\n\npublic static void main(String[] args) &#123;\n    System.out.println(Main.getRet());\n&#125;\npublic static int getRet() &#123;\n    int ret &#x3D; 0;\n    try&#123;\n        System.out.println(&quot;try ...&quot;);\n        return ret;\n    &#125;finally &#123;\n        System.out.println(&quot;finally...&quot;);\n        ret &#x3D; 2;\n    &#125;\n&#125;\n&#x2F;&#x2F; out \ntry ...\nfinally...\n0\n\npublic static int getRet() &#123;\n    int ret &#x3D; 0;\n    try&#123;\n        ret &#x3D; 1&#x2F;0;\n    &#125;finally &#123;\n        System.out.println(&quot;finally...&quot;);\n        return ret &#x3D; 2;\n    &#125;\n&#125;\n&#x2F;&#x2F;out \nfinally...\n2\n\ntry自动释放资源\n位于try()括号中的资源将在try执行完毕后自动关闭。\n\ntry(FileInputStream in &#x3D; new FileInputStream(&quot;filename&quot;))&#123;\n\n&#125; catch (Exception e) &#123;\n    throw new RuntimeException(e);\n&#125; \n\n\n\n\n\n\n\n\n\n\n包装类Integer之类的应使用valueOf()，因为除了Float和Double，其他包装类都会缓存一些包装类对象，使用valueOf()更高效。\nString构造\n在构造器String(String)的注释上找到一句话 the newly created string is a copy of the argument string.，即使用构造方法创建的对象是一个副本，也就是说如下代码。s1是不等于s2的。\n\nString s1 &#x3D; &quot;A&quot;;\nString s2 &#x3D; new String(&quot;A&quot;);\n\n\n下面则看一个比较被常调用的构造过程，总体的思路是循环判断每个字符是否可单字节编码，只要有一个不可以单字节编码，则整体切换为双字节编码。如下是详细调用过程\n\n    public static void main(String[] args) &#123;\n        char[] chars &#x3D; &#123;&#39;Q&#39;,&#39;i&#39;,&#39;D&#39;,&#39;a&#39;,&#39;i&#39;&#125;;\n        String s &#x3D; new String(chars, 2, 2);\n        System.out.println(s);\n    &#125;\n    &#x2F;&#x2F; 下标从0开始算，offset&#x3D;2且count&#x3D;2，即从char数组中的第三个字母和第四个字母组成字符串返回\n    public String(char value[], int offset, int count) &#123;\n        this(value, offset, count, rangeCheck(value, offset, count));\n    &#125;\n    &#x2F;&#x2F; 这里的Void sig表示接受一次方法，此方法是无返回值的 ,此处的rangeCheck是来检查参数不出界的。\n    String(char[] value, int off, int len, Void sig) &#123;\n        if (len &#x3D;&#x3D; 0) &#123;\n            this.value &#x3D; &quot;&quot;.value;\n            this.coder &#x3D; &quot;&quot;.coder;\n            return;\n        &#125;\n        &#x2F;&#x2F; COMPACT_STRINGS默认为true\n        if (COMPACT_STRINGS) &#123;\n            &#x2F;&#x2F; 若此时返回为空，代表char数组中必有需要双字节编码的字符\n            &#x2F;&#x2F; 不为空的话，则代表char数组中字符都可以单字节编码，且已经都从char数组转换为了byte数组\n            byte[] val &#x3D; StringUTF16.compress(value, off, len);\n            if (val !&#x3D; null) &#123;\n              &#x2F;&#x2F; 转换好的数组直接赋值即可是String的底层实现。\n                this.value &#x3D; val;\n                this.coder &#x3D; LATIN1;\n                return;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 到这就是需要处理char中的双字符编码了\n        this.coder &#x3D; UTF16;\n        &#x2F;&#x2F;\n        this.value &#x3D; StringUTF16.toBytes(value, off, len);\n    &#125;\n    public static byte[] compress(char[] val, int off, int len) &#123;\n        byte[] ret &#x3D; new byte[len];\n        &#x2F;&#x2F; 若compress返回的与len参数相同，证明char中都是可单字节编码的且已经转换为byte数组，可直接用于String的底层实现了\n        &#x2F;&#x2F; 否则不同表示必须是有双字节编码了，直接返回null，再由上层函数进行下一步处理。\n        if (compress(val, off, ret, 0, len) &#x3D;&#x3D; len) &#123;\n            return ret;\n        &#125;\n        return null;\n    &#125;\n    &#x2F;&#x2F; compressedCopy char[] -&gt; byte[]\n    &#x2F;&#x2F; 整体方法思路就是循环判断每个字符是否是可以单字节编码的，如果可以，则该位置的字符直接从char转为byte，否则的话就结束本方法返回0\n    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) &#123;\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            char c &#x3D; src[srcOff];\n            &#x2F;&#x2F; 单字符可编码，即是2的八次方即0到255内的字符内的字符\n            &#x2F;&#x2F; c&gt;0xff就是循环判断每个char是否是单字节可编码的\n            if (c &gt; 0xFF) &#123;\n              &#x2F;&#x2F; 进来后表示char数组中此位置的字符必须双字节编码的字符，则len&#x3D;0，中止循环，return 0\n                len &#x3D; 0;\n                break;\n            &#125;\n            &#x2F;&#x2F; 到这表示此位置的字符是单字节可编码的，则将char转byte\n            dst[dstOff] &#x3D; (byte)c;\n            srcOff++;\n            dstOff++;\n        &#125;\n        return len;\n    &#125;\n    &#x2F;&#x2F; 双字节的字符转byte的处理方法\n&#96;&#96;    public static byte[] toBytes(char[] value, int off, int len) &#123;\n        byte[] val &#x3D; newBytesFor(len);\n        for (int i &#x3D; 0; i &lt; len; i++) &#123;\n            putChar(val, i, value[off]);\n            off++;\n        &#125;\n        return val;\n    &#125;\n    &#x2F;&#x2F; 得到一个存储双字符编码长度的数组\n    public static byte[] newBytesFor(int len) &#123;\n        if (len &lt; 0) &#123;\n            throw new NegativeArraySizeException();\n        &#125;\n        if (len &gt; MAX_LENGTH) &#123;\n            throw new OutOfMemoryError(&quot;UTF16 String size is &quot; + len +\n                                       &quot;, should be less than &quot; + MAX_LENGTH);\n        &#125;\n        &#x2F;&#x2F; 返回你指定字符个数的二倍大小的数组\n        return new byte[len &lt;&lt; 1];\n    &#125;\n    static void putChar(byte[] val, int index, int c) &#123;\n      &#x2F;&#x2F; 边界检查，index&gt;&#x3D;0且小于字符数\n        assert index &gt;&#x3D; 0 &amp;&amp; index &lt; length(val) : &quot;Trusted caller missed bounds check&quot;;\n        &#x2F;&#x2F; index &#x3D; index&lt;&lt;1 ，即index*2\n        index &lt;&lt;&#x3D; 1;\n        &#x2F;&#x2F; 这里是将char中的双字符一个个的进行处理，因为要双字符则是16位二进制，一个字符八个二进制\n        &#x2F;&#x2F; 这里移位就是将高位和低位分别放入byte数组中。\n        val[index++] &#x3D; (byte)(c &gt;&gt; HI_BYTE_SHIFT);\n        val[index]   &#x3D; (byte)(c &gt;&gt; LO_BYTE_SHIFT);\n    &#125;\n    static final int HI_BYTE_SHIFT;  &#x2F;&#x2F;0 \n    static final int LO_BYTE_SHIFT;  &#x2F;&#x2F;8\n\n\n\n存储实现\n在Java8及之前，底层存储还是private final char value[]， 自从9版本开始，底层实现更改了private final byte[] value;。其原因是：若存储字符串由英文字符组成，则在编码的时候可以使用一个byte的大小就可以表示，而存储汉字的时候，是由两个byte来实现的，对比之前的char存储实现，在最理想情况下，byte数组要比char数组要节省一半的空间。\n\nlength( )\n因为其存储为字节数组，之前字符数组的时候，String的长度是计算char的个数，而现在的length的实现有些许变化。\n\n    @Native static final byte LATIN1 &#x3D; 0;\n  @Native static final byte UTF16  &#x3D; 1;\n  public int length() &#123;\n      return value.length &gt;&gt; coder();\n  &#125;\n  byte coder() &#123;\n      return COMPACT_STRINGS ? coder : UTF16;   &#x2F;&#x2F; coder 变量可取值 UTF-16和LATIN1\n  &#125;\n  static final boolean COMPACT_STRINGS;\n  static &#123;\n      COMPACT_STRINGS &#x3D; true;\n  &#125;\n&#x2F;&#x2F; use\n  System.out.println(&quot;Qidai&quot;.length());   &#x2F;&#x2F; 5 其中coder()&#x3D;0\n  System.out.println(&quot;期待&quot;.length());   &#x2F;&#x2F; 2  其中coder()&#x3D;1\n\n\n\n\n如上有一个很重要的方法就是coder()，里面一个关键的字段为：COMPACT_STRINGS，其意思是字符串是否采用压缩存储，默认为true，若为false，则字符串始终采用UTF-16编码，否则就是默认开始字符串压缩，这个值是由JVM启动时注入的。\ncoder()方法中的coder变量是用来标识字符串是否为可以都用单字节编码，可以的话值为LATIN1，否则UTF-16。\n所以coder()方法的逻辑就是看是否采用字符串压缩，是的话则返回coder值，否则返回UTF-16，即返回1。\n解析：如上两个使用，第一个Qidai中每个字符都是可以单字节编码解决的，则coder变量为LATIN1=0，COMPACT_STRINGS=true，则coder()方法返回0，则value.length不变返回5。类似的，第二个使用，期待则coder变量返回1，由于汉字的俩字节编码的，则期待二次的value.length=4，最终coder()方法返回1，4&gt;&gt;1=2，则最终为2。\n\n\n\n\n\n\n\n\n\n\nString的底层实现的变动进而影响的相关类的实现，比如StringBuffer和StringBuilder的实现。其父类均为AbstractStringBuilder，其内部实现也改为了byte[]，coder的实现方式。\n不变性\nString类的注释为：Strings are constant; their values cannot be changed after they are created，即字符串被创建后就不能改变了。\n无论从字符串的不变性从其类的final防止继承，各种私有变量，还是各种常用方法的具体实现就可以看出，都是为了保证String的不可变，常用方法对于String的每次操作都是返回一个新字符串，拿subString方法举例，来说明\n\n&#x2F;&#x2F; 最终的实现都是newString，足以说明之前的字符串是不会动的，而只是返回了一个新的字符串对象。\npublic String substring(int beginIndex, int endIndex) &#123;\n    int length &#x3D; length();\n    checkBoundsBeginEnd(beginIndex, endIndex, length);\n    if (beginIndex &#x3D;&#x3D; 0 &amp;&amp; endIndex &#x3D;&#x3D; length) &#123;\n        return this;\n    &#125;\n    int subLen &#x3D; endIndex - beginIndex;\n    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)\n                      : StringUTF16.newString(value, beginIndex, subLen);\n&#125;\n\n\n\n\n\n\n\n\n\n\n\nhttps://www.zhihu.com/question/55994121http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/\n常量池\n常量池分，静态常量池，运行常量池，以及字符串常量池\n静态常量池：当java被编译之后，通过javap可以看到属于单独类文件的常量池信息，包括字面量和符号引用。字面量包括字符串，final常量，其他数据类型的值。符号引用包括类和结构的完全限定名，字段名称和描述符，方法名称和描述符。\n运行时常量池：当完成类加载后，将编译成的一个个class文件加载入内存，一个class文件在方法区也对应一个独立的class的区域，其中class文件中的字符串常量将存入字符串常量池，而跟其他的分开。\n字符串常量池：位于方法区外面，为类中的编译期可确定的字符串，后期使用的时候也会加入新的字符串，是全局共享的。创建字符串时首先会从字符串常量池中查找是否有一样的字符串，有则直接返回引用，否则创建一个放入池中。这种操作仅限于String str = &quot;xx&quot;方式，对于String str = new String(&quot;xx&quot;)方式还略有不同。\n\n\n\npublic static void main(String[] args) &#123;\n    String sxx1 &#x3D; &quot;QIDAI&quot;;\n    String sxx2 &#x3D; new String(&quot;Qidai&quot;);\n    double d1 &#x3D; 1.2;\n    Animal animal &#x3D; new Animal();\n&#125;\n\n\n如下，类编译后的详细信息，可以看到里面确实包含了一些常量信息，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。\n有一个有意思的是double类型的也加入了常量池，但是如果我们修改代码为double d1 = 1.0D，则常量池中就找不到double的信息了，而在最下面的main的汇编代码中就会多一条dconst_1，若是double d1 = 2.0D，则多一个dconst_2，对于float也是如此，我猜测是jvm的优化吧，由于大部分小数是不可完全的精确表示的，所以干脆直接的放入了常量池，而对于这种1.0整的小数，jvm会认出来并直接使用了，这仅仅是个人猜测。\n\nE:\\projects\\untitled\\target\\classes\\org\\example&gt;javap -v -c Main.class\nClassfile &#x2F;E:&#x2F;projects&#x2F;untitled&#x2F;target&#x2F;classes&#x2F;org&#x2F;example&#x2F;Main.class\n  Last modified 2023年1月16日; size 653 bytes\n  SHA-256 checksum 9a66102117f2905bdc9235cd77869b0de6f0e57cd3d953b8f19ea6b361a5d422\n  Compiled from &quot;Main.java&quot;\npublic class org.example.Main\n  minor version: 0\n  major version: 61\n  flags: (0x0021) ACC_PUBLIC, ACC_SUPER\n  this_class: #21                         &#x2F;&#x2F; org&#x2F;example&#x2F;Main\n  super_class: #2                         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类\n  interfaces: 0, fields: 0, methods: 2, attributes: 1\nConstant pool:                                                                     &#x2F;&#x2F; 静态常量池信息\n   #1 &#x3D; Methodref          #2.#3          &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         &#x2F;&#x2F; 父类的构造方法，符号引用#2,#3\n   #2 &#x3D; Class              #4             &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类object\n   #3 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V                          &#x2F;&#x2F; 引用5，6，表示无参构造\n   #4 &#x3D; Utf8               java&#x2F;lang&#x2F;Object\n   #5 &#x3D; Utf8               &lt;init&gt;\n   #6 &#x3D; Utf8               ()V\n   #7 &#x3D; String             #8             &#x2F;&#x2F; QIDAI                       &#x2F;&#x2F; 字符串常量符号引用\n   #8 &#x3D; Utf8               QIDAI                                         &#x2F;&#x2F; 字符串常量\n   #9 &#x3D; Class              #10            &#x2F;&#x2F; java&#x2F;lang&#x2F;String            \n  #10 &#x3D; Utf8               java&#x2F;lang&#x2F;String\n  #11 &#x3D; String             #12            &#x2F;&#x2F; Qidai                       &#x2F;&#x2F; 字符串常量符号引用\n  #12 &#x3D; Utf8               Qidai                                        &#x2F;&#x2F; 字符串常量\n  #13 &#x3D; Methodref          #9.#14         &#x2F;&#x2F; java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V   &#x2F;&#x2F; 字符串引用的狗崽方法\n  #14 &#x3D; NameAndType        #5:#15         &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V\n  #15 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V                          &#x2F;&#x2F; 字符串的有参构造\n  #16 &#x3D; Double             1.2d                                         &#x2F;&#x2F; 数值常量\n  #18 &#x3D; Class              #19            &#x2F;&#x2F; org&#x2F;example&#x2F;Animal         &#x2F;&#x2F; animal 的符号引用\n  #19 &#x3D; Utf8               org&#x2F;example&#x2F;Animal                           &#x2F;&#x2F; animal 的真实类型\n  #20 &#x3D; Methodref          #18.#3         &#x2F;&#x2F; org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V   &#x2F;&#x2F; animal 的无参构造\n  #21 &#x3D; Class              #22            &#x2F;&#x2F; org&#x2F;example&#x2F;Main\n  #22 &#x3D; Utf8               org&#x2F;example&#x2F;Main\n  #23 &#x3D; Utf8               Code\n  #24 &#x3D; Utf8               LineNumberTable\n  #25 &#x3D; Utf8               LocalVariableTable\n  #26 &#x3D; Utf8               this\n  #27 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Main;\n  #28 &#x3D; Utf8               main\n  #29 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V\n  #30 &#x3D; Utf8               args\n  #31 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;\n  #32 &#x3D; Utf8               sxx1                               &#x2F;&#x2F; 对象名\n  #33 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;\n  #34 &#x3D; Utf8               sxx2                               &#x2F;&#x2F; 对象名\n  #35 &#x3D; Utf8               d1\n  #36 &#x3D; Utf8               D \n  #37 &#x3D; Utf8               animal                       &#x2F;&#x2F; 对象名 \n  #38 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Animal;\n  #39 &#x3D; Utf8               SourceFile\n  #40 &#x3D; Utf8               Main.java\n&#123;\n  public org.example.Main();\n    descriptor: ()V\n    flags: (0x0001) ACC_PUBLIC\n    Code:\n      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1\n         0: aload_0\n         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V\n         4: return\n      LineNumberTable:\n        line 10: 0\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0       5     0  this   Lorg&#x2F;example&#x2F;Main;\n\n  public static void main(java.lang.String[]);\n    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V\n    flags: (0x0009) ACC_PUBLIC, ACC_STATIC\n    Code:\n      stack&#x3D;3, locals&#x3D;6, args_size&#x3D;1\n         0: ldc           #7                  &#x2F;&#x2F; String QIDAI\n         2: astore_1\n         3: new           #9                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String\n         6: dup\n         7: ldc           #11                 &#x2F;&#x2F; String Qidai\n         9: invokespecial #13                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V\n        12: astore_2\n        13: ldc2_w        #16                 &#x2F;&#x2F; double 1.2d\n        16: dstore_3\n        17: new           #18                 &#x2F;&#x2F; class org&#x2F;example&#x2F;Animal\n        20: dup\n        21: invokespecial #20                 &#x2F;&#x2F; Method org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V\n        24: astore        5\n        26: return\n      LineNumberTable:\n        line 12: 0\n        line 13: 3\n        line 14: 13\n        line 15: 17\n        line 16: 26\n      LocalVariableTable:\n        Start  Length  Slot  Name   Signature\n            0      27     0  args   [Ljava&#x2F;lang&#x2F;String;\n            3      24     1  sxx1   Ljava&#x2F;lang&#x2F;String;\n           13      14     2  sxx2   Ljava&#x2F;lang&#x2F;String;\n           17      10     3    d1   D\n           26       1     5 animal   Lorg&#x2F;example&#x2F;Animal;\n&#125;\nSourceFile: &quot;Main.java&quot;\n\n\n\n示例String str &#x3D; new String(&quot;1&quot;);\nString n &#x3D; &quot;1&quot;;\n&#x2F;&#x2F;str !&#x3D; n\n\n\n上面说创建字符串时会在常量池中寻找,那么new String(&quot;1&quot;)为啥不等于String str = &quot;1&quot;呢？new操作其实是创建了一个真正的对象，所以这个new出来的对象1一定会在堆内存，new出来的对象是引用常量池中的对象的，如果常量池中没有这个对象，new操作就会先在常量池中新建一个常量，然后再引用他。\n\n\nintern\n当调用intern方法时，如果池中已经包含一个由equals方法确定的与此string对象相等的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。因此，对于任意两个字符串s和t，s.intern（）==t.intern为真，当且仅当s.equals（t）为真。\n\n拼接String s1 &#x3D; &quot;&#39;A&quot; + &quot;B&quot;;\nString s2 &#x3D; &quot;&#39;A&quot; + new String(&quot;B&quot;);\nString s3 &#x3D; new String(&quot;A&quot;) + new String(&quot;B&quot;);\n\n\n从javap中只发现了一个常量即”A”+”B”，在编译期间可直接确定，并放入了常量池。\n其他的我们可以看到的实现是用到了StringConcatFactory类中的makeConcatWithConstants拼接方法。而并非之前的StringBuilder实现了。\n\n","slug":"java/basic/basicjava3","date":"2023-01-13T08:15:35.000Z","categories_index":"java基础","tags_index":"java","author_index":"Qidai"},{"id":"8e53ea792c68f7c08b10733cf876a7d7","title":"Redis复习：基本命令","content":"特性\n键值 (key-value)型，value支持多种不同数据结构，功能丰富。\n单线程，每个命令具备原子性。\n低延迟，速度快(基于内存、10多路复用、良好的编码)。\n支持数据持久化。\n支持主从集群、分片集群。\n\n登入\nredis-cli -h host -p port -a password，登入成功后，输入ping，后返回pong。\n\n\n\n\n\n\n\n\n\n\nhttps://www.redis.com.cn/redis-keys.htmlhttps://redis.io/docs/data-types/\n基础命令-- 除了以下命令，还有好多命令参考上面文档\n127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3\nOK\n-- KEYS:查看符合模板的所有key，不建议在生产环境设备上使用  : keys [正则]\n127.0.0.1:6379&gt; keys *\n1) &quot;k1&quot;\n2) &quot;k3&quot;\n3) &quot;k2&quot;\n127.0.0.1:6379&gt; keys *1\n1) &quot;k1&quot;\n127.0.0.1:6379&gt; keys k*\n1) &quot;k1&quot;\n2) &quot;k3&quot;\n3) &quot;k2&quot;\n-- DEL:删除一个指定的key : del [key...]\n127.0.0.1:6379&gt; del k1\n(integer) 1\n127.0.0.1:6379&gt; keys *\n1) &quot;k3&quot;\n2) &quot;k2&quot;\n-- EXISTS:判断key是否存在，0不存在，1存在\n127.0.0.1:6379&gt; EXISTS k1\n(integer) 0\n127.0.0.1:6379&gt; EXISTS k2\n(integer) 1\n-- TTL:查看一个KEY的剩余有效期，被删除-2，若永久返回-1\n127.0.0.1:6379&gt; TTL k1\n(integer) -2\n127.0.0.1:6379&gt; TTL k2\n(integer) -1\n-- EXPIRE:给一个key设置有效期，有效期到期时该key会被自动删除，设置k2在20秒后过期\n127.0.0.1:6379&gt; EXPIRE k2 20\n(integer) 1\n127.0.0.1:6379&gt; TTL k2 \n-- 剩余13秒 \n(integer) 13\n127.0.0.1:6379&gt; TTL k2\n-- 剩余5秒 \n(integer) 5\n-- 过期被删除\n127.0.0.1:6379&gt; TTL k2\n(integer) -2\n\nString\nRedis字符串存储字节序列，包括文本、序列化对象和二进制数组。它们通常用于缓存，但它们支持额外的功能，允许实现计数器并执行按位操作。\n最大不超过512MB。\n大部分操作都是O(1)操作，但是一些随机命令可能会达到O(n)级别。比如 SUBSTR, GETRANGE,  SETRANGE\n\n-- SET\t设置指定 key 的值\n-- GET\t获取指定 key 的值\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;\n-- GETRANGE\t返回 key 中字符串值的子字符\n127.0.0.1:6379&gt; GETRANGE name 0 2\n&quot;qid&quot;\n-- SETRANGE\t从偏移量 offset 开始用 value 覆写给定 key 所储存的字符串值\n127.0.0.1:6379&gt; SETRANGE name 1 ohbug\n(integer) 6\n127.0.0.1:6379&gt; get name\n&quot;qohbug&quot;\n-- SETEX\t设置 key 的值为 value 同时将过期时间设为 seconds\n127.0.0.1:6379&gt; SETEX name 20 ooo\nOK\n127.0.0.1:6379&gt; get name\n&quot;ooo&quot;\n127.0.0.1:6379&gt; ttl name\n(integer) 12\n127.0.0.1:6379&gt; ttl name\n(integer) 11\n-- SETNX\t只有在 key 不存在时设置 key 的值\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; SETNX name ohbug\n(integer) 0\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;\n-- STRLEN\t返回 key 所储存的字符串值的长度\n127.0.0.1:6379&gt; STRLEN name\n(integer) 5\n-- INCR\t将 key 中储存的数字值增一\n-- INCRBY\t将 key 所储存的值加上给定的增量值 ( increment )\n127.0.0.1:6379&gt; set age 1\nOK\n127.0.0.1:6379&gt; get age\n&quot;1&quot;\n127.0.0.1:6379&gt; INCR age\n(integer) 2\n127.0.0.1:6379&gt; get age\n&quot;2&quot;\n127.0.0.1:6379&gt; INCRBY age 5   -- 每次加五\n(integer) 7\n127.0.0.1:6379&gt; get age\n&quot;7&quot;\n\nkey 结构-- 设置一个key名为name，值为qidai\nset name qidai\n-- 为了区分name，那么可以使用前缀方式，分隔符为分号 :  ，\n-- 类似于分表操作\n127.0.0.1:6379&gt; set ohbug:src:name qidai\nOK\n127.0.0.1:6379&gt; set ohbug:cls:name red22\nOK\n127.0.0.1:6379&gt; set name qidai\nOK\n127.0.0.1:6379&gt; keys *\n1) &quot;ohbug:src:name&quot;\n3) &quot;ohbug:cls:name&quot;\n4) &quot;name&quot;\n127.0.0.1:6379&gt; get ohbug:src:name\n&quot;qidai&quot;\n127.0.0.1:6379&gt; get ohbug:cls:name\n&quot;red22&quot;\n127.0.0.1:6379&gt; get name\n&quot;qidai&quot;\n\n\n命令行看不出啥，来看看图形界面。明显看出单独的name和其他有限定的name的不同。\n\n  \nLists\n基于链表实现，可以用来实现堆栈和队列，以及为后台工作系统构建队列管理。\n最长长度限制 ： 2^{32} -1\n由于是基于链表实现，所以对头尾操作是O(1)，而对于某些插入命令，设值LSET复杂度是O(n)的。\n\n  \n-- BLPOP\t移出并获取列表的第一个元素，如果列表内为空，则阻塞\n-- BLMOVE 将一个元素移入另一个list中，如果原list中为空，则阻塞\n\n-- BRPOP\t移出并获取列表的最后一个元素\n-- LINDEX\t通过索引获取列表中的元素\n-- LINSERT\t在列表的元素前或者后插入元素\n-- LLEN\t获取列表长度\n-- LPOP\t移出并获取列表的第一个元素\n-- LPUSH\t将一个或多个值插入到列表头部\n-- RPUSH\t在列表中添加一个或多个值\n-- RPUSHX\t为已存在的列表添加值\n-- LREM\t移除列表元素\n-- LSET\t通过索引设置列表元素的值\n-- LTRIM\t对一个列表进行修剪(trim)\n-- RPOP\t移除并获取列表最后一个元素\n-- LPUSHX\t将一个值插入到已存在的列表头部\n-- BRPOPLPUSH\t从列表中弹出一个值，并将该值插入到另外一个列表中并返回它\n-- RPOPLPUSH\t移除列表的最后一个元素，并将该元素添加到另一个列表并返回\n\nSets\n无序且元素唯一，可用于跟踪记录唯一的元素，比如IP地址，执行常见的集合操作，如交集、并集和差集。\n可用于查找共同好友之类的操作。\n最多2^32-1 个元素。\n大部分命令都是O(1)级别，但是对于元素多的时候，要当心  SMEMBERS 操作，这个操作的级别是O(n)级别，它会返回所有set元素。作为替换操作，可以考虑 SSCAN  ，SSCAN 允许迭代地检索集合的所有成员。\n\n  \n-- SADD\t向集合添加一个或多个成员\n-- SCARD\t获取集合的成员数\n-- SDIFF\t返回给定所有集合的差集\n-- SDIFFSTORE\t返回给定所有集合的差集并存储在 destination 中\n-- SINTER\t返回给定所有集合的交集\n-- SINTERSTORE\t返回给定所有集合的交集并存储在 destination 中\n-- SISMEMBER\t判断 member 元素是否是集合 key 的成员\n-- SMEMBERS\t返回集合中的所有成员\n-- SMOVE\t将 member 元素从 source 集合移动到 destination 集合\n-- SPOP\t移除并返回集合中的一个随机元素\n-- SRANDMEMBER\t返回集合中一个或多个随机数\n-- SREM\t移除集合中一个或多个成员\n-- SUNION\t返回所有给定集合的并集\n-- SUNIONSTORE\t所有给定集合的并集存储在 destination 集合中\n-- SSCAN\t迭代集合中的元素\n\nSorted Sets\nstring 类型元素的集合，且不允许重复的成员，每个元素都会关联一个名为score的 double 类型的分数，根据score进行排序。\n通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。但大部分是logn级别的复杂度\n可用于排名应用，可取出前几名，后几名，中间几名。\n默认range返回的是根据score返回的升序。\n\n127.0.0.1:6379&gt; zadd math 100 qidai\n(integer) 1\n127.0.0.1:6379&gt; zadd math 12 liming\n(integer) 1\n127.0.0.1:6379&gt; zadd math 23 xiaohong\n(integer) 1\n127.0.0.1:6379&gt; ZADD math 66 zhangsan\n(integer) 1\n127.0.0.1:6379&gt; ZRANGE math 0 1\n1) &quot;liming&quot;\n2) &quot;xiaohong&quot;\n127.0.0.1:6379&gt; ZRANGE math 0 1 withscores\n1) &quot;liming&quot;\n2) &quot;12&quot;\n3) &quot;xiaohong&quot;\n4) &quot;23&quot;\n-- ZADD\t向有序集合添加一个或多个成员，或者更新已存在成员的分数\n-- ZCARD\t获取有序集合的成员数\n-- ZCOUNT\t计算在有序集合中指定区间分数的成员数\n-- ZINCRBY\t有序集合中对指定成员的分数加上增量 increment\n-- ZINTERSTORE\t计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中\n-- ZLEXCOUNT\t在有序集合中计算指定字典区间内成员数量\n-- ZRANGE\t通过索引区间返回有序集合成指定区间内的成员\n-- ZRANGEBYLEX\t通过字典区间返回有序集合的成员\n-- ZRANGEBYSCORE\t通过分数返回有序集合指定区间内的成员\n-- ZRANK\t返回有序集合中指定成员的索引\n-- ZREM\t移除有序集合中的一个或多个成员\n-- ZREMRANGEBYLEX\t移除有序集合中给定的字典区间的所有成员\n-- ZREMRANGEBYRANK\t移除有序集合中给定的排名区间的所有成员\n-- ZREMRANGEBYSCORE\t移除有序集合中给定的分数区间的所有成员\n-- ZREVRANGE\t返回有序集中指定区间内的成员，通过索引，分数从高到底\n-- ZREVRANGEBYSCORE\t返回有序集中指定分数区间内的成员，分数从高到低排序\n-- ZREVRANK\t返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序\n-- ZSCORE\t返回有序集中，成员的分数值\n-- ZUNIONSTORE\t计算一个或多个有序集的并集，并存储在新的 key 中\n-- ZSCAN\t迭代有序集合中的元素（包括元素成员和元素分值）\n\nHashes\n结构为key - (file-value)，即一个key标识一个file-value对。适用存储对象。\n大部分操作时间复杂度是O(1)，其中 HKEYS, HVALS, HGETALL 是O(n) 级别。\n例如： hset user name qidai sex man age 12，则结构如下图\n\n  \n-- HDEL\t删除一个或多个哈希表字段\n-- HEXISTS\t查看哈希表 key 中，指定的字段是否存在\n-- HGET\t获取存储在哈希表中指定字段的值\n-- HGETALL\t获取在哈希表中指定 key 的所有字段和值\n-- HINCRBY\t为哈希表 key 中的指定字段的整数值加上增量 increment\n-- HINCRBYFLOAT\t为哈希表 key 中的指定字段的浮点数值加上增量 increment\n-- HKEYS\t获取所有哈希表中的字段\n-- HLEN\t获取哈希表中字段的数量\n-- HMGET\t获取所有给定字段的值\n-- HMSET\t同时将多个 field-value (域-值)对设置到哈希表 key 中\n-- HSET\t将哈希表 key 中的字段 field 的值设为 value\n-- HSETNX\t只有在字段 field 不存在时，设置哈希表字段的值\n-- HVALS\t获取哈希表中所有值\n-- HSCAN\t迭代哈希表中的键值对\n-- HSTRLEN\t返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度\n","slug":"redis/basic-redis1","date":"2023-02-03T04:17:32.000Z","categories_index":"redis","tags_index":"redis","author_index":"Qidai"},{"id":"fab60566d104e206f93915adac60dea5","title":"红黑树 VS AVL","content":"\n\n\n\n\n\n\n\n\nhttps://zhuanlan.zhihu.com/p/95892351https://www.bilibili.com/video/BV1xG4y1b7Zu/?spm_id_from=333.788.recommend_more_video.5&amp;vd_source=e1294f8209fc39ec6e458c23cce6613f\n\nBST搜索树：左小右大，在元素基本有序时，插入操作可能将树形结构变成链表结构。此时复杂度并未降低，为改善这个情况，引入了AVL平衡二叉树。\n\n平衡二叉树 AVL\n树上任一结点的左子树和右子树的高度之差不超过1。\n结点的平衡因子=左子树高-右子树高。各个节点的平衡因子绝对值不超过1。\n\n调整\n因为要保证每一个节点的平衡因子绝对值都不超过1，则在插入时就需要进行频繁的二叉树节点的调整。\n\nLL右\n在发生不平衡节点A的左侧的左侧插入导致的，即将不平衡节点的左子树B进行右旋，剩余节点进行有序插入即可。\n\n  \nRR左\n在发生不平衡节点A的右侧的右侧插入导致的，即将不平衡节点的右子树B进行左旋，剩余节点进行有序插入即可。\n\n  \nLR左右\n在发生不平衡节点A的左侧的右侧插入导致的，即将不平衡节点的左子树B进行左旋，再将整体右旋，剩余节点进行有序插入即可。\n\n  \nRL右左\n在发生不平衡节点A的右侧的左侧插入导致的，即将不平衡节点的右子树B进行右旋，再将整体左旋，剩余节点进行有序插入即可。\n\n  \n优缺点\n查找效率优秀：若树高为h，查找一个关键字最多需要对比h次，即时间复杂度不可能超过o(h)。含有n个结点的平衡二叉树的最大深度为 ，平衡二叉树的平均查找长度为 ，即为  的时间复杂度。\n修改结构频繁：若大部分的插入删除操作总是打破平衡节点为1的限制，那么AVL树就会一直调整，这样开销会很大。\n\n\n\n\n\n\n\n\n\n\n既然AVL查找优秀，但是删除操作时有限制，那么将限制放松一些，则规则就开始与红黑树类似了。\n红黑树  \n\n节点有红色和黑色两种\n根节点一定是黑色的，若调整后根节点为红色，则需要变黑。\n叶子节点规定（nil节点）都是黑色的。\n不能有连续的红色节点，红色节点的子节点必须是黑色节点。\n从同一个节点出发，此节点到叶子节点所经过的所有路径上的黑色节点数相同。\n\n复杂度\n由于红黑树是由红节点+黑节点构成，记作红节点数为R，黑节点数为B。则总数n=R+B。若此时先忽略红节点树，则只剩黑节点数，由于每条路径上的黑节点书都是相同的，则此时就退化成了一个AVL树，AVL树的复杂度为  ，再将红节点数添加回来，此时红节点最多添加B个，即红黑交错的时候，红节点是最多的。此时红节点数的复杂度与黑节点数的复杂度相同，则此时整个红黑树的复杂度为  。由于叶子节点都为黑节点，则黑节点的数量最少占整个树节点数量的一半，则假设此时黑节点的数量最少占整个树节点数量的一半，即 B = N/2 ，则此时整个红黑树的复杂度为   = 。\n对比AVL的时间复杂度，整体是相同的，但是还是不及AVL的查找效率，所以红黑树是牺牲了一定的查找效率换来的是结构的更加稳定。这也是HashMap使用红黑树而不采用AVL的理由。\n\n变换规则  \n调整\n\n\n\n\n\n\n\n\nhttps://www.cs.usfca.edu/~galles/visualization/RedBlack.html\n\n红黑树的插入依旧沿用BST的左小右大原则，只是当到达一定的变化规则时，需要进行不同变化。\n\n插入根节点65时直接为黑色。此时一个节点不满足任何变化规则。\n\n后插入62，因为62 &lt; 65，所以链接到65的左边。此时62的父节点为黑色，满足无需操作。\n\n后插入32，链接到62左侧。此时32的父节点是红色，叔节点是黑色，且32是在左左插入的。满足左左条件，进行右旋+变色调整。此时红色62被提到根节点位置，红色节点62下面是不可以挂红色节点32的，则根节点62与黑色节点65交换颜色。\n\n\n  \n\n后插入33，链接到32的右侧，此时33的父节点32为红色，叔节点65也是红色，满足 父叔32，65都变黑，祖父62变红。祖父62变成当前节点，递归这个规则。祖父变红成当前节点后，由于是根节点必须变黑。\n\n后插入50，链接到33的右侧，此时50的父节点33是红色，叔节点null黑色，且相对于32来说为右右插入，满足右右条件，进行左旋再变色。提红色33为父节点，33再与32交换颜色。\n\n\n  \n\n后插入55，链接到50右侧，父节点50黑色，无需操作。\n后插入57，链接到55右侧，父节点55红色，叔节点null黑色，且相对于50来说是右右插入，满足右右条件，进行左旋再变色。操作类似。\n\n  \n\n后插入60，链接到57右侧，父节点57红色，叔节点50红色，满足 父叔57，50都变黑，祖父55变红。祖父55变成当前节点，递归这个规则，55的父节点33是红色，叔节点65是黑色，且相对于62是右右插入，满足左右条件，进行左旋右旋再变色。\n\n  \n","slug":"datastructure/redblacktree-avl","date":"2023-02-02T02:07:00.000Z","categories_index":"数据结构","tags_index":"红黑树,AVL","author_index":"Qidai"},{"id":"cfeb076eceaa089663cf2e1f4248e9ee","title":"Java复习篇：Map源码实现","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n\n\n紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。\n下面进行实现类的源码分析，主要是分析其实现类的主要功能。\n\n\n\n\n\n\n\n\n\n\n对于红黑树的原理可以参考本博客中文章  《红黑树 VS AVL》https://www.pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.htmlhttps://www.bilibili.com/video/BV1ST411o7GR/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=e1294f8209fc39ec6e458c23cce6613f\nHashMap移位运算A&gt;&gt;1;   &#x2F;&#x2F; 相当于A&#x2F;2，高位正数补零，负数补一\nA&lt;&lt;1;   &#x2F;&#x2F;相当于A*2，高位移出，低位的空位补零\nA&gt;&gt;&gt;1； &#x2F;&#x2F;无符号右移，只使用 0 进行补位\n散列表\n即一个元素通过一个function可以得出对应的的散列值，但不同的元素也可能得到相同的散列值。是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。\n把关键字称为 Key，记录称为 Value，通过 Key 访问一个function来得到 Value 的地址。而这个function，也叫作散列函数或者哈希函数，存放记录的数组叫作散列表。\n当发生两个key产生了同一个散列值时，此时发生hash碰撞，解决办法就是拉链法，即如图通过链表的方式将发生冲突的元素都连接起来。HashMap就是采用这一方法解决hash冲突，但是如果当冲突非常多，那么链表会越来越长，则效率变差，此时HashMap中定义了一个值，当链表长度超过此值且满足一定条件时，将链表转化为红黑树。\n\n\nHashMap结构\n\nMap的实现基于数组+链表+红黑树结构。每一个数组被称为一个bin，每一个bin里面可能连接着链表或者红黑树结构。\n\n数组的源码定义，从此看出Map的实现基于Node类型的数组。\n\n\ntransient Node&lt;K,V&gt;[] table;\n\n\n链表的源码定义\n\nstatic class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;\n    final int hash;\n    final K key;\n    V value;\n    Node&lt;K,V&gt; next;\n&#125;\n\n\n\n红黑树的源码定义为\n\nstatic final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;\n    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links\n    TreeNode&lt;K,V&gt; left;\n    TreeNode&lt;K,V&gt; right;\n    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion+\n    boolean red;\n    ...\n&#125;\n\n内部变量&#x2F;**\n * 默认容量\n *&#x2F;\nstatic final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16\n&#x2F;**\n * 最大容量\n *&#x2F;\nstatic final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;\n&#x2F;**\n * 负载因子，当数组的容量达到总容量的百分之七十五时，则map就需要考虑扩容了\n *&#x2F;\nstatic final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;\n&#x2F;**\n * 树化阈值，当一个bin中的链表元素个数超过8时才具备链表转红黑树的条件。\n *&#x2F;\nstatic final int TREEIFY_THRESHOLD &#x3D; 8;\n&#x2F;**\n * 红黑树退化为链表的阈值\n *&#x2F;\nstatic final int UNTREEIFY_THRESHOLD &#x3D; 6;\n&#x2F;**\n * 整个bin的数量达到64个且链表长度达到8个后才具备转换红黑树的条件\n * TREEIFY_THRESHOLD 和 MIN_TREEIFY_CAPACITY 两个变量是同时具备才可以\n * 这样可以避免因为数组容量太小以至于都hash计算到一个bin中，若bin都64个了且链表\n * 还是大于8个长，那么就说明了不是因为数组太小导致的hash冲突\n *&#x2F;\nstatic final int MIN_TREEIFY_CAPACITY &#x3D; 64;\n\n\n\n构造方法 &#x2F;**\n  * 默认的初始化16容量和0.75的负载因子\n  *&#x2F;\n public HashMap() &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted\n &#125;\n&#x2F;**\n  * 指定初始化容量，默认负载因子0.75\n  *&#x2F;\n public HashMap(int initialCapacity) &#123;\n     this(initialCapacity, DEFAULT_LOAD_FACTOR);\n &#125;\n&#x2F;**\n  * 可指定默认初始化容量和负载因子\n  *&#x2F;\n public HashMap(int initialCapacity, float loadFactor) &#123;\n     &#x2F;&#x2F; 参数检查开始\n     if (initialCapacity &lt; 0)\n         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +\n                                            initialCapacity);\n     if (initialCapacity &gt; MAXIMUM_CAPACITY)\n         initialCapacity &#x3D; MAXIMUM_CAPACITY;\n     if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))\n         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +\n                                            loadFactor);\n     &#x2F;&#x2F; 参数检查结束\n     &#x2F;&#x2F; 指定的负载因子\n     this.loadFactor &#x3D; loadFactor;\n     &#x2F;&#x2F; threshold &#x3D; capacity * load factor，即直接算出来了下次数组达到多大的时候进行扩容。\n     this.threshold &#x3D; tableSizeFor(initialCapacity);\n &#125;\n &#x2F;**\n  *&#x2F;\n public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;\n     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;\n     putMapEntries(m, false);\n &#125;\n\n\n其中的putMapEntries方法一会分析，现在来分析一下tableSizeFor。\n\n &#x2F;**\n  * 返回大于cap的最小2的幂次方数，比如给定cap&#x3D;12，返回16，给定5返回8，返回结果始终是2的幂次方\n  * 原理： 因为2的幂次方的二进制都是高位为1，其余位都是0。比如cap&#x3D;100，tableSizeFor应返回128\n  * cap &#x3D; 0000 0000 0000 0000 0000 0000 0110 0100     numberOfLeadingZeros返回25\n  *  -1&#x3D;  10000 0000 0000 0000 0000 0000 0000 0001    无条件&gt;&gt;&gt;25\n  * res:  0000 0000 0000 0000 0000 0000 1000 0000      128\n  *\n  * 旧版HashMap.tableSizeFor的参考文章：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiyixiaodao&#x2F;p&#x2F;14483876.html\n  *&#x2F;\n static final int tableSizeFor(int cap) &#123;\n     &#x2F;&#x2F; 返回无符号整形i的最高非零位前面的0的个数，包括符号位在内\n     &#x2F;&#x2F; cap-1是防止出现cap已经是2的次方数了\n     int n &#x3D; -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);\n     &#x2F;&#x2F; 小于0即cap为负数，负数返回1，否则只要不超过 最大容量 都会返回n+1\n     return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;\n &#125;\n&#x2F;**\n  *  返回无符号整形i的最高非零位前面的0的个数，包括符号位在内。\n  *&#x2F;\n public static int numberOfLeadingZeros(int i) &#123;\n     &#x2F;&#x2F; HD, Count leading 0&#39;s\n     &#x2F;&#x2F; 若为0或负数，\n     if (i &lt;&#x3D; 0)\n         &#x2F;&#x2F; 0的所有位都是0，所以返回32位，若i为负数，负数的二进制位的最高位已经是1了，所以返回0；\n         return i &#x3D;&#x3D; 0 ? 32 : 0;\n     int n &#x3D; 31;\n     &#x2F;**\n      * 举例子  i&#x3D;65537\n      *     7: 0000 0000 0000 0001 0000 0000 0000 0001\n      * 1&lt;&lt;16: 0000 0000 0000 0001 0000 0000 0000 0000\n      * 1&lt;&lt;8 : 0000 0000 0000 0000 0000 0001 0000 0000\n      * 1&lt;&lt;4 : 0000 0000 0000 0000 0000 0000 0001 0000\n      * 1&lt;&lt;2 : 0000 0000 0000 0000 0000 0000 0000 0100\n      *\n      * 其中：i &gt;&#x3D; 1 &lt;&lt; 16 ，因为1&lt;&lt;16的高16位有1，若i&gt;1&lt;&lt;16，则i的高十六位一定也有1\n      *      i &gt;&#x3D; 1 &lt;&lt; 16，  满足，则n&#x3D;15，i&#x3D;0000 0000 0000 0000 0000 0000 0000 0001&#x3D;1\n      *      i &gt;&#x3D; 1 &lt;&lt;  8，不满足\n      *      i &gt;&#x3D; 1 &lt;&lt;  4，不满足\n      *      i &gt;&#x3D; 1 &lt;&lt;  2，不满足\n      *      return 15-0\n      *&#x2F;\n     &#x2F;&#x2F;如果高16位有1，那么n减半（二分查找的核心），i无符号右移16位，保留高16位\n     if (i &gt;&#x3D; 1 &lt;&lt; 16) &#123; n -&#x3D; 16; i &gt;&gt;&gt;&#x3D; 16; &#125;\n     &#x2F;&#x2F;到这里，如果前面一步false，那么高16位都是0；如果上面一步true，那么只有16位了。\n     &#x2F;&#x2F;如果高8位有1，那么n减半（二分查找的核心），i无符号右移8位，保留高8位\n     if (i &gt;&#x3D; 1 &lt;&lt;  8) &#123; n -&#x3D;  8; i &gt;&gt;&gt;&#x3D;  8; &#125;\n     &#x2F;&#x2F;如果高4位有1，那么n减半（二分查找的核心），i无符号右移4位，保留高4位\n     if (i &gt;&#x3D; 1 &lt;&lt;  4) &#123; n -&#x3D;  4; i &gt;&gt;&gt;&#x3D;  4; &#125;\n     &#x2F;&#x2F;如果高2位有1，那么n减半（二分查找的核心），i无符号右移2位，保留高2位\n     if (i &gt;&#x3D; 1 &lt;&lt;  2) &#123; n -&#x3D;  2; i &gt;&gt;&gt;&#x3D;  2; &#125;\n     return n - (i &gt;&gt;&gt; 1);\n &#125;\n\n\n由此看出tablesizeFor的实现最关键的是得到一个数字的高位0的个数，通过对负一移位来实现的。\n\nPut方法public V put(K key, V value) &#123;\n    return putVal(hash(key), key, value, false, true);\n&#125;\n&#x2F;**\n * Implements Map.put and related methods.\n *\n * @param hash hash for key\n * @param key the key\n * @param value the value to put\n * @param onlyIfAbsent if true, don&#39;t change existing value\n * @param evict if false, the table is in creation mode. 只有在构造方法执行的时候，才会传入false为构造模式\n * @return previous value, or null if none\n * 从方法也可以看出来，若put替换value是不增加modCount的。\n *&#x2F;\nfinal V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;\n    &#x2F;&#x2F; tab 保存之前的数组引用，p指向当前要操作的位置上的元素，n&#x3D; tab.length，i遍历下标\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;\n    &#x2F;&#x2F; 如果表为空\n    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)\n        &#x2F;&#x2F; 表进行扩容初始化\n        n &#x3D; (tab &#x3D; resize()).length;\n    &#x2F;&#x2F; 到这表示表不为空，但是hash计算出来的结果映射到的数组下标位置上没有元素\n    &#x2F;&#x2F; (n - 1) &amp; hash，n为表长为2的次方数，只有(n - 1) &amp; hash这样才可以将hash均匀的分配到数组中，\n    &#x2F;&#x2F; 也是通过这种方式进行查位于哪个数组的\n    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)\n        &#x2F;&#x2F; 则直接赋值\n        tab[i] &#x3D; newNode(hash, key, value, null);\n    else &#123;\n        &#x2F;&#x2F; 到这表示表不为空，且位置上有元素\n        Node&lt;K,V&gt; e; K k;\n        &#x2F;&#x2F; 如果此位置上就是要put的key\n        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            &#x2F;&#x2F; 暂存\n            e &#x3D; p;\n        &#x2F;&#x2F; 此位置上第一个与要put的key不匹配，且已经是红黑树了\n        else if (p instanceof TreeNode)\n            &#x2F;&#x2F; 执行红黑树的操作\n            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);\n        else &#123;\n            &#x2F;&#x2F; 即不是红黑树也不是单个元素，则只剩下链表的情况，遍历寻找\n            for (int binCount &#x3D; 0; ; ++binCount) &#123;\n                &#x2F;&#x2F; e已经保存了此位置上第一个元素的引用，判断是否还有下一个元素\n                &#x2F;&#x2F; 之前已经排除了第一个元素就是put的key，则如果没有下一个就直接链接上新node\n                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;\n                    &#x2F;&#x2F; 链接上新node\n                    p.next &#x3D; newNode(hash, key, value, null);\n                    &#x2F;&#x2F; 判断是否需要树化，binCount在遍历链表的时候已经算出目前位置有多少元素了\n                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st\n                        treeifyBin(tab, hash); &#x2F;&#x2F; 进行树化\n                    break;\n                &#125;\n                &#x2F;&#x2F; 如果遍历中找到了与put元素一样的key，则跳出\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    break;\n                &#x2F;&#x2F; 用于循环\n                p &#x3D; e;\n            &#125;\n        &#125;\n        &#x2F;&#x2F; 前面break后，e的引用已经是指向了链表的末尾。 情况为要么后面没元素了要么就是现在就是put的元素key\n        &#x2F;&#x2F; 不为空的情况就是第二种：现在e就是与要put的元素key相同的元素\n        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key\n            &#x2F;&#x2F; 保存旧值用于返回\n            V oldValue &#x3D; e.value;  \n            &#x2F;&#x2F; 是否替换\n            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)\n                e.value &#x3D; value;\n            &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法\n            afterNodeAccess(e);\n            return oldValue;&#x2F;&#x2F; 返回旧值\n        &#125;\n    &#125;\n    ++modCount;\n    &#x2F;&#x2F; 判断是否需要扩容\n    if (++size &gt; threshold)\n        resize();\n    &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法\n    afterNodeInsertion(evict);\n    return null;\n&#125;\n\nresize方法final Node&lt;K,V&gt;[] resize() &#123;\n    &#x2F;&#x2F; 暂存旧引用\n    Node&lt;K,V&gt;[] oldTab &#x3D; table;\n    &#x2F;&#x2F; 对于初始化没有分配空间的情况，oldtab是空的，若不是空，则保存之前的容量\n    &#x2F;&#x2F; 之前的扩容阈值，达到这个阈值后考虑扩容\n    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;\n    int oldThr &#x3D; threshold;\n    &#x2F;&#x2F; newCap扩容后的新容量，newThr扩容后的新阈值\n    int newCap, newThr &#x3D; 0;\n    &#x2F;&#x2F; 若之前有容量\n    if (oldCap &gt; 0) &#123;\n        &#x2F;&#x2F; 已经比最大的容量还大\n        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;\n            &#x2F;&#x2F; 当下次达到Integer.MAX_VALUE个元素后再扩容。\n            &#x2F;&#x2F; 目的是之前扩容阈值&#x3D;capacity*0.75，这样赋值最大值是将剩下的百分十25利用起来\n            threshold &#x3D; Integer.MAX_VALUE;\n            return oldTab;\n        &#125;\n        &#x2F;&#x2F; 未到最大容量而且小于最大容量，则新容量是旧容量的二倍，通过oldCap &lt;&lt; 1实现，\n        &#x2F;&#x2F; 且旧容量已经大于等于16，则下次扩容阈值是之前扩容阈值的二倍\n        &#x2F;&#x2F; 若不满足，代表map初始化的时候指定了初始化容量。容量小于16\n        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;\n                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)\n            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold\n    &#125;\n    &#x2F;&#x2F; 到这表示oldCap&#x3D;0,但是oldThr&gt;0；此时只有初始化时指定参数。oldThr&#x3D;threshold&#x3D;tablesizeFor\n    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold\n        &#x2F;&#x2F; 将阈值直接当作新容量\n        newCap &#x3D; oldThr;\n    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults\n        &#x2F;&#x2F; 初始化时是默认的构造\n        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;\n        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);\n    &#125;\n    if (newThr &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 如果是0，表示newThr在前面的代码中未被赋值，表示只满足else if (oldThr &gt; 0)情况。\n        &#x2F;&#x2F; 计算下次扩容阈值\n        float ft &#x3D; (float)newCap * loadFactor;\n        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?\n                  (int)ft : Integer.MAX_VALUE);\n    &#125;\n    threshold &#x3D; newThr;\n    &#x2F;&#x2F; 下面进行从旧数组将数组迁移到新数组的操作\n    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) &#x2F;&#x2F; 新容量数组\n    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];\n    table &#x3D; newTab;\n    &#x2F;&#x2F; 如果之前的旧数组是空的话代表无元素可迁移，直接返回新数组引用即可。\n    if (oldTab !&#x3D; null) &#123;\n        &#x2F;&#x2F; 循环旧数组中的元素\n        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;\n            Node&lt;K,V&gt; e;\n            &#x2F;&#x2F; 若元素不为空\n            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;\n                &#x2F;&#x2F; 为了方便垃圾回收\n                oldTab[j] &#x3D; null;\n                &#x2F;&#x2F; bin中仅有一个元素\n                if (e.next &#x3D;&#x3D; null)\n                    &#x2F;&#x2F; 映射到新数组中\n                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;\n                &#x2F;&#x2F; 如果已经是树了，进行树的操作\n                else if (e instanceof TreeNode)\n                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);\n                &#x2F;&#x2F; 到这就是链表情况\n                else &#123; &#x2F;&#x2F; preserve order\n                    &#x2F;&#x2F; 若一个bin中有一条链表，那么在遍历此链表上的元素的时候，由于容量不一样了，所以需要对\n                    &#x2F;&#x2F; 元素进行重新的hash计算，则会出现有的元素hash后在新数组的位置与目前位置相同，有些元素\n                    &#x2F;&#x2F; 在hash后在新数组的位置是 原来旧数组的位置加上原来旧容量的长度\n                    &#x2F;&#x2F; 若下标不动的，则依次链接到loxxxx的链表上\n                    &#x2F;&#x2F; 下标动的，依次链接到hixxxx的链表上\n                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;\n                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;\n                    Node&lt;K,V&gt; next;\n                    do &#123;\n                        next &#x3D; e.next;\n                        &#x2F;&#x2F; e.hash &amp; oldCap 决定了链表上的元素的下标是不是动\n                        &#x2F;&#x2F; 因为oldCap都是2的次方，则高位为1，其余位为0\n                        &#x2F;&#x2F; 例如：\n                        &#x2F;&#x2F; oldCap &#x3D; 1 0000\n                        &#x2F;&#x2F; e.hash &#x3D; 1 1111   或\n                        &#x2F;&#x2F; e.hash &#x3D; 0 1111   \n                        &#x2F;&#x2F; 则通过与运算后，链表上的元素就被分为两个链表\n                        &#x2F;&#x2F; 下面就是拆分链表的逻辑\n                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;\n                            if (loTail &#x3D;&#x3D; null)\n                                loHead &#x3D; e;\n                            else\n                                loTail.next &#x3D; e;\n                            loTail &#x3D; e;\n                        &#125;\n                        else &#123;\n                            if (hiTail &#x3D;&#x3D; null)\n                                hiHead &#x3D; e;\n                            else\n                                hiTail.next &#x3D; e;\n                            hiTail &#x3D; e;\n                        &#125;\n                    &#125; while ((e &#x3D; next) !&#x3D; null);\n                    &#x2F;&#x2F; 不为空，则有下标不动的元素链表，直接链接\n                    if (loTail !&#x3D; null) &#123;\n                        loTail.next &#x3D; null;\n                        newTab[j] &#x3D; loHead;\n                    &#125;\n                    &#x2F;&#x2F; 不为空，则有下标移动的元素链表，连接到原来数组下标+旧容量的位置。\n                    if (hiTail !&#x3D; null) &#123;\n                        hiTail.next &#x3D; null;\n                        newTab[j + oldCap] &#x3D; hiHead;\n                    &#125;\n                &#125;\n            &#125;\n        &#125;\n    &#125;\n    return newTab;\n&#125;\n\ngetpublic V get(Object key) &#123;\n    Node&lt;K,V&gt; e;\n    return (e &#x3D; getNode(key)) &#x3D;&#x3D; null ? null : e.value;\n&#125;\nfinal Node&lt;K,V&gt; getNode(Object key) &#123;\n    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n, hash; K k;\n    &#x2F;&#x2F; 若表不空，且key的hash位置不为空才继续\n    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;\n        (first &#x3D; tab[(n - 1) &amp; (hash &#x3D; hash(key))]) !&#x3D; null) &#123;\n        &#x2F;&#x2F; 检查第一个元素是否匹配\n        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node\n            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n            return first;\n        &#x2F;&#x2F; 第一个元素不匹配\n        if ((e &#x3D; first.next) !&#x3D; null) &#123;\n            &#x2F;&#x2F; 从树中寻找\n            if (first instanceof TreeNode)\n                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);\n            &#x2F;&#x2F; 否则遍历链表寻找\n            do &#123;\n                if (e.hash &#x3D;&#x3D; hash &amp;&amp;\n                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))\n                    return e;\n            &#125; while ((e &#x3D; e.next) !&#x3D; null);\n        &#125;\n    &#125;\n    return null;\n&#125;\n\n\n\n\nTreeMaptodo\n","slug":"java/basic/basicjava6","date":"2023-01-29T01:56:01.000Z","categories_index":"java基础","tags_index":"java,todo","author_index":"Qidai"},{"id":"1ecb0dcab298124399035c934d4bcb66","title":"Java复习篇：List源码实现","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n\n\n紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。\n下面进行实现类的源码分析，主要是分析其实现类的主要功能。\n\nListArrayList构造\n从如下的得知，默认的空参构造并不会初始化一个数组，而是类似于懒加载的方式，当加入参数或者指定大小的时候才开始初始化数组大小。\n若 ArrayList 对象都是空实例，则都会指向一个数组对象，以便节约内存。\nDEFAULTCAPACITY_EMPTY_ELEMENTDATA 和  EMPTY_ELEMENTDATA 并不一样。DEFAULTCAPACITY_EMPTY_ELEMENTDATA 用于无参初始化，而 EMPTY_ELEMENTDATA 用于优化创建ArrayList空实例时产生不必要的空数组。\n\n&#x2F;&#x2F; 默认容量\nprivate static final int DEFAULT_CAPACITY &#x3D; 10;\ntransient Object[] elementData;\n&#x2F;&#x2F; 共享的空数组\nprivate static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;\nprivate static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;\n\n&#x2F;&#x2F; 空参构造，从这也可以看到出，ArrayList默认无参数初始化时，底层的数组长度是0，无元素\npublic ArrayList() &#123;\n    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;\n&#125;\n\npublic ArrayList(int initialCapacity) &#123;\n    if (initialCapacity &gt; 0) &#123;\n        &#x2F;&#x2F; 指定长度构造则只构造参数长度的数组对象。\n        this.elementData &#x3D; new Object[initialCapacity];\n    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;\n        &#x2F;&#x2F; 与无参的思路一样\n        this.elementData &#x3D; EMPTY_ELEMENTDATA;\n    &#125; else &#123;\n        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+\n                                            initialCapacity);\n    &#125;\n&#125;\n&#x2F;&#x2F; 参数为Collection的子类即可\npublic ArrayList(Collection&lt;? extends E&gt; c) &#123;\n    &#x2F;&#x2F; 将参数转为数组\n    Object[] a &#x3D; c.toArray();\n    &#x2F;&#x2F; 不为空\n    if ((size &#x3D; a.length) !&#x3D; 0) &#123;\n      &#x2F;&#x2F; 若构造参数也是ArrayList则直接赋值即可\n        if (c.getClass() &#x3D;&#x3D; ArrayList.class) &#123;\n            elementData &#x3D; a;\n        &#125; else &#123;\n          &#x2F;&#x2F; 否则还是执行下面的复制方法\n            elementData &#x3D; Arrays.copyOf(a, size, Object[].class);\n        &#125;\n    &#125; else &#123;\n        &#x2F;&#x2F; 如果传入参数没有元素，则赋值一个共享的空数组，以节约内存。\n        &#x2F;&#x2F; replace with empty array.\n        elementData &#x3D; EMPTY_ELEMENTDATA;\n    &#125;\n&#125;\npublic Object[] toArray() &#123;\n  &#x2F;&#x2F; a 数组内容，长度，a数组类型\n    return Arrays.copyOf(a, a.length, Object[].class);\n&#125;\npublic static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;\n    @SuppressWarnings(&quot;unchecked&quot;)\n    &#x2F;&#x2F; 由于ArrayList的底层就是使用的Object数组，则始终为true，返回一个新数组，新数组与传入参数的对象长度一样\n    &#x2F;&#x2F; 否则返回一个应有对象类型的数组。\n    &#x2F;&#x2F; 根据不同的参数，toArray的实现不一样的，比如若传入HashSet的实现类，则HashSet已经重写了toArray方法，则调用的是HashSet的实现方法，代码就不会执行到这里了\n    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n    &#x2F;&#x2F; 数组复制，然后返回即可\n    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));\n    return copy;\n&#125;        \n\n\n对于 copyof 方法的额外补充。\n\nObject[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;\nObject[] strings &#x3D; Arrays.copyOf(str, 2);\n&#x2F;&#x2F; 此时上面copyof方法中的((Object)newType &#x3D;&#x3D; (Object)Object[].class) 为true\n&#x2F;&#x2F; 若换为String，或者其他类型的数组，则为false\n&#x2F;&#x2F; 如下，如果是Object数组，返回一个新Object数组，新数组与传入参数的规定长度一样\n    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)\n        ? (T[]) new Object[newLength]\n        : (T[]) Array.newInstance(newType.getComponentType(), newLength);\n&#x2F;&#x2F; 否则就返回与实际相符的类型数组。\n    public static Object newInstance(Class&lt;?&gt; componentType, int length)\n        throws NegativeArraySizeException &#123;\n        return newArray(componentType, length);\n    &#125;\n&#x2F;&#x2F; out: class java.lang.String\n  String[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;\n  System.out.println(str.getClass().getComponentType());\ntransient\n\n\n\n\n\n\n\n\nhttps://www.runoob.com/w3cnote/java-transient-keywords.html\n\n被transient修饰的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。只需要实现Serilizable接口，将不需要序列化的属性前添加transient，序列化对象的时候，这个属性就不会序列化到指定的目的地中。\n只能修饰变量，而不能修饰方法和类。变量如果是用户自定义类变量，则该类需要实现Serializable接口。\n被transient关键字修饰的变量不再能被序列化，一个静态变量不管是否被transient修饰，均不能被序列化。\n\nadd\n总结下来就是通过判断数组的大小与元素的数量，来返回合适的容量大小，以便创建合适的数组，在通过copyof方法进行复制元素。\n重点是grow方法的实现，我们可以从源码得到，若满了，则推荐的扩容大小是之前的 1.5呗，是通过 oldCapacity &gt;&gt; 1 实现的。\n\nprotected transient int modCount &#x3D; 0;\n    public boolean add(E e) &#123;\n      &#x2F;&#x2F; 表示内部的修改次数，与迭代器配合，可以判断出迭代过程中是否被修改，防止多线程模式下安全问题\n        modCount++;\n        &#x2F;&#x2F; 添加元素\n        add(e, elementData, size);\n        return true;\n    &#125;\n    &#x2F;&#x2F; e要添加的参数，elementData是底层数组实现，s 已包含元素数量\n    private void add(E e, Object[] elementData, int s) &#123;\n      &#x2F;&#x2F; 数组无空闲地方存放待加入元素，则扩充数组大小，包括两种情况，一种是刚刚初始化完毕无空闲位置，一个是已满无空闲位置\n      &#x2F;&#x2F; 如果为false，即代表数组位置和数组内元素数量不一致，则不需要增长容量，因为有空闲位置。\n        if (s &#x3D;&#x3D; elementData.length)\n            elementData &#x3D; grow();\n        &#x2F;&#x2F; 插入值\n        elementData[s] &#x3D; e;\n        &#x2F;&#x2F; 容量+1\n        size &#x3D; s + 1;\n    &#125;\n    private Object[] grow() &#123;\n        return grow(size + 1);\n    &#125;\n    private Object[] grow(int minCapacity) &#123;\n      &#x2F;&#x2F; 保存原来长度\n        int oldCapacity &#x3D; elementData.length;\n        &#x2F;&#x2F; 如果不是空元素的ArrayList集合 或 刚初始化完成的\n        if (oldCapacity &gt; 0 || elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;\n          &#x2F;&#x2F; 计算新容量的大小\n            int newCapacity &#x3D; ArraysSupport.newLength(oldCapacity,\n                    minCapacity - oldCapacity, &#x2F;* minimum growth *&#x2F;\n                    oldCapacity &gt;&gt; 1           &#x2F;* preferred growth *&#x2F;);\n            &#x2F;&#x2F; 复制元素进去，返回的是新的数组，原数组引用丢失，会被之后当垃圾回收掉\n            return elementData &#x3D; Arrays.copyOf(elementData, newCapacity);\n        &#125; else &#123;\n          &#x2F;&#x2F; 代表ArrayList中已经是空的了，此时与默认初始化大小和目前元素个数+1 比较，两个数取大值，创建大值容量的Object数组\n            return elementData &#x3D; new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];\n        &#125;\n    &#125;\n    public static final int SOFT_MAX_ARRAY_LENGTH &#x3D; Integer.MAX_VALUE - 8;\n    &#x2F;&#x2F; 仅仅用来计算数组长度的\n    public static int newLength(int oldLength, int minGrowth, int prefGrowth) &#123;\n        &#x2F;&#x2F; 如果长度超过了Integer.MAX_VALUE，则异常发生OutOfMemoryError\n        &#x2F;&#x2F; 一般情况下选取prefGrowth，而当prefGrowth超过最大值而minGrowth没有超时，选取minGrowth\n        int prefLength &#x3D; oldLength + Math.max(minGrowth, prefGrowth); &#x2F;&#x2F; might overflow\n        if (0 &lt; prefLength &amp;&amp; prefLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;\n            return prefLength;\n        &#125; else &#123;\n            &#x2F;&#x2F; prefLength超了\n            &#x2F;&#x2F; put code cold in a separate method\n            return hugeLength(oldLength, minGrowth);\n        &#125;\n    &#125;\n    &#x2F;&#x2F; 判断oldLength + minGrowth是否超过了SOFT_MAX_ARRAY_LENGTH，如果超了即为负数直接报错，\n    &#x2F;&#x2F; 如果没超过SOFT_MAX_ARRAY_LENGTH，则直接返回SOFT_MAX_ARRAY_LENGTH，否则返回minLength的计算值\n    private static int hugeLength(int oldLength, int minGrowth) &#123;\n        int minLength &#x3D; oldLength + minGrowth;\n        if (minLength &lt; 0) &#123; &#x2F;&#x2F; overflow\n            throw new OutOfMemoryError(\n                &quot;Required array length &quot; + oldLength + &quot; + &quot; + minGrowth + &quot; is too large&quot;);\n        &#125; else if (minLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;\n            return SOFT_MAX_ARRAY_LENGTH;\n        &#125; else &#123;\n            return minLength;\n        &#125;\n    &#125;\n\n\nget\n没啥好分析的。首先判断下标是否合法，合法则直接取值。\n\npublic E get(int index) &#123;\n    &#x2F;&#x2F; 仅仅是检查下标是否越界\n    Objects.checkIndex(index, size);\n    return elementData(index);\n&#125;\nE elementData(int index) &#123;\n    return (E) elementData[index];\n&#125;\n\nset\n检查下标是否合法，取出旧值并返回，新值替换就值。\n\npublic E set(int index, E element) &#123;\n    Objects.checkIndex(index, size);\n    E oldValue &#x3D; elementData(index);\n    elementData[index] &#x3D; element;\n    return oldValue;\n&#125;\n\n\nremove\n指定位置删除十分简单，若是指定对象删除，实现逻辑就是循环遍历元素然后依旧通过fastRemove删除，通过System.arraycopy实现。\n\npublic E remove(int index) &#123;\n    &#x2F;&#x2F; 检查下标是否合法\n    Objects.checkIndex(index, size);\n    final Object[] es &#x3D; elementData;\n    @SuppressWarnings(&quot;unchecked&quot;) \n    E oldValue &#x3D; (E) es[index];\n    fastRemove(es, index);\n    return oldValue;\n&#125;\nprivate void fastRemove(Object[] es, int i) &#123;\n    modCount++;\n    final int newSize;\n    &#x2F;&#x2F; 如果为true，则代表要删除的指定位置并不是最后一个元素，则数组整体往前移一个位置\n    if ((newSize &#x3D; size - 1) &gt; i)\n        System.arraycopy(es, i + 1, es, i, newSize - i);\n    &#x2F;&#x2F; 到这条件为false，或者要删除的指定位置是最后一个元素，直接赋值null即可  \n    es[size &#x3D; newSize] &#x3D; null;\n&#125;\n\nremoveAllpublic boolean removeAll(Collection&lt;?&gt; c) &#123;\n    return batchRemove(c, false, 0, size);\n&#125;\nboolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123;\n    &#x2F;&#x2F; 不为空，否则空指针\n    Objects.requireNonNull(c);\n    final Object[] es &#x3D; elementData;\n    int r;\n    for (r &#x3D; from;; r++) &#123;\n        &#x2F;&#x2F; 若循环到了最后一个，即证明了没有要删除的元素\n        if (r &#x3D;&#x3D; end)\n            return false;\n        &#x2F;&#x2F; 如果包含对应的元素则结束循环，结束循环的位置就是第一个元素出现的下标位置\n        if (c.contains(es[r]) !&#x3D; complement)\n            break;\n    &#125;\n    &#x2F;&#x2F; 第一个元素出现的下标位置记作w，r指向下一个位置\n    int w &#x3D; r++;\n    try &#123;\n        &#x2F;&#x2F; 从下一个位置开始判断，结束条件为末尾\n        for (Object e; r &lt; end; r++)\n            &#x2F;&#x2F; 如果剩下的未遍历的c中的元素中，该元素不是要删除的元素\n            if (c.contains(e &#x3D; es[r]) &#x3D;&#x3D; complement)\n                &#x2F;&#x2F; 则将要删除的元素用不需要删除元素的值顶替\n                es[w++] &#x3D; e;\n    &#125; catch (Throwable ex) &#123;\n        &#x2F;&#x2F; Preserve behavioral compatibility with AbstractCollection,\n        &#x2F;&#x2F; even if c.contains() throws.\n        System.arraycopy(es, r, es, w, end - r);\n        w +&#x3D; end - r;\n        throw ex;\n    &#125; finally &#123;\n        &#x2F;&#x2F; 操作次数记录\n        modCount +&#x3D; end - w;\n        &#x2F;&#x2F; 经过上面操作，到这已经是将要删除的元素剔除完了，但是操作还没结束\n        &#x2F;&#x2F; 比如从12345中剔除24，则到这12345变为了13545，其中最后的45是要删除掉的\n        &#x2F;&#x2F; 则下面方法就是将后面多余元素删除的工作\n        shiftTailOverGap(es, w, end);\n    &#125;\n    return true;\n&#125;\n\nLinkedList定义public class LinkedList&lt;E&gt;\n    extends AbstractSequentialList&lt;E&gt;\n    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable\n\n\n从定义也可以看出来，LinkedList 不仅可以做链表，还可以当作队列使用，以及堆栈，但是如果涉及到堆栈等操作，更合适用的是 ArrayDeque\n\n结构\nLinkedList里面有一内部类Node，从这也可以看出LinkedList是一个双向链表。\n\nprivate static class Node&lt;E&gt; &#123;\n    E item;\n    Node&lt;E&gt; next;  \n    Node&lt;E&gt; prev;\n\n    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;\n        this.item &#x3D; element;\n        this.next &#x3D; next;\n        this.prev &#x3D; prev;\n    &#125;\n&#125;\n\n构造&#x2F;&#x2F; 元素个数\ntransient int size &#x3D; 0;\npublic LinkedList() &#123;\n&#125;\npublic LinkedList(Collection&lt;? extends E&gt; c) &#123;\n    this();\n    addAll(c);\n&#125;\npublic boolean addAll(Collection&lt;? extends E&gt; c) &#123;\n    return addAll(size, c);\n&#125;\npublic boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;\n    &#x2F;&#x2F; 内部实现就是简单的边界检查\n    checkPositionIndex(index);\n    &#x2F;&#x2F; 将参数转为数组，底层实现为Arrays.copyOf\n    Object[] a &#x3D; c.toArray();\n    &#x2F;&#x2F; 元素个数\n    int numNew &#x3D; a.length;\n    if (numNew &#x3D;&#x3D; 0)\n        return false;\n    &#x2F;&#x2F; 记录： pred前一个元素，succ 当前\n    Node&lt;E&gt; pred, succ;\n    &#x2F;&#x2F; 如果相等代表在最后追加\n    if (index &#x3D;&#x3D; size) &#123;\n        &#x2F;&#x2F; 若在最后追加，则last已经指向了最后一个元素，那么pred就应该是待添加元素的前驱节点\n        &#x2F;&#x2F; 即last即为待添加元素的前驱节点，所以pred&#x3D;last且当前节点succ未添加为空\n        succ &#x3D; null;\n        pred &#x3D; last;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这了就表示在链表中间插入新元素\n        &#x2F;&#x2F; 得到后继节点\n        succ &#x3D; node(index);\n        &#x2F;&#x2F; 再由后继节点得到前驱节点。\n        pred &#x3D; succ.prev;\n    &#125;\n    &#x2F;&#x2F; 遍历要插入得元素数组\n    for (Object o : a) &#123;\n        @SuppressWarnings(&quot;unchecked&quot;) \n        E e &#x3D; (E) o;\n        &#x2F;&#x2F; 创建一个待插入节点，此节点已经指向了前驱节点\n        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);\n        &#x2F;&#x2F; 前驱节点为空，即插入节点为头节点。\n        if (pred &#x3D;&#x3D; null)\n            first &#x3D; newNode;\n        else\n            &#x2F;&#x2F; 否则将前驱节点得后指针指向待插入节点\n            pred.next &#x3D; newNode;\n        &#x2F;&#x2F; 元素指针后移，为下次循环做准备\n        pred &#x3D; newNode;\n    &#125;\n    &#x2F;&#x2F; 如果在末尾追加，则succ由上面可知一定是null，且由于上面得for循环已经将pred指向了最后一个元素，则pred即为链表末尾\n    if (succ &#x3D;&#x3D; null) &#123;\n        last &#x3D; pred;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这则不代表在末尾追加，则一定是在头或中间追加，则succ为待插入位置的后面的链表的头引用\n        &#x2F;&#x2F; 此时链表的状态是，待插入位置前面的元素 + 已加入的新元素 。succ指向的待插入位置后面的原来的元素\n        &#x2F;&#x2F; 直接连接（待插入位置前面的元素 + 已加入的新元素）和succ，即完成添加\n        pred.next &#x3D; succ;\n        succ.prev &#x3D; pred;\n    &#125;\n    size +&#x3D; numNew;\n    modCount++;\n    return true;\n&#125;\ntransient Node&lt;E&gt; first;   &#x2F;&#x2F; 全局节点头指针\ntransient Node&lt;E&gt; last;     &#x2F;&#x2F; 尾指针\n&#x2F;&#x2F; 返回指定元素索引处的节点\nNode&lt;E&gt; node(int index) &#123;\n    &#x2F;&#x2F; 如果插入下标为链表元素的左半边\n    if (index &lt; (size &gt;&gt; 1)) &#123;\n        &#x2F;&#x2F; 记录头节点\n        Node&lt;E&gt; x &#x3D; first;\n        &#x2F;&#x2F; 从头遍历，因为是左半边，所以从头遍历比较快\n        &#x2F;&#x2F; 找到要插入位置的左边一个元素并返回\n        for (int i &#x3D; 0; i &lt; index; i++)\n            x &#x3D; x.next;\n        return x;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这表示要插入的元素为链表元素的右半边，所以从尾部往前遍历\n        Node&lt;E&gt; x &#x3D; last;\n        &#x2F;&#x2F; 直到遍历到要插入位置的右边一个位置\n        for (int i &#x3D; size - 1; i &gt; index; i--)\n            x &#x3D; x.prev;\n        return x;\n    &#125;\n    &#x2F;&#x2F; 无论for停留在左边还是右边，返回的都是指定元素索引处的元素\n&#125;\n\n\n由于里面的诸如：addFirst,addLast,removeFirst等一系列方法都是在调用几个共同的方法，只是传入参数不同，则下面只分析几个调用较多的公共方法。\n\nlinkLast\n将e元素添加至末尾。\n\nvoid linkLast(E e) &#123;\n    &#x2F;&#x2F; 保存原来的尾节点\n    final Node&lt;E&gt; l &#x3D; last;\n    &#x2F;&#x2F; 创建要插入的新节点\n    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);\n    &#x2F;&#x2F; 新节点设置为last节点\n    last &#x3D; newNode;\n    &#x2F;&#x2F; 若为真，则代表原来的链表为空\n    if (l &#x3D;&#x3D; null)\n        &#x2F;&#x2F; 则一共就元素，则首尾都是此新元素\n        first &#x3D; newNode;\n    else\n        &#x2F;&#x2F; 尾节点的下一个引用则为新节点\n        l.next &#x3D; newNode;\n    size++;\n    modCount++;\n&#125;\n\n\nlinkBefore\n将一个元素放置在一个元素的前面。\n\nvoid linkBefore(E e, Node&lt;E&gt; succ) &#123;\n    &#x2F;&#x2F;已经确保了succ不为空,在上面node方法中确保的\n    &#x2F;&#x2F;取出指定index索引上的元素的前一个元素引用\n    final Node&lt;E&gt; pred &#x3D; succ.prev;\n    &#x2F;&#x2F;创建新的元素,新元素的前一个元素就是目前指定index上的元素的前一个元素\n    &#x2F;&#x2F;下一个元素是index上面的元素\n    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);\n    &#x2F;&#x2F;将指定索引位置的原元素的前指针指向新元素\n    succ.prev &#x3D; newNode;\n    &#x2F;&#x2F;如果是在头部添加,那么当前元素的前一个元素肯定为空\n    if (pred &#x3D;&#x3D; null)\n    &#x2F;&#x2F;然后新元素就成为了头元素\n        first &#x3D; newNode;\n    else\n    &#x2F;&#x2F;否则就将index-1位置的元素的后指针指向新元素\n        pred.next &#x3D; newNode;\n    size++;\n    modCount++;\n&#125;\nunlink\n将一个非空元素删除，即讲该元素的前后指针和前驱节点和后继节点的指针相连。\n\nE unlink(Node&lt;E&gt; x) &#123;\n    final E element &#x3D; x.item;\n    final Node&lt;E&gt; next &#x3D; x.next;\n    final Node&lt;E&gt; prev &#x3D; x.prev;\n    &#x2F;&#x2F; 无前驱元素，则就是头节点\n    if (prev &#x3D;&#x3D; null) &#123;\n        first &#x3D; next;\n    &#125; else &#123;\n        &#x2F;&#x2F; 否则前驱节点的后指针指向该删除元素的后继节点\n        prev.next &#x3D; next;\n        &#x2F;&#x2F; 断开要删除元素的前指针\n        x.prev &#x3D; null;\n    &#125;\n    &#x2F;&#x2F; 无后继元素，就是末尾节点\n    if (next &#x3D;&#x3D; null) &#123;\n        last &#x3D; prev;\n    &#125; else &#123;\n        &#x2F;&#x2F; 到这就代表不是末尾节点，则该后继节点的前指针指向该删除元素的前驱节点\n        next.prev &#x3D; prev;\n        &#x2F;&#x2F; 断开要删除元素的后指针\n        x.next &#x3D; null;\n    &#125;\n    &#x2F;&#x2F; 赋值为空，方便回收\n    x.item &#x3D; null;\n    size--;\n    modCount++;\n    return element;\n&#125;\n\n\n对于其他的方法，最后归到底基本都是在调用上面几个方法，且逻辑比较简单，就不一一分析了。\n\n","slug":"java/basic/basicjava5","date":"2023-01-27T01:57:16.000Z","categories_index":"java基础","tags_index":"java","author_index":"Qidai"},{"id":"216c1df589f41fe3d75a0e63e395221b","title":"Java复习篇：泛型","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n泛型\n通过使用泛型， 可以最大程度的保证其类型安全。\n加入泛型的代码是更加的灵活的，避免了硬编码。\n由于泛型是运行时被擦除的，所以类泛型不可应用于静态变量方法中。\n\n\n\n\n\n\n\n\n\n\n《写给大忙人看的JAVA核心技术》一书中对于泛型的解释相当详细，值得多次翻阅   @todo \n原理\n编译器在编译期间，会将使用泛型的类直接擦去泛型代码，转换为普通的非泛型代码。比如 MyFactory &lt;T,U&gt; 直接就擦除成了MyFactory，替换为Object类型，由于不知道确切的类型了，则还需要加入强制类型转换。在虚拟机执行的时候是不知道泛型是啥的，只知道这是一个通过强制类型转换达到目的的普通代码。\n\npublic class MyFactory&lt;K extends String, V extends Set&gt;&#123;\n    private K key;\n    private V sets;\n&#125;\n&#x2F;&#x2F; 擦除后\npublic class MyFactory&#123;\n    private String key;\n    private Set sets;\n&#125;\n\n\n使用泛型类\n接口中使用泛型与泛型类中是类似的。\n\npublic class MyFactory &lt;T,U&gt;&#123;\n    public MyFactory() &#123;\n    &#125;\n    public MyFactory(T first, U second) &#123;\n        this.first &#x3D; first;\n        this.second &#x3D; second;\n    &#125;\n    private T first;\n    private U second;\n    public T getFirst() &#123;\n        return first;\n    &#125;\n    public U getSecond() &#123;\n        return second;\n    &#125;\n    public static void main(String[] args) &#123;\n        MyFactory&lt;Integer, String&gt; factory &#x3D; new MyFactory&lt;&gt;(1,&quot;ohbug.cn&quot;);\n        System.out.println(factory.getFirst());\n        System.out.println(factory.getSecond());\n    &#125;\n&#125;\n&#x2F;&#x2F;out\n1\nohbug.cn\n\n泛型方法\n泛型方法不一定非要使用在泛型类中。声明泛型方法的时候，必须在返回值前面加上泛型声明&#x2F;&#x2F; 返回值为T的second方法\npublic static &lt;T,Y&gt; T second(T i, Y j) &#123;&#125;\n&#x2F;&#x2F; 返回值为void的first方法\npublic static &lt;T,Y&gt; void first(T i, Y j) &#123;&#125;\n\n泛型参数限定extends\n&lt;T extends AutoCloseable&gt;上界为AutoCloseable。即传入的参数必须是AutoCloseable以及子类。\n\n&lt;T extends Runnable &amp; AutoCloseable&gt;多重限定，但只可以有一个是类，且如果是类必须放在最前面。\n\nSon[]可直接赋值给Father[]，这称为协变，数组随元素类型变化而变化。但是ArrayList&lt;Son&gt;并不可以赋值给ArrayList&lt;Father&gt;。\n\n&lt;T extends A&gt;和&lt;? extends A&gt;的区别\npublic &lt;T extends String&gt; void  fun1(ArrayList&lt;T&gt; list) &#123;\n    for (T t : list) &#123;\n        System.out.println(t);\n    &#125;\n    T t &#x3D; list.get(1);\n    list.add((T) &quot;fun1&quot;);\n&#125;\npublic void fun2(ArrayList&lt;? extends String&gt; list)&#123;\n    for (String s : list) &#123;\n        System.out.println(s);\n    &#125;\n    String s &#x3D; list.get(1);\n    list.add((String)&quot;fun1&quot;); &#x2F;&#x2F;error\n&#125;\n&#x2F;** 从这也可以看出来，T可以直接当作一个类型在其作用域内使用，返回值更加灵活，且可以对形参进行增删操作\n    而?类型不可以在作用域内使用，返回值更加确定，且不可对形参操作\n    由此可以得出结论：如果不希望形参被修改则需用? 类型，否则T类型更加灵活。\n    *&#x2F;\n\nsuper&#x2F;&#x2F; 任何类型的数组都适用的方法\n    public static  &lt;T&gt; void filter(T[] arrs, Predicate&lt;? super T&gt; test) &#123;\n        for (T arr : arrs) &#123;\n            if (test.test(arr)) &#123;\n                System.out.println(arr);\n            &#125;\n        &#125;\n    &#125;\n    &#x2F;&#x2F;use\n    Integer[] arr &#x3D; &#123;21,52,0,1,63,52,91,2,4,2,3,9,8,1,100,22&#125;;\n    &#x2F;&#x2F; 打印arr中大于10的元素\n    filter(arr,e -&gt; e&gt;10);\n\nPredicate&lt;? super T&gt;，先想象T为一个具体类型Son，他是Father的子类，这里写为了Predicate&lt;T&gt;也是可以运行的，但是方法签名就将实参限制的太死了，若传入是Son数组，则后面只能是Son类型的函数时接口，如果我们需要使用父类的时候，而前面是子类数组，这样就行不通了。所以改为Predicate&lt;? super T&gt;，此时传入子类数组，依旧可以传入父类的判断逻辑。\n\n通配符捕获\n之前提到了T可以作为一个类型来定义变量，而? 是不可以的，如果就是用? 定义该怎么来。\n如下通过添加一个其他的泛型方法，其他的泛型方法中的T就会捕获?的真是类型，从而可以使用T进行定义变量。\n\npublic static void get(List&lt;? extends Father&gt; list, int i) &#123;\n    &#x2F;&#x2F;error\n    &#x2F;&#x2F; ? f &#x3D; list.get(0);\n    Father father &#x3D; swap(list, i);\n    System.out.println(father);\n&#125;\nprivate static &lt;T&gt; T swap(List&lt;T&gt; list, int i) &#123;\n    T e &#x3D; list.get(i);\n    return e;\n&#125;\npublic static void main(String[] args) &#123;\n    List&lt;Father&gt; fathers &#x3D; Arrays.asList(new Father(&quot;Qidai&quot;));\n    get(fathers, 0);\n&#125;\n&#x2F;&#x2F; out Father&#123;name&#x3D;&#39;Qidai&#39;&#125;","slug":"java/basic/basicjava4","date":"2023-01-17T01:58:04.000Z","categories_index":"java基础","tags_index":"java,todo","author_index":"Qidai"},{"id":"8d49f1dff289c8a88e72afa0d38a120a","title":"MySQL必知必会 {一}","content":"\n\n\n\n\n\n\n\n\n所有操作的数据源来自《MySQL必知必会》，使用MySQL 8.0 进行学习\n\n\nMySQL 可以分为 Server 层和存储引擎层两部分\nServer 层包括连接器、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。\n存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。\n\n\n\nSelect过程\n连接器：如果用户名密码认证通过，连接器会得到相对应登入用户的该有权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。\n分析器：MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。\n优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。以达到最高的执行效率。\n执行器：负责SQL的执行。\n\nUpdate过程\n大致与SELECT的过程是一样的，中间不一样的涉及到了两个重要的日志模块，redo log（重做日志）和 binlog（归档日志）。\n\nredo Log （InnoDB特有）\n在 MySQL里若每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了先写入日志文件后将日志中的条目总和一并写入磁盘中的思路来提升更新效率。\n先写日志再写磁盘的就是MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging。比如当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。若更新相当频繁以至于redo log写满了，则需要先暂停更新操作，将一部分redo log写入磁盘以腾出新空间来供新的更新操作记录。\nInnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，类似一个循环队列。\n有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。\n\nbin log\n处理InnoDB特有的，Server层自己的日志叫做 bin log。bin log日志只能用于归档。\n\nredo log与bin log 区别\nredo log 是物理日志，记录的是“在某个数据页上做了什么修改”；bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。\nredo log 是循环写的，空间固定会用完；bin log 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。\n\nupdate内部流程\n先找主键，id是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。\n执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。\n引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。\n执行器生成这个操作的 binlog，并把 binlog 写入磁盘。\n执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。\n\nredo log两段提交\nredo log 和 bin log 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。\n\n\n不采用两段式提交的结果\n由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。\n仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？\n先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。\n\n\n\n\n\n\n\n\n\n\nredo log 用于保证 crash-safe 能力。innodb_flush_log_at_trx_commit 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。sync_binlog 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。\n\nshow columns from customers; 快捷语句 ：describe customers;。\n查看表的创建语句 show create tables customers;。\n\nSELECT\n去重：select distinct vend_id from products;，distinct应用于所有列，即把要查询字段当作一个整体去重。\n限制：select * from customers limit 5; 零到五行，limit 3,5，从第3个往后5个。\n排序：select prod_name from products order by prod_price ;，order by后可以是显示列也可以是其他列，也可以是按照多个列排序。DESC降序，默 认为升序ASC。 order by 应位于where之后。\nwhere：与串对比时需要加单引号。\n比较运算符：&gt;， &lt;，= ，is null …\n逻辑运算符：and ，or ,and 优先级高于 or。in是一个范围，in一般比or执行快。not可对in，exists，between取反。\nlike：%任意字符任意次数，搜索区分大小写，%不可匹配null。_单个字符。\n\n\n\n函数\n\n\n\n\n\n\n\n\nhttps://www.runoob.com/mysql/mysql-functions.html\n\navg 自动忽略null。\ncount(*)不忽略null，count(column)忽略null。\n\nGroup by\n可以包含任意多的列名，数据将在最后的列上进行分组汇总。\nGroup by中出现的列必须是检索列，Select中除聚集计算外，每个列必须在group by中给出。\nnull值作为单独一个分组返回。\n必须位于where之后。 order by之前。\nwith rollup，得到每个分组的汇总信息。\n\nmysql&gt; select vend_id,count(*) as num_prods from products group by vend_id with rollup;\n+---------+-----------+\n| vend_id | num_prods |\n+---------+-----------+\n|    1001 |         3 |\n|    1002 |         2 |\n|    1003 |         7 |\n|    1005 |         2 |\n|    NULL |        14 |\n+---------+-----------+\n5 rows in set (0.29 sec)\n\nmysql&gt; select vend_id,count(*) as num_prods from products group by vend_id;\n+---------+-----------+\n| vend_id | num_prods |\n+---------+-----------+\n|    1001 |         3 |\n|    1002 |         2 |\n|    1003 |         7 |\n|    1005 |         2 |\n+---------+-----------+\n4 rows in set (0.00 sec)\n\nhaving\nwhere针对行过滤，having针对分组过滤。WHERE 在数据分组前进行过滤， HAVING在数据分组后进行过滤。\n子查询：列必须匹配在WHERE子句中使用子查询， 应该保证SELECT语句具有与WHERE子句中相同数目的列。 通常子查询将返回单个列并且与单个列匹配， 但如果需要也可以使用多个列。\n\nUNION\nUNION 中的每个查询必须包含相同的列、 表达式或聚集函数（不过各个列不需要以相同的次序列出） 。\nUNION 从查询结果集中自动去除了重复的行，如果想返回所有匹配行， 可使用UNION ALL。\n在用UNION 组合查询时， 只能使用一条ORDER BY 子句， 它必须出现在最后一条SELECT 语句之后。\n\n视图 CREATE VIEW productcustomers AS SQL\n\n视图是虚拟的表。 与包含数据的表不一样， 视图只包含使用时动态检索数据的查询。视图本身不包含数据， 因此它们返回的数据是从其他表中检索出来的。\n在添加或更改这些表中的数据时， 视图将返回改变过的数据。\n视图可以嵌套， 即可以利用从其他视图中检索数据的查询来构造一个视图。\n视图不能索引， 也不能有关联的触发器或默认值。\n视图可以和表一起使用。 例如， 编写一条联结表和视图的SELECT 语句。\n\n存储过程\n\n\n\n\n\n\n\n\nhttps://www.yiibai.com/mysql/stored-procedure.html#article-starthttps://blog.csdn.net/whf_a/article/details/114871866SQLSTATE状态码：https://blog.csdn.net/cao478208248/article/details/27647419\n\n简单、 安全、 高性能，因为存储过程得创建是编译后再存储的，所以使用存储过程比使用单独的SQL语句要快。\n\n-- 声明变量的语法\nDECLARE variable_name datatype(size) DEFAULT default_value;\n-- 设置变量值\nSET total_count &#x3D; 10;\n-- 也可以用into方式设置变量值\nSELECT COUNT(*) INTO total_products FROM products\n\n\n\n\n-- 模板，当使用图形化界面时，可省略DELIMITER\nDELIMITER &#x2F;&#x2F;\n CREATE PROCEDURE GetAllProducts()\n   BEGIN\n   SELECT *  FROM products;\n   END &#x2F;&#x2F;\nDELIMITER ;\n\n\nDELIMITER \\\\语句将标准分隔符 ;更改为：//。BEGIN 和END之间的部分称为存储过程的主体。\n\nMySQL游标只能用于存储过程（和函数） \n触发器\n创建触发器需要四条信息：触发器名；触发器关联的表；触发器应该响应的活动（DELETE 、 INSERT 或UPDATE ） ；触发器何时执行（处理之前或之后） 。\n触发器名称应遵循命名约定[trigger time]_[table name]_[trigger event]，例如before_employees_update.\n只有表才支持触发器， 视图不支持，每个表每个事件每次只允许一个触发器。单一触发器不能与多个事件或多个表关联。\n如果before触发器执行失败，sql也会执行失败，sql在执行失败时，after型触发器不会执行，如果after触发器执行失败，sql会回滚。\n\nCREATE TRIGGER trigger_name trigger_time trigger_event\n ON table_name\n FOR EACH ROW\n BEGIN\n ...\n END;\n\nINSERT\n在INSERT 触发器代码内， 可引用一个名为 NEW 的虚拟表， 访问被插入的行；\n在BEFORE INSERT 触发器中， NEW 中的值也可以被更新（允许更改被插入的值） ；\n对于AUTO_INCREMENT 列， NEW 在INSERT 执行之前包含0 ， 在INSERT 执行之后包含新的自动生成值。\n实例：从下面可以看到可以从 new 虚拟表中获得自增后的最新值。且注意在MySQL8中，触发器不再支持由SELECT方式的返回值，只能将结果放入一个变量中带回。\n\nmysql&gt; desc orders;\n+------------+----------+------+-----+---------+----------------+\n| Field      | Type     | Null | Key | Default | Extra          |\n+------------+----------+------+-----+---------+----------------+\n| order_num  | int      | NO   | PRI | NULL    | auto_increment |\n| order_date | datetime | NO   |     | NULL    |                |\n| cust_id    | int      | NO   | MUL | NULL    |                |\n+------------+----------+------+-----+---------+----------------+\n3 rows in set (0.00 sec)\nmysql&gt; select * from orders;\n+-----------+---------------------+---------+\n| order_num | order_date          | cust_id |\n+-----------+---------------------+---------+\n|     20005 | 2005-09-01 00:00:00 |   10001 |\n|     20006 | 2005-09-12 00:00:00 |   10003 |\n|     20007 | 2005-09-30 00:00:00 |   10004 |\n|     20008 | 2005-10-03 00:00:00 |   10005 |\n|     20009 | 2005-10-08 00:00:00 |   10001 |\n|     20011 | 2006-02-23 00:00:00 |   10001 |\n|     20012 | 2006-02-23 00:00:00 |   10001 |\n+-----------+---------------------+---------+\n7 rows in set (0.00 sec)\nmysql&gt; create trigger after_insert_orders after insert on orders for each row select new.order_num into @a;\nQuery OK, 0 rows affected (1.64 sec)\n\nmysql&gt; select @a;\n+------------+\n| @a         |\n+------------+\n| NULL       |\n+------------+\n1 row in set (0.00 sec)\nmysql&gt; insert into orders(order_Date,cust_id) values(&#39;2006-05-23 00:00:00&#39;,10001);\nQuery OK, 1 row affected (0.05 sec)\n\nmysql&gt; select @a;\n+-------+\n| @a    |\n+-------+\n| 20013 |\n+-------+\n1 row in set (0.00 sec)\n\nDELETE\n在DELETE 触发器代码内， 你可以引用一个名为 OLD 的虚拟表， 访问被删除的行；OLD 中的值全都是只读的， 不能更新。\n\n-- 从info中删除的信息插入info_copy表中。\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  1 | Ricky Simmons |  867 |\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n5 rows in set (0.00 sec)\n\nmysql&gt; select * from info_copy;\nEmpty set (0.00 sec)\n\nmysql&gt; create trigger before_delete_info before delete on info for each row insert into info_copy(no,name,age) values (old.no,old.name,old.age);\nQuery OK, 0 rows affected (0.11 sec)\n\nmysql&gt; delete from info where no&#x3D;1;\nQuery OK, 1 row affected (0.03 sec)\n\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n4 rows in set (0.00 sec)\n\nmysql&gt; select * from info_copy;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  1 | Ricky Simmons |  867 |\n+----+---------------+------+\n1 row in set (0.00 sec)\n\nUPDATE\n在UPDATE 触发器代码中， 你可以引用一个名为OLD 的虚拟表访问以前（UPDATE 语句前） 的值， 引用一个名为NEW 的虚拟表访问新更新的值；\n在BEFORE UPDATE 触发器中， NEW 中的值可能也被更新（允许更改将要用于UPDATE 语句中的值） ；\nOLD 中的值全都是只读的， 不能更新。\n\n-- 在更新的时候，将指定no的一行信息的名字改为 Qidai。\nmysql&gt; select * from info;\n+----+---------------+------+\n| no | name          | age  |\n+----+---------------+------+\n|  2 | Murakami Rena |   82 |\n|  3 | Ueda Kenta    |  950 |\n|  4 | Ikeda Akina   |  681 |\n|  5 | Fan Yunxi     |  583 |\n+----+---------------+------+\n4 rows in set (0.00 sec)\n\nmysql&gt; update info set age&#x3D;11 where no&#x3D;2;\nQuery OK, 1 row affected (0.09 sec)\nRows matched: 1  Changed: 1  Warnings: 0\n\nmysql&gt; select * from info;\n+----+-------------+------+\n| no | name        | age  |\n+----+-------------+------+\n|  2 | Qidai       |   11 |\n|  3 | Ueda Kenta  |  950 |\n|  4 | Ikeda Akina |  681 |\n|  5 | Fan Yunxi   |  583 |\n+----+-------------+------+\n4 rows in set (0.00 sec)\n\n事务\n开始一个事务：START TRANSACTION;。\n回滚一个事务：ROLLBACK。\n设置保存点：SAVEPOINT delete1;。\n混滚至具体的保存点：ROLLBACK TO delete1;。\n设置不自动提交：SET autocommit=0;。\n事务处理用来管理 INSERT 、 UPDATE 和 DELETE 语句。\n保留点在事务处理完成（执行一条 ROLLBACK 或 COMMIT ） 后自动释放 ，也可以用RELEASE SAVEPOINT 明确地释放保留点。\nautocommit 标志是针对每个连接而不是服务器的。\n\n","slug":"mysql/mysqlmustknow","date":"2023-01-16T13:08:37.000Z","categories_index":"MySQL基础","tags_index":"MySQL,《MySQL必知必会》","author_index":"Qidai"},{"id":"451e8b3038f6c87fffb50c6a654b133c","title":"Spring6-注入方式","content":"\n\n\n\n\n\n内容来源\n基于Oracle openJDK 17 ， Spring6\n\n\n\n\n\n\n\n\n\n\n个人学习习惯，视频入门，书本精进。内容来自于视频讲解内容以及个人总结理解。\nOCP开闭原则\n在使用Spring中，Service层可能由如下实现，这样就规定死了userDao的真实类型的UserDaoMysqlImpl，在之后的系统升级维护中，若更改为其他的数据库，则必须手动更改Imple实现类。那么这样就会造成对项目源码的更改，这样的违背OCP开闭原则的。这个原则意思是对扩展开放，对修改关闭，即在维护升级中可以新建类等操作，但是不允许进行修改源代码。\n下面的代码也使得Service层的实现完全依赖与底层Impl的实现。这样的更改下层而牵动上层的设计，违背了DIP依赖倒置原则。\n\nUserDao  userDao &#x3D; new UserDaoMysqlImple();\n\nDIP依赖倒置\nDIP主要倡导面向抽象编程，面向接口编程，不要面向具体编程，让上层不再依赖下层，下面改动了，上面的代码不会受到牵连，目的是解耦，增加内聚。\n上面的代码段是面向具体编程了，在代码编写的时候就直接规定死了UserDao的实现类，Spring中的IoC就是来解决这个问题的。\n\n&#x2F;*与上面代码不同的是，这段代码若结合Spring使用，userDao的对象完全由Spring来注入，userDao的实现完全由配置决定，\n则面向接口编程意思就是我们只需要关注接口中的方法即可，而无需考虑实现类的具体实现。*&#x2F;\nUserDao  userDao;\npublic User findById(id) &#123;\n  return userDao.findById(Id);\n&#125;\n\n\n\n两个问题\n不让面向具体编程，不让自己new对象出来，那么怎么创建对象？\nSpring通过创建Bean的方式，通过用户配置，来创建需要的对象Bean。通过这样的方式，若以后项目升级维护，更改操作，则通过更改配置文件即可，而不用更改源码，解决掉了之前的OCP问题。\n\n\n当类初始化后，不让new对象赋值，则userDao对象被使用会发生空指针怎么办？\n同样是交由Spring进行管理，一样是通过配置文件的方法告诉Spring，userDao该如何赋值。这样通过面向接口编程，则有效解决了DIP问题。\n\n\n\n控制反转IoC\n这是上面的总结下来的思想，之前我们的对象都是主动在程序中new创建出来的，而现在我们反过来，将对象的创建和对象间的管理权限全部交由Spring来管理维护，再由Spring将对象注入到配置好的位置。这样反过来的操作可以理解为IoC。\nIoC算是一种思想方法，而在Spring的实现中是通过配置好后，Spring进行依赖注入，依赖注入又称DI，DI的实现方式主要有\n构造注入\nsetter注入\n\n\n结合之前学习的Java基础，则两种注入方法存在本质的不同，构造方法是在对象初始化，当对象的变量都分配好空间和默认值之后，构造方法开始对变量的内容进行初始化。而setter注入是在初始化完毕后，对象已经创建完毕后，setter注入才可以开始工作，两种方式初始化的时机是不一样的。\n\n\npom.xml\n&lt;dependencies&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;spring-context&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;6.0.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.junit.jupiter&lt;&#x2F;groupId&gt;\n        &lt;artifactId&gt;junit-jupiter&lt;&#x2F;artifactId&gt;\n        &lt;version&gt;5.6.3&lt;&#x2F;version&gt;\n    &lt;&#x2F;dependency&gt;\n&lt;&#x2F;dependencies&gt;\n\n\ngetBean\n当在配置文件中配置了之后，可以通过三种方式得到SPring为我们初始化好的Bean\n\n&lt;!-- getBean时会返回userDao，而不会返回另一个。 --&gt;\n&lt;bean id&#x3D;&quot;userDao&quot; class&#x3D;&quot;cn.ohbug.UserDao&quot; primary&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;userDao1&quot; class&#x3D;&quot;cn.ohbug.UserDao&quot;&#x2F;&gt;\n\n\nUserDao bean &#x3D; context.getBean(UserDao.class);\nUserDao bean &#x3D; (UserDao) context.getBean(&quot;userDap&quot;);\nUserDao bean &#x3D; context.getBean(&quot;userDao&quot;, UserDao.class);\n\n\n若配置文件中有重复的Bean配置，则使用第一种getBean的方式要报错，要在配置文件中配置重复Bean的主次即可。\n\n若 UserDao为一个接口，配置文件中有，这样的情况会怎么样？当仅有一个实现类Bean时，默认会取出来加以执行，若有两个及以上实现类，则依旧采用primary 配置主次即可。\n\n\n&lt;bean id&#x3D;&quot;manDao&quot; class&#x3D;&quot;cn.ohbug.ManDao&quot; primary&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;womanDao&quot; class&#x3D;&quot;cn.ohbug.WomanDao&quot; &#x2F;&gt;\n\n\n\npublic interface UserDao &#123;\n    public void say() ;\n&#125;\npublic class ManDao implements UserDao&#123;\n    @Override\n    public void say() &#123;\n        System.out.println(&quot;i&#39;m a man&quot;);\n    &#125;\n&#125;\npublic class WomanDao implements UserDao&#123;\n    @Override\n    public void say() &#123;\n        System.out.println(&quot;i&#39;m a woman&quot;);\n    &#125;\n&#125;\n\n案例程序：setter注入&#x2F;&#x2F;Java程序\npublic class User &#123;\n    public User(String name, int id) &#123;\n        this.name &#x3D; name;\n        this.id &#x3D; id;\n        System.out.println(&quot;User(name,id) constructor init...&quot;);\n    &#125;\n    public User() &#123;\n        System.out.println(&quot;User() constructor init...&quot;);\n    &#125;\n    @Override\n    public String toString() &#123;\n        return &quot;User&#123;&quot; +\n                &quot;name&#x3D;&#39;&quot; + name + &#39;\\&#39;&#39; +\n                &quot;, id&#x3D;&quot; + id +\n                &#39;&#125;&#39;;\n    &#125;\n    private String name;\n    private int id;\n&#125;\n\npublic class UserService &#123;\n    public UserService() &#123;\n        System.out.println(&quot;UserService() constructor init...&quot;);\n    &#125;\n    private UserDao userDao;\n    public void setUserDao(UserDao userDao) &#123;\n        this.userDao &#x3D; userDao;\n    &#125;\n    public User getUserById(int i) &#123;\n        return userDao.getUserById(i);\n    &#125;\n&#125;\npublic class UserDao &#123;\n    public UserDao() &#123;\n        System.out.println(&quot;UserDao() constructor init...&quot;);\n    &#125;\n    public User getUserById(int i) &#123;\n        return new User(&quot;Qidai&quot;,i);\n    &#125;\n&#125;\n&#x2F;&#x2F;use\n@Test\npublic void test() &#123;\n    ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);\n    UserService service &#x3D; context.getBean(&quot;userService&quot;, UserService.class);\n    User user &#x3D; service.getUserById(1);\n    System.out.println(user);\n\n&#125;\n&#x2F;&#x2F;out\nUserDao() constructor init...\nUserService() constructor init...\nUser(name,id) constructor init...\nUser&#123;name&#x3D;&#39;Qidai&#39;, id&#x3D;1&#125;\n\n\n下面是Spring配置文件\n\n&lt;bean id&#x3D;&quot;dao&quot; class&#x3D;&quot;cn.ohbug.UserDao&quot; primary&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;userService&quot; class&#x3D;&quot;cn.ohbug.UserService&quot;&gt;\n    &lt;property name&#x3D;&quot;userDao&quot; ref&#x3D;&quot;dao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n配置文件的解释\nspring-config.xml为Spring全局配置文件，放置于项目根目录下。配置文件中&lt;bean id=&quot;userDao&quot; class=&quot;org.example.UserDao&quot;/&gt;就是告诉Spring要new一个这个对象，交由Spring管理，id在xml中唯一，class是对应的类路径。\n第二个bean作用与上面userDao的配置一样，但是里面的property是告诉Spring，要使用setter方式将ref引用的id为dao的创建好的bean通过UserService类中叫做setUserDao的方法注入到UserService中的实例未赋值的变量userDao中。即若使用setter方法注入，我们就必须为成员变量设置一个set方法，property中的name是这个方法名去掉set后首字母小写值，假如一个方法名为setQidai，若要使用name，则那么name值为qidai，就是这样一种约定，如上java代码中，UserService中有一个setUserDao方法，则此处的name就为userDao，ref就是寻找xml中id为dao的bean，然后通过编写的setter方法进行赋值。\n\n\n\n\n\n看到输出，那么究竟发生了什么？\n当测试程序运行了    ApplicationContext context = new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);则Spring就已经将UserDao和UserService初始化，并输出了初始化信息，此时我们知道了Spring bean的创建是通过无参构造进行的。若Bean中没有无参构造则报错。原理是利用了反射。\n创建好的对象交由Spring管理，Spring放入了一个Map中进行存储，当使用context.getBean(…)时，参数其实是Map中的key。\n\n\n\n构造器注入public class ManDao &#123;\n    public void say() &#123;\n        System.out.println(&quot;i&#39;m a man&quot;);\n    &#125;\n&#125;\npublic class WomanDao&#123;\n    public void say() &#123;\n        System.out.println(&quot;i&#39;m a woman&quot;);\n    &#125;\n&#125;\npublic class PersonService &#123;\n    private ManDao manDao;\n    private WomanDao womanDao;\n\n    public PersonService(ManDao manDao, WomanDao womanDao) &#123;\n        this.manDao &#x3D; manDao;\n        this.womanDao &#x3D; womanDao;\n    &#125;\n\n    public void say() &#123;\n        manDao.say();\n        womanDao.say();\n    &#125;\n&#125;\n    @Test\n    public void test() &#123;\n        ApplicationContext context &#x3D; new ClassPathXmlApplicationContext(&quot;spring-config.xml&quot;);\n        PersonService bean &#x3D; context.getBean(PersonService.class);\n        bean.say();\n    &#125;\n\n\n\n&lt;bean id&#x3D;&quot;manDao&quot; class&#x3D;&quot;cn.ohbug.ManDao&quot; primary&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;womanDao&quot; class&#x3D;&quot;cn.ohbug.WomanDao&quot; &#x2F;&gt;\n&lt;bean class&#x3D;&quot;cn.ohbug.PersonService&quot; id&#x3D;&quot;personService&quot;&gt;\n    &lt;constructor-arg name&#x3D;&quot;manDao&quot; ref&#x3D;&quot;manDao&quot;&#x2F;&gt;\n    &lt;constructor-arg name&#x3D;&quot;womanDao&quot; ref&#x3D;&quot;womanDao&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\nname 指定 PersonService 中待注入的变量名，ref 为 配置文件中配置好的bean的id。\n\nset注入简单类型\nBeanUtils.isSimpleValueType 方法可以知道，简单类型包括：基本数据类型及包装类，枚举类，字符串，数字，时间，URI，Class 类型。\n\n&#x2F;&#x2F; 引入lombok插件\n@Data\n@ToString\npublic class User &#123;\n    private String name;\n    private int age;\n    private Class aClass;\n&#125;\n\n\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;24&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;AClass&quot; value&#x3D;&quot;cn.ohbug.User&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n级联注入\n即一个对象内的引用对象的内容注入。需要注意的是外部对象User需要提供内部引用对象Info的getter方法。在执行的时候，会调用User.getInfo 方法后赋值。\n\n@Data\n@ToString\npublic class User &#123;\n    private String name;\n    private int age;\n    private Info info;\n&#125;\n@Data\npublic class Info &#123;\n    private String phone;\n    private String address;\n&#125;\n\n\n&lt;bean id&#x3D;&quot;infoBean&quot; class&#x3D;&quot;cn.ohbug.Info&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;age&quot; value&#x3D;&quot;24&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;info&quot; ref&#x3D;&quot;infoBean&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;info.address&quot; value&#x3D;&quot;tangshan&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;info.phone&quot; value&#x3D;&quot;18888888888&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n数组注入简单类型@Data\n@ToString\npublic class User &#123;\n    private String[] names;\n&#125;\n\n\n\n&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;names&quot;&gt;\n        &lt;array&gt;\n            &lt;value&gt;qidai&lt;&#x2F;value&gt;\n            &lt;value&gt;ohbug.cn&lt;&#x2F;value&gt;\n        &lt;&#x2F;array&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n引用类型@Data\npublic class Company &#123;\n    private User[] users;\n&#125;\n@Data\n@ToString\npublic class User &#123;\n    private String name;\n&#125;\n\n\n&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ohbug.cn&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot;&gt;\n    &lt;property name&#x3D;&quot;users&quot;&gt;\n        &lt;array&gt;\n            &lt;ref bean&#x3D;&quot;user1&quot;&#x2F;&gt;\n            &lt;ref bean&#x3D;&quot;user2&quot;&#x2F;&gt;\n        &lt;&#x2F;array&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\nList\n注入List集合的时候使用list标签，如果List集合中是简单类型使用value标签，反之使用ref标签。\n\n@Data\n@ToString\npublic class Company &#123;\n    private List&lt;User&gt;[] users;\n&#125;\n@Data\n@ToString\npublic class User &#123;\n    private String name;\n&#125;\n\n\n&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ohbug.cn&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot;&gt;\n    &lt;property name&#x3D;&quot;users&quot;&gt;\n        &lt;list&gt;\n            &lt;ref bean&#x3D;&quot;user1&quot;&#x2F;&gt;\n            &lt;ref bean&#x3D;&quot;user2&quot;&#x2F;&gt;\n        &lt;&#x2F;list&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\nSet\n与List注入一样。\n\nMap\n如果key是简单类型，使用key属性，反之使用 key-ref 属性，如果value是简单类型，使用 value 属性，反之使用 value-ref 属性。\n\n\n@Data\n@ToString\npublic class Company &#123;\n    private Map&lt;Integer, User&gt; user;\n&#125;\n&#x2F;&#x2F; User同List一样\n\n\n&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;ohbug.cn&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot;&gt;\n    &lt;property name&#x3D;&quot;user&quot;&gt;\n        &lt;map&gt;\n            &lt;entry key&#x3D;&quot;1&quot; value-ref&#x3D;&quot;user1&quot;&#x2F;&gt;\n            &lt;entry key&#x3D;&quot;2&quot; value-ref&#x3D;&quot;user2&quot;&#x2F;&gt;\n        &lt;&#x2F;map&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\n\nProperties\n一样是Map结构，但是标签使用的是props嵌套prop实现。@Data\n@ToString\npublic class Company &#123;\n    private Properties properties;\n&#125;\n\n\n\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot;&gt;\n    &lt;property name&#x3D;&quot;properties&quot;&gt;\n        &lt;props&gt;\n            &lt;prop key&#x3D;&quot;cname&quot;&gt; ohbug.cn&lt;&#x2F;prop&gt;\n            &lt;prop key&#x3D;&quot;owner&quot;&gt; qidai &lt;&#x2F;prop&gt;\n        &lt;&#x2F;props&gt;\n    &lt;&#x2F;property&gt;\n&lt;&#x2F;bean&gt;\n\n\n\n\n\n命名空间注入\n是为了简化配置的。\n\nC命名空间\n将bean配置文件的文件头更改，主要用于构造注入.\n\n@ToString\n@AllArgsConstructor\n@NoArgsConstructor\npublic class Company &#123;\n    private String companyName;\n    private User owner;\n&#125;\n\n\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:c&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;c&quot;  &lt;!--  新加入的 --&gt;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot; c:companyName&#x3D;&quot;ohbug.cn&quot; c:owner-ref&#x3D;&quot;user1&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n\nP命名空间\n将bean配置文件的文件头更改，主要用于简化变量注入.@Data\n@ToString\npublic class Company &#123;\n    private String companyName;\n    private User owner;\n&#125;\n    @Data\n    @ToString\n    public class User &#123;\n        private String name;\n    &#125;\n\n\n\n&lt;?xml version&#x3D;&quot;1.0&quot; encoding&#x3D;&quot;UTF-8&quot;?&gt;\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot; &lt;!--  新加入的 --&gt;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd&quot;&gt;\n    &lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot;&gt;\n        &lt;property name&#x3D;&quot;name&quot; value&#x3D;&quot;qidai&quot;&#x2F;&gt;\n    &lt;&#x2F;bean&gt;\n    &lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot; p:companyName&#x3D;&quot;ohbug.cn&quot; p:owner-ref&#x3D;&quot;user1&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\nutil配置复用\n若配置文件中反复使用一个配置,则可以将这个配置信息提出来,用util的办法加以复用.\n如下将两个UserBean打包成一个方便Company中ref使用.\n@Data\npublic class User &#123;\n    private String name;\n&#125;\n@Data\npublic class Company &#123;\n    private String companyName;\n    private List&lt;User&gt; users;\n&#125;\n\n\n\n&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;zhangsan&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;lisi&quot;&#x2F;&gt;\n&lt;util:list id&#x3D;&quot;users&quot; value-type&#x3D;&quot;cn.ohbug.User&quot;&gt;\n    &lt;ref bean&#x3D;&quot;user1&quot;&#x2F;&gt;\n    &lt;ref bean&#x3D;&quot;user2&quot;&#x2F;&gt;\n&lt;&#x2F;util:list&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot;&gt;\n    &lt;property name&#x3D;&quot;companyName&quot; value&#x3D;&quot;xxx&quot;&#x2F;&gt;\n    &lt;property name&#x3D;&quot;users&quot; ref&#x3D;&quot;users&quot;&#x2F;&gt;\n&lt;&#x2F;bean&gt;\n\n\n自动注入\n无论是根据名字还是根据类型,都是调用的set方法注入的.\n\n按其名字@Data\npublic class User &#123;\n    private String name;\n&#125;\n@Data\npublic class Company &#123;\n    private String companyName;\n    private User user;\n&#125;\n\n\n\nautowire=&quot;byName&quot;说明按名字注入,因为Company中有一个user变量,其set方法名为setUser(..),去掉set字样后小写开头为user,即为配置的UserBean的id,自动注入时,Spring会找id为user的Bean进行自动注入. 这是一种约定.&lt;bean id&#x3D;&quot;user&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;Qidai&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot; p:companyName&#x3D;&quot;ohbug.cn&quot; autowire&#x3D;&quot;byName&quot;&#x2F;&gt;\n\n按其类型&#x2F;&#x2F; 与上一样\n\n\n\n当出现相同类型的多个Bean时,同样更可以通过 primary 来指定主要Bean对象.&lt;bean id&#x3D;&quot;user1&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;Qidai&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;user2&quot; class&#x3D;&quot;cn.ohbug.User&quot; p:name&#x3D;&quot;Qidaix&quot; primary&#x3D;&quot;true&quot;&#x2F;&gt;\n&lt;bean id&#x3D;&quot;company&quot; class&#x3D;&quot;cn.ohbug.Company&quot; p:companyName&#x3D;&quot;ohbug.cn&quot; autowire&#x3D;&quot;byType&quot;&#x2F;&gt;\n\n加载外部配置文件@Data\npublic class DataSource &#123;\n    private String name;\n    private String passwd;\n&#125;\n\n\n\n\n\n测试的properties文件内容如下\n\njdbc.name&#x3D;Qidai\njdbc.passwd&#x3D;123456\n\n\nspring 配置中 加入了 context的配置和语法约束. 并用context标签来引入外部文件.\n\n&lt;beans xmlns&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&quot;\n       xmlns:p&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;p&quot;\n       xmlns:util&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&quot;\n       xmlns:context&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&quot;   &lt;!-- 新加入 --&gt;\n       xmlns:xsi&#x3D;&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2001&#x2F;XMLSchema-instance&quot;\n       xsi:schemaLocation&#x3D;&quot;http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;beans&#x2F;spring-beans.xsd\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;util&#x2F;spring-util.xsd\n                           &lt;!-- 新加入--&gt;\n                           http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context http:&#x2F;&#x2F;www.springframework.org&#x2F;schema&#x2F;context&#x2F;spring-context.xsd&quot;&gt; \n    &lt;context:property-placeholder location&#x3D;&quot;dataSource.properties&quot;&#x2F;&gt;\n    &lt;bean id&#x3D;&quot;dataSource&quot; class&#x3D;&quot;cn.ohbug.DataSource&quot; p:name&#x3D;&quot;$&#123;jdbc.name&#125;&quot; p:passwd&#x3D;&quot;$&#123;jdbc.passwd&#125;&quot;&#x2F;&gt;\n&lt;&#x2F;beans&gt;\n\n\n\n\n\n\n\n\n\n","slug":"spring/spring6-1","date":"2023-01-12T00:51:17.000Z","categories_index":"Spring6","tags_index":"Spring6","author_index":"Qidai"},{"id":"a24485c2a08f5a5922225dff3c3d2ee2","title":"Java复习篇：继承，接口","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n继承\n子类不可访问父类的私有属性和方法。\nsuper只是一个关键字，用来指定访问父类的方法和变量以及构造方法，而this是实实在在的对象。\n当一个类继承的父类和实现的接口中有同名方法，则类优先。\n子类重写了父类的方法时，子类的返回值是可更改的。\n多态会确定对象的真实类型进行方法调用。这样写法的弊端是只能调用Father中的方法，如果要调用子类方法，则可以使用instanceof判断，将父类转为子类使用。\n\n  Son son &#x3D; new Son();\nFather father &#x3D; son;\nfather.getMoneny();  &#x2F;&#x2F; 子类的重写将被执行\nif(father instanceof Son) &#123;\n  Son son1 &#x3D; (Son)father;\n  son1.sonMethod();\n&#125;\n构造器\n子类初始化，默认调用父类无参构造器，若父类中没有，子类必须在自己的构造器中调用super(params)进行初始化，否则编译出错。\n\n  public class Father &#123;\n  public Father() &#123;\n    test();\n  &#125;\n  public void test() &#123;\n  &#125;\n&#125;\nclass Son extends Father &#123;\n  private int a &#x3D; 123;\n  public Son() &#123;&#125;\n  @Override\n  public void test() &#123;\n    System.out.println(a);\n  &#125;\n&#125;\n&#x2F;&#x2F; 使用\nSon son &#x3D; new Son();\nson.test();\n&#x2F;&#x2F; out  0   123 \n\nSon初始化的时候调用父类构造器，父类构造器内调用tes()方法，但是此时Son内的a变量并没被赋值，此时Son继承Father，且实际的类型为Son，则调用重写后的test()方法，输出为0，Father初始化完毕后，子类初始化，a变量得以赋值为123，此时Son son = new Son()执行完毕，son.test()输出123。这是一种不好的代码实践。\n\n  public class Father &#123;\n  public static String str &#x3D; &quot;father_base&quot;;\n  public String a &#x3D; &quot;fbase&quot;;\n  public static void test() &#123;\n    System.out.println(&quot;fbase--&gt; &quot; + str);\n  &#125;\n\n&#125;\nclass Son extends Father &#123;\n  public static String str &#x3D; &quot;son_base&quot;;\n  public String a &#x3D; &quot;sbase&quot;;\n  public static void test() &#123;\n    System.out.println(&quot;sbase--&gt; &quot; + str);\n  &#125;\n&#125;\n&#x2F;&#x2F;use\n  public static void main(String[] args) &#123;\n    Son son &#x3D; new Son();\n    System.out.println(son.a);\n    System.out.println(son.str);\n    son.test();\n    Father father &#x3D; son;\n    System.out.println(father.a);\n    System.out.println(father.str);\n    father.test();\n  &#125;\n&#x2F;&#x2F; out\nsbase\nson_base\nsbase--&gt; son_base\nfbase\nfather_base\nfbase--&gt; father_base\n\n上面叫做静态绑定，实例变量，静态变量，静态方法，private方法都是静态绑定的，在编译的时候已经确定下来的。\n\nprotested只可被子类访问，不可被外部类访问，可以被同包内类访问。\n\n\n细节\n类加载是从要加载的类的父类开始将其加载到内存的，Java的类加载是动态的。\n类的初始化流程：父类静态代码块，子类静态代码块，父类实例代码块，父类构造方法，子类实例代码块，子类构造方法的顺序进行初始化。\nJVM虚拟机的栈，堆，方法区\n栈：当方法调用时会产生方法压栈，且存放函数的局部变量等。\n方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。\n堆：实例化对象存放的地方\n\n\n初始化过程中，\n对象的创建要进行分配内存，包括父类和子类的所有实例变量，不包括静态变量。\n对所有实例变量赋默认值，这一步在初始化之前已经完成。\n执行实例化初始化代码。Person p = new Person()，则Person类信息放入了方法区，p对象引用放入了栈内，而new Person()所创建的对象则放入了堆中，p指向堆中的对象，对象保留了方法区内的类信息的引用。\n\n\n运行实例方法的时候是根据真实对象来找对于的方法进行执行的，若没有才找父类中的对应方法。\n\n弊端\n破坏封装，若父类更改或者增加了公开方法，则可能直接影响子类的行为，甚至导致逻辑出错。相反，子类也限制了父类随意更改实现的自由。\n在应用到现实生活中时，也并不是一定是严丝合缝的符合实际，鸟都会飞，那继承鸟类之后的企鹅不会飞。\n\n\n\n\n\n\n\n\n\n\n尽量少使用继承，使用继承时应将父类尽量抽象，将真正公共行为放入父类，也应考虑清楚哪些可以用final修饰以防止子类继承，进而得到更高父类的代码修改的自由度，且部分的功能可以用实现接口来实现比继承更加方便。\n接口\n所有方法默认为public。定义的变量默认为public static final。\n\n接口允许多继承接口。类允许继承多个接口。\n\n不能new接口，只能通过实现类来创建对象。\n\n自我理解，接口更多的使用在为某一个类增加一种或多种特殊能力，而继承更像是一种模板。\n\n类中 extends 在 implements 关键字之前。\n\n在一些框架中，若直接用子类实现接口对象，则称面向具体编程，应避免这种情况，而采用面向接口编程。\n静态方法\n通过interfaceName.method()限定调用。无需子类实现。public interface Demo &#123;\n  public static boolean hasNext() &#123;\n    return true;\n  &#125;\n&#125;\n\n默认方法public interface Demo &#123;\n  default boolean hasNext() &#123;\n    return true;\n  &#125;\n&#125;\n\n\n通过子类对象调用。无需子类刻意实现。可被子类重写。\n例子：默认方法的使用。\n\npublic interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\nclass Son implements Father &#123;&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\n&#x2F;&#x2F;out father\n\n\n例子：默认方法的重写，由下代码可看出若子类调用父类的方法用Father.super.method()方式。\n\npublic interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\nclass Son implements Father &#123;\n  @Override\n  public void callMe() &#123;\n    Father.super.callMe();\n    System.out.println(&quot;son&quot;);\n  &#125;\n&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\n&#x2F;&#x2F;out -&gt; father son\n\n\n例子：当两个接口中有一样的默认方法时，必须由子类重写。即使一个提供了默认实现，另一个接口仅仅是定义的同名抽象方法。\n\npublic interface Father &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;father&quot;);\n  &#125;\n&#125;\ninterface Mother &#123;\n  default void callMe() &#123;\n    System.out.println(&quot;mother&quot;);\n  &#125;\n&#125;\nclass Son implements Father, Mother &#123;\n  @Override\n  public void callMe() &#123;\n    Father.super.callMe();\n  &#125;\n&#125;\n&#x2F;&#x2F;use\nnew Son().callMe();\nFather father &#x3D; new Son();\nfather.callMe();\nMother mother &#x3D; new Son();\nmother.callMe();\n&#x2F;&#x2F;out -&gt; father father father\n\n","slug":"java/basic/basicjava2","date":"2023-01-11T01:47:37.000Z","categories_index":"java基础","tags_index":"java","author_index":"Qidai"},{"id":"1a10fb860efe72fabf13abf525b82b1c","title":"Java复习篇：内部类","content":"\n\n\n\n\n\n注意\n  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。  文章欢迎大家评论指正。\n\n\n\n\n\n\n\n\n\n\n参考：https://www.cnblogs.com/dolphin0520/p/3811445.html     十分重要\n小知识点的收获\n可变长参数就可以理解为数组\n文中的一些说法，accessor访问器方法和mutator更改器方法，说白了mutator更改器方法就是类似list.add()方法，add方法改变了list对象的内容，即被成为更改器方法。而前者accessor就是相反，不改变调用者的对象属性与内容，比如工厂类的实现。\njava所有参数都是值传递，引用对象传递地址值，基本数据类型是值拷贝。\n\n函数调用的原理\n函数调用是通过栈来实现的，通过出栈和入栈的配合操作来达到函数调用，每次的调用都会分配栈空间来存储参数，局部变量以及返回地址等，从这也就知道函数调用是有成本的，若进行递归操作，数量多的递归层数会造成大量的方法栈压栈，若超出栈空间则会栈溢出，即StackOverflowError错误，会直接导致程序停摆。所以能避免这种进行就应该进行避免。\n\n内部类\n对于所有内部类，越是作用域范围小的地方定义的变量优先级越高。\n\n静态内部类  public class Outter &#123;\n  ...\n  public static class Inner &#123;....&#125;\n&#125;\n\n使用，如下两种创建方式\n\n  public class Outter &#123;\n  private static int name &#x3D; 2;\n  public static class Inner &#123;\n    public void test() &#123;\n     System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n public static void main(String[] args) &#123;\n  &#x2F;&#x2F;静态内部类对象的两种创建方式\n    new Inner().test();\n    new Outter.Inner().test();\n  &#125;\n&#125;\n\n静态内部类除了不可以访问外部类的成员变量和方法，其他与普通类没啥不一样。\n关于内部类为何可以访问外部类的私有变量，《Java编程的逻辑》中提到，是通过给私有变量建立了一个非私有的访问方法，在该方法中返回私有变量的值，类似于getter&#x2F;setter方法。\n\n\n\n\n\n\n\n\n由于这里自己就没编译出书上的代码段，则直接引用了书上的结果，之后会补上为什么。@todo P143\n\n\n成员内部类  public class Outter &#123;\n  ...\n  public class Inner &#123;....&#125;\n&#125;\n\n使用，如下两种方式\n\n  public class Outter &#123;\n  private String name;\n  public Outter(String name) &#123;\n      this.name &#x3D; name;\n  &#125;\n  &#x2F;&#x2F; 得到内部类实例的方法一\n  public Inner getInner(String name) &#123;\n      return new Inner(name);\n  &#125;\n  public class Inner &#123;\n      private String name;\n      public Inner(String name) &#123;\n          this.name &#x3D; name;\n      &#125;\n      &#x2F;&#x2F; 判断是否属于一个Outter对象的方法\n      public boolean belongsTo(Outter obj) &#123;\n          return Outter.this &#x3D;&#x3D; obj;\n      &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n      Outter qidai &#x3D; new Outter(&quot;Qidai&quot;);\n      Inner inner &#x3D; qidai.getInner(&quot;inner&quot;);\n      System.out.println(inner.belongsTo(qidai));\n\n      Outter ohbug &#x3D; new Outter(&quot;ohbug.cn&quot;);\n      &#x2F;&#x2F;得到内部实力类的方法二\n      Inner inner2 &#x3D; ohbug.new Inner(&quot;inner2&quot;);\n      System.out.println(inner2.belongsTo(qidai));\n  &#125;\n&#125;\n&#x2F;&#x2F; output : true false\n\n成员内部类可以访问外部类的所有内容。\n外部类访问内部类也是一样，但是外部类访问内部类的成员变量时需要创建内部类的对象，通过对象才可以访问，这是因为成员内部类的创建是依赖于外部类的，当有内部类访问外部类的时候，外部类一定先于内部类进行了初始化，所以内部类访问外部类的所有东西都是无条件的，而当外部类访问成员内部类的成员变量时，成员变量必须初始化才使用，即内部类初始化后才可以使用，即外部类引用内部类的变量必须通过内部类对象引用。\n成员内部类中不能存在任何static的变量和方法，个人的理解是内部类要依赖于某一个外部类对象，而static修饰的变量和方法是在编译期就明确下来的，并不能知晓属于某一个外部类对象。但是static final 修饰的变量则为常量，是可以出现的。\n可以看到，成员内部类的实例化是必须依赖一个已经实例化的外部类对象的。代码中展示了创建成员内部类对象的两种方法。  \n由于内部类对象和外部类对象是类似绑定关系，则如上代码中的beblongsTo()方法展示了如何判断两个内部类对象是否属于一个外部类对象。\n成员内部类编译完成后隐含的包含一个指向外部类的引用。通过javap -p target.class可以看到。如下代码。\n\n  public class Outter &#123;\n  private int name &#x3D; 2;\n  public class Inner &#123;\n    public void test() &#123;\n      System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n    Inner inner &#x3D; new Outter().new Inner();\n    inner.test();\n  &#125;\n&#125;\n\n反编译后为\n\n  shell&gt; javap -p Outter$Inner.class #内部类\nCompiled from &quot;Outter.java&quot;\npublic class Outter$Inner &#123;    \n  final Outter this$0;             #外部类对象引用，final不可变\n  public Outter$Inner(Outter);     #从这可以看到，本身代码并没有对Inner构造器初始化，但是Java自动的将Outter的对象传入进行初始化，进行绑定。\n  public void test();\n&#125;\nshell&gt; javap -p Outter.class       #外部类\nCompiled from &quot;Outter.java&quot;\npublic class Outter &#123;\n  private int name;\n  public Outter();\n  public static void main(java.lang.String[]);\n&#125;\n\n对比静态内部类，则没有this$0的引用，以及默认初始化的操作。\n\n\n点击查看静态内部类的代码以及反编译结果。\npublic class Outter &#123;\n  private static int name &#x3D; 2;\n  public static class Inner &#123;\n    public void test() &#123;\n      System.out.println(&quot;xxx&quot; + name);\n    &#125;\n  &#125;\n  public static void main(String[] args) &#123;\n    new Inner().test();\n  &#125;\n&#125;\nshell&gt; javap -p Outter$Inner.class\nCompiled from &quot;Outter.java&quot;\npublic class Outter$Inner &#123;\n  public Outter$Inner();\n  public void test();\n&#125;\nshell&gt; javap -p Outter.class\nCompiled from &quot;Outter.java&quot;\npublic class Outter &#123;\n  private static int name;\n  public Outter();\n  public static void main(java.lang.String[]);\n  static &#123;&#125;;\n&#125;\n\n\n\n方法内部类  public class Outter &#123;\n  ...\n  public void test() &#123;\n    class Inner &#123;\n      ...\n    &#125;\n  &#125;\n&#125;\n\n若test()是实例方法，内部类则可以访问外部类的所有，以及test()方法中被final修饰的变量。\n若test()是静态方法，则内部类只可以访问外部类的静态变量和方法，以及test()方法中被final修饰的变量。\n关于其具体实现，与上面分析的成员内部类十分相似，若是成员方法内部类，一样是存有外部类的对象引用，一样是通过传递构造器参数来初始化成员方法内部类。静态方法内部类类似则没有。\n\n匿名内部类\n常用于监听类函数使用，在Java8中加入的lambda表达式中常用。\nnew Panel().addMouseListener(new MouseAdapter() &#123;\n  @Override\n  public void mouseClicked(MouseEvent e) &#123;\n    super.mouseClicked(e);\n  &#125;\n&#125;);\n\n只能被使用一次，没有类名，没有构造方法。\n\n可以使用外部类的所有内容，必须为final修饰。\n\n\nfinal修饰\n关于匿名和方法内部类引用变量必须final修饰，有如下代码，摘自参考文章中。\n\n  public class Test &#123;\n  public void test() &#123;\n    final int a &#x3D; 1;\n    new Thread()&#123;\n        public void run() &#123;\n            ...\n            System.out.println(a);\n            ...\n        &#125;;\n    &#125;.start();\n  &#125;\n&#125;\n\n当test()方法执行完后，新开线程未必能够执行完成，那么a是如何处理的，a由final修饰，在编译期已经可以确定下来，则Java是将final参数直接复制一份进匿名内部类中。\n\n  public class Test &#123;\n  public void test(final int a) &#123;\n    new Thread()&#123;\n        public void run() &#123;\n            ...\n            System.out.println(a);\n            ...\n        &#125;;\n    &#125;.start();\n  &#125;\n&#125;\n\n对于这种编译器并不能确定的参数，回想之前的成员内部类初始化，匿名内部类同样也有外部引用，为达到对匿名类内a的初始化，则在将外部引用传入内部类初始化的同时，会传入参数a的值，即内部类初始化的时候是通过类似Inner(Outter_constructor,int)的方式进行a的内容赋值的。\n对于为何必须final修饰，由于Java是通过拷贝外部变量进内部类中，则两个内外部类的变量是不同的，这样如果内部类对变量进行修改，则内外变量会造成数据的不一样，所以必须是final修饰。\n\n","slug":"java/basic/basicjava1","date":"2023-01-10T13:06:07.000Z","categories_index":"java基础","tags_index":"java,todo","author_index":"Qidai"},{"id":"c1d2fc8301f1a7844f90d47afa5e34a0","title":"回顾，总结，出发 ！","content":"回顾回想自己中专一路过来到现在的本科，虽然说是本科已然是烂大街的现象，而且是普普通通的二本院校，不过回想起来也是十分的感谢自己遇到过的所有老师，自己好像有幸运加持一般，遇到的老师都或多或少的改变了自己的人生轨迹。\n中专的时候，教室里上课考验的不再是学生的心理素质，而是考验的老师的心理素质。所有人几乎全部在睡觉或者玩手机，老师站在讲台上，手里握着泛黄的课本，认认真真的在讲着，偶尔抽来学生提问，也只是会得到学生的 “我不会” 的回答，老师也没有无奈的表情，或许是已经习惯了。记忆尤新的是我只是上去解了一个方程，下面居然都有惊叹的声音，我不经有些好奇，这有很难么？后来的我开始好好学，当时报的专业是数控机床，加上小时候拆东拆西的动手能力不错，很快就能上手机床，老师也很好，一些在鼓励我，最后快毕业的时候，大家凑钱买来黄铜，老师交给我，让我车一些子弹，当然是实心的，当作纪念品。从此，我的自信心就在这所不大点的学校培养起来了。\n中专毕业后，自己也糊里糊涂的跟着去长城汽车实习了，这哪里是实习，分明是压榨，自己被分配到最底层的车间，每天拉着载满货物的两米多的板车到处走。直到过年回家了，帮家里收拾东西的时候，老妈说了一句，要不你还是再考学吧。\n听从老妈的话，自己又顺利的从中专升入了大专，在这所也是不大点的学校，我收获颇丰。升入大专后，报的是计算机专业，也不知怎的，自己就和身边人在编程上有些差距，感觉编程还是很简单的，但是现在回想起来，谁不会照着书敲代码呢？ 但也就是自己这么一点点优势，后面才进入了老师的办公室，全职在办公室学开发，而且是不用上课的那种！！还有一千多块的工资拿，当时真过的还挺滋润的。后来慢慢的学，从strust2 到spring到后面出现的boot，当时只是会用的地步，之后跟着老师全国跑，涨了眼界，自此也快到了专科毕业，在专科的时候，真的是十分感谢把我招入办公室的老师，虽然我现在把那些技术都要忘得一干二净。\n最后才到了近些年，也很幸运的把握住的升本的机会，来到了一所本科学校学习，到这，我才真正的明显的感觉到本科和专科的同学的不同，大家都开始学了，虽然不是重本，但是这给当时的我带来的感觉是相当有冲击力的。到了本科，依旧是计算机专业，仗着专科的学习，自己感觉相当良好，其实是相当傻逼。就因为这种翘尾巴，导致了我本科阶段的学习都是临时抱佛脚，而且把之前的技术全部抛掷脑后了，两年说完就完，到这自己又好像回到了入学中专的起点，脑子一点东西没剩下。到这依然是2022年了，自己拿到本科毕业证的时候已经24岁了。然后在家备考一年研究生，2023年的今天，我都已经25岁，但仍旧是什么都不是。\n专科到本科之间这段时间，自己参加了培训班，又不满培训班的课程，当时真的是自己都学过就跑回家了，在这是傲娇了第二次，回头想想也真是傻逼。\n吐槽：为什么培训班都教人包装简历，伪造学历来加入程序员这个行列，吃着这碗饭，自己难道都不怕被查吗？这也导致了我之后找公司真是狗都不要。这不是引战，我理解包装行为，谁又跟钱过不去呢。\n总结到这也算是大概的过了过最近几年，有几点我觉得还真是要提醒自己注意。\n\n存钱，存到手的才是钱。自己也到了该存钱的年纪了。\n傲娇，这应该是我的致命伤，只要自己稍微了解，自己就会比较轻视这一块东西，以后多加改正。\n考研，希望今年找工作顺利，利用闲暇时间再复习复习，也算是今年的大任务之一了。还有老爸安排的找对象，这个随缘吧。\n今年多多看书，用自己的话总结下来，也希望老铁们看到这，加个收藏，多多支持。\n\n出发最开心的莫过于自己搭建了自己博客网站，现在真是动力满满，一定要把这股劲保持下去。最后了希望自己在今年能回顾之前，总结问题，认真出发。\n也由衷的祝福看到这的老铁们，2023年一帆风顺。\n希望大家多多评论~\n","slug":"talk/newstart2023","date":"2023-01-07T14:49:24.000Z","categories_index":"日常唠叨","tags_index":"日常唠叨","author_index":"Qidai"}]