<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>OhBug.cn</title>
  
  <subtitle>OhBug.cn</subtitle>
  <link href="https://ohbug.cn/atom.xml" rel="self"/>
  
  <link href="https://ohbug.cn/"/>
  <updated>2023-02-20T14:17:41.881Z</updated>
  <id>https://ohbug.cn/</id>
  
  <author>
    <name>Qidai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>RocketMQ 消息</title>
    <link href="https://ohbug.cn/post/rocketmq/rocketmq2.html"/>
    <id>https://ohbug.cn/post/rocketmq/rocketmq2.html</id>
    <published>2023-02-20T14:17:32.000Z</published>
    <updated>2023-02-20T14:17:41.881Z</updated>
    
    <content type="html"><![CDATA[<h1 id="安装RocketMQ"><a href="#安装RocketMQ" class="headerlink" title="安装RocketMQ"></a>安装RocketMQ</h1><ul><li>首先调整<code>bin/runbroker</code>和<code>bin/runserver</code>的内存占用大小，后在<code>conf/broker.conf</code>中加入 <code>namesrvAddr=127.0.0.1:9876</code>。</li><li>安装RocketMQ5.0.0的一个大坑，就是必须先修改掉bin&#x2F;mqbroker脚本中的代码<pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"># 之前是双括号，要将双括号改成单括号  while [ $# -gt 0 ];# ...while [[ $# -gt 0 ]]; do  case $1 in# ...</code></pre></li></ul><details class="custom-details"><summary>隐藏内容</summary><p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup">&lt;dependency&gt;    &lt;groupId&gt;org.apache.rocketmq&lt;&#x2F;groupId&gt;    &lt;artifactId&gt;rocketmq-client&lt;&#x2F;artifactId&gt;    &lt;version&gt;5.0.0&lt;&#x2F;version&gt;&lt;&#x2F;dependency&gt;</code></pre></p></details><h1 id="普通消息"><a href="#普通消息" class="headerlink" title="普通消息"></a>普通消息</h1><h2 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h2><ul><li>一般应用于微服务解耦、事件驱动、数据集成等场景，要求数据传输通道具有<strong>可靠传输的能力</strong>，且对消息的<strong>处理时机、处理顺序没有特别要求</strong>。支持生产者和消费者的异步解耦通信。<ul><li>微服务异步解耦：电商交易场景，上层订单系统产生的消息供下游系统使用，实现解耦。</li><li>数据集成传输：离线的日志收集场景，不做任何处理，将日志顺序传送至下游系统使用。</li></ul></li></ul><h2 id="生命周期"><a href="#生命周期" class="headerlink" title="生命周期"></a>生命周期</h2><ul><li>初始化：消息被生产者构建并完成初始化，待发送到服务端的状态。</li><li>待消费：消息被发送到服务端，对消费者可见，等待消费者消费的状态。</li><li>消费中：消息被消费者获取并按业务进行处理的过程。 此时服务端会等待消费者完成消费并提交消费结果，如果一定时间后没有收到消费者的响应，RocketMQ会对消息进行重试处理。</li><li>消费提交：消费者完成消费处理，并向服务端提交消费结果，服务端标记当前消息已经被处理（包括消费成功和失败）。  RocketMQ默认支持保留所有消息，此时消息数据并不会立即被删除，只是逻辑标记已消费。消息在保存时间到期或存储空间不足被删除前，消费者仍然可以回溯消息重新消费。</li><li>消息删除：RocketMQ按照消息保存机制滚动清理最早的消息数据，将消息从物理文件中删除。</li><li><strong>建议</strong>：设置全局唯一业务索引键，方便问题追踪。</li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Producer &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 1.创建一个发送消息的对象Producer        DefaultMQProducer producer &#x3D; new DefaultMQProducer(&quot;group1&quot;);  &#x2F;&#x2F; 入参为自定义组名        &#x2F;&#x2F; 2.设定发送的命名服务器地址        producer.setNamesrvAddr(&quot;192.168.137.29:9876&quot;);        &#x2F;&#x2F; 设置发送消息超时时间（默认为3000）        producer.setSendMsgTimeout(60000);        &#x2F;&#x2F; 3.启动发送的服务        producer.start();        &#x2F;&#x2F; 4.创建要发送的消息对象,指定topic和body        Message msg &#x3D; new Message(&quot;topic1&quot;, &quot;test-tag&quot;,                &quot;业务ID&quot;, &quot;hello rocketmq&quot;.getBytes(&quot;UTF-8&quot;));        &#x2F;&#x2F; 5.发送单条消息        SendResult result &#x3D; producer.send(msg);        &#x2F;&#x2F; 打印返回消息        System.out.println(&quot;返回结果：&quot;+result);        &#x2F;&#x2F; 6.关闭连接        producer.shutdown();    &#125;&#125;public class Consumer &#123;    public static void main(String[] args) throws Exception &#123;        &#x2F;&#x2F; 1.创建一个接收消息的对象Consumer        DefaultMQPushConsumer consumer &#x3D; new DefaultMQPushConsumer(&quot;group1&quot;);  &#x2F;&#x2F; 入参为自定义组名        &#x2F;&#x2F; 2.设定接收的命名服务器地址        consumer.setNamesrvAddr(&quot;192.168.137.29:9876&quot;);        &#x2F;&#x2F; 3.设置接收消息对应的topic，对应的sub标签为任意*        consumer.subscribe(&quot;topic1&quot;, &quot;*&quot;);        &#x2F;&#x2F; 4.开启监听，用于接收消息        consumer.registerMessageListener((MessageListenerConcurrently) (list, consumeConcurrentlyContext) -&gt; &#123;            &#x2F;&#x2F; 遍历消息            for(MessageExt msg : list)&#123;                System.out.println(&quot;消息：&quot; + new String(msg.getBody()));            &#125;            &#x2F;&#x2F; 成功处理后，mq 收到该标记，则相同的消息将不会再次发给消费者            return ConsumeConcurrentlyStatus.CONSUME_SUCCESS;        &#125;);        &#x2F;&#x2F; 5.启动接收消息的服务        consumer.start();  &#x2F;&#x2F; 开启多线程监控消息，会持续运行        System.out.println(&quot;接收消息服务已开启运行&quot;);    &#125;&#125;</code></pre><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;安装RocketMQ&quot;&gt;&lt;a href=&quot;#安装RocketMQ&quot; class=&quot;headerlink&quot; title=&quot;安装RocketMQ&quot;&gt;&lt;/a&gt;安装RocketMQ&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;首先调整&lt;code&gt;bin/runbroker&lt;/code&gt;和&lt;</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://ohbug.cn/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://ohbug.cn/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>RocketMQ 基础概念</title>
    <link href="https://ohbug.cn/post/rocketmq/rocketmq1.html"/>
    <id>https://ohbug.cn/post/rocketmq/rocketmq1.html</id>
    <published>2023-02-19T13:35:32.000Z</published>
    <updated>2023-02-19T16:23:05.971Z</updated>
    
    <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://rocketmq.apache.org/zh/docs/introduction/02concepts">https://rocketmq.apache.org/zh/docs/introduction/02concepts</a></p></blockquote><h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p><img src="/img/rocketmq/topic.png" alt="picture 1">  </p><ul><li><strong>主题（Topic）</strong>：用于标识同一类业务逻辑的消息，所有消息资源的定义都在主题内部完成，但主题是一个逻辑概念，并不是实际的消息容器。主题通过TopicName来做唯一标识和区分。作用主要如下：<ul><li>定义数据的分类隔离： 不同业务类型的数据拆分到不同的主题中管理，通过主题实现存储的隔离性和订阅隔离性。</li><li>定义数据的身份和权限： 消息本身是匿名无身份的，但是可以对同一分类的消息使用相同的主题来做身份识别和权限管理。</li></ul></li></ul><ul><li><strong>消息类型（MessageType）</strong>：按照消息传输特性的不同而定义的分类，用于类型管理和安全校验。支持的消息类型有普通消息、顺序消息、事务消息和定时&#x2F;延时消息。</li></ul><ul><li><strong>消息队列（MessageQueue）</strong>：队列是 RocketMQ 中消息存储和传输的实际容器，也是消息的最小存储单元。  RocketMQ 的所有主题都是由多个队列组成，以此实现队列数量的水平拆分和队列内部的流式存储。队列通过QueueId来做唯一标识和区分。主要作用如下：<ul><li>存储顺序性：队列天然具备顺序性，即消息按照进入队列的顺序写入存储，同一队列间的消息天然存在顺序关系，队列头部为最早写入的消息，队列尾部为最新写入的消息。消息在队列中的位置和消息之间的顺序通过位点（Offset）进行标记管理。</li><li>流式操作语义：RocketMQ 基于队列的存储模型可确保消息从任意位点读取任意数量的消息，以此实现类似聚合读取、回溯读取等特性。</li></ul></li></ul><ul><li><strong>消息（Message）</strong>：消息是  RocketMQ 中的最小数据传输单元。生产者将业务数据的负载和拓展属性包装成消息发送到服务端，服务端按照相关语义将消息投递到消费端进行消费。具备如下特点：<ul><li>消息不可变性：消息本质上是已经产生并确定的事件，一旦产生后，消息的内容不会发生改变。即使经过传输链路的控制也不会发生变化，消费端获取的消息都是只读消息视图。</li><li>消息持久化：RocketMQ 会默认对消息进行持久化，即将接收到的消息存储到  RocketMQ 服务端的存储文件中，保证消息的可回溯性和系统故障场景下的可恢复性。</li></ul></li></ul><ul><li><p><strong>消息视图（MessageView）</strong>：是面向开发视角提供的一种消息只读接口。通过消息视图可以读取消息内部的多个属性和负载信息，但是不能对消息本身做任何修改。</p></li><li><p><strong>消息标签（MessageTag）</strong>： 消息标签是Apache RocketMQ 提供的细粒度消息分类属性，可以在主题层级之下做消息类型的细分。消费者通过订阅特定的标签来实现细粒度过滤，根据过滤条件进行筛选匹配，将符合条件的消息投递给消费者进行消费。支持Tag标签过滤和SQL属性过滤。<br><img src="/img/rocketmq/message.png" alt="picture 2">  </p></li><li><p><strong>消息过滤</strong>：消费者可以通过订阅指定消息标签（Tag）对消息进行过滤，确保最终只接收被过滤后的消息合集。过滤规则的计算和匹配在Apache RocketMQ 的服务端完成。</p></li><li><p><strong>消息位点（MessageQueueOffset）</strong>：消息是按到达  RocketMQ 服务端的先后顺序存储在指定主题的多个队列中，每条消息在队列中都有一个唯一的Long类型坐标，这个坐标被定义为消息位点。</p></li><li><p><strong>消费位点（ConsumerOffset）</strong>：一条消息被某个消费者消费完成后不会立即从队列中删除， RocketMQ 会基于每个消费者分组记录。消费过的最新一条消息的位点，即消费位点。</p></li><li><p><strong>消息索引（MessageKey）</strong>：通过设置的消息索引可以快速查找到对应的消息内容。</p></li><li><p><strong>生产者（Producer）</strong>：生产者是   RocketMQ 系统中用来构建并传输消息到服务端的运行实体。生产者通常被集成在业务系统中，将业务消息按照要求封装成消息并发送至服务端。生产者和主题的关系为多对多关系，即同一个生产者可以向多个主题发送消息，对于平台类场景如果需要发送消息到多个主题，并不需要创建多个生产者；同一个主题也可以接收多个生产者的消息，以此可以实现生产者性能的水平扩展和容灾。</p></li><li><p><strong>事务检查器（TransactionChecker）</strong>：RocketMQ 中生产者用来执行本地事务检查和异常事务恢复的监听器。事务检查器应该通过业务侧数据的状态来检查和判断事务消息的状态。</p></li><li><p><strong>事务状态（TransactionResolution）</strong>：RocketMQ 中事务消息发送过程中，事务提交的状态标识，服务端通过事务状态控制事务消息是否应该提交和投递。事务状态包括事务提交、事务回滚和事务未决。</p></li><li><p><strong>事务消息</strong>：是   RocketMQ 提供的一种高级消息类型，支持在分布式场景下保障消息生产和本地事务的最终一致性。</p></li><li><p><strong>消费者分组（ConsumerGroup）</strong>：消费者分组是  RocketMQ 系统中承载多个消费行为一致的消费者的负载均衡分组。和消费者不同，消费者分组并不是运行实体，而是一个逻辑资源。在  RocketMQ 中，通过消费者分组内初始化多个消费者实现消费性能的水平扩展以及高可用容灾。</p></li><li><p><strong>消费者（Consumer）</strong>：消费者是  RocketMQ 中用来接收并处理消息的运行实体。消费者通常被集成在业务系统中，从服务端获取消息，并将消息转化成业务可理解的信息，供业务逻辑处理。</p></li><li><p><strong>消费结果（ConsumeResult）</strong>：用来标识本次消息是否正确处理。消费结果包含消费成功和消费失败。</p></li><li><p><strong>订阅关系（Subscription）</strong>：订阅关系是Apache RocketMQ 系统中消费者获取消息、处理消息的规则和状态配置。订阅关系由消费者分组动态注册到服务端系统，并在后续的消息传输中按照订阅关系定义的过滤规则进行消息匹配和消费进度维护。</p></li><li><p><strong>定时&#x2F;延时消息</strong>：定时&#x2F;延时消息是   RocketMQ 提供的一种高级消息类型，消息被发送至服务端后，在指定时间后才能被消费者消费。通过设置一定的定时时间可以实现分布式场景的延时调度触发效果。</p></li><li><p><strong>顺序消息</strong>：顺序消息是   RocketMQ 提供的一种高级消息类型，支持消费者按照发送消息的先后顺序获取消息，从而实现业务场景中的顺序处理。</p></li></ul><h1 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://juejin.cn/post/7109262212350345224">https://juejin.cn/post/7109262212350345224</a></p></blockquote><p><img src="/img/rocketmq/all.png" alt="picture 3">  </p><h2 id="Nameserver"><a href="#Nameserver" class="headerlink" title="Nameserver"></a>Nameserver</h2><ul><li>Nameserver 集群，topic 的路由注册中心，为客户端根据 Topic 提供路由服务，从而引导客户端向 Broker 发送消息。Nameserver 之间的节点不通信。路由信息在Nameserver 集群中保持一致， NameServer 起来后监听 端口，等待 Broker、Producer、Consumer 连上来，NameServer 是集群元数据管理中心。</li></ul><h2 id="Broker"><a href="#Broker" class="headerlink" title="Broker"></a>Broker</h2><ul><li>消息存储服务器，分为两种角色: Master 与 Slave，上图中呈现的就是2主2从的部署架构，在 RocketMQ 中，主服务承担读写操作，从服务器作为一个备份，当主服务器存在压力时，从服务器可以承担读服务。所有 Broker，包含 Slave 服务器每隔30s 会向Nameserver 发送心跳包，心跳包中会包含存在在 Broker 上所有的 topic 的路由信息。</li><li>可以同时部署多个 Master Broker和多个 Slave Broker，一个 Master 可以对应多个 Slave，但是一个 Slave 只能对应一个 Master。Master 与 Slave 需要有相同的 BrokerName，不同的 BrokerId 。BrokerId 为 0 表示 Master，非 0 表示 Slave，但只有 BrokerId&#x3D;1 的从服务器才会参与消息的读负载。</li></ul><h2 id="Client"><a href="#Client" class="headerlink" title="Client"></a>Client</h2><ul><li>消息客户端，包括Producer(消息发送者)和Consumer(消费消费者)，客户端在同一时间只会连接一台nameserver，只有在连接出现异常时才会向尝试连接另外一台。客户端每隔 30s向Nameserver 发起topic 的路由信息查询。Nameserver是在内存中存储Topic 的路由信息，持久化Topic 路由信息的地方是在 Broker中。</li></ul><h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a>Consumer</h3><ul><li>在rocketMQ中，支持两种消费模式<ul><li><strong>广播模式</strong>：一个消费组内的所有消费者每一个都会处理 topic 中的每一条消息，通常用于刷新内存缓存。</li><li><strong>集群模式</strong>：一个消费组内的所有消费者共同消费一个topic 中的消息，即分工协作，一个消费者消费一部分数据，启动负载均衡。</li></ul></li><li>消息的分配问题，涉及到两种最常用的算法<ul><li>平均分配</li><li>轮流分配</li></ul></li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>在MQ领域有一个不成文的约定: 同一个消费者同一时间可以分配多个队列，但一个队列同一时间只会分配给一个消费者</p></blockquote><h2 id="消费队列重平衡机制"><a href="#消费队列重平衡机制" class="headerlink" title="消费队列重平衡机制"></a>消费队列重平衡机制</h2><ul><li>在RocketMQ 客户端中会每隔20s 去查询当前 topic 的所有队列、消费者的个数，运用队列负载算法进行重新分配，然后与上一次的分配结果进行对比，如果发生了变化，则进行队列重新分配。如果没有发生变化，则忽略。比如之前三个消费者，之后新增了一个消费者，则队列会均匀的分配到这四个消费者上。</li></ul><h2 id="消费模型"><a href="#消费模型" class="headerlink" title="消费模型"></a>消费模型</h2><ul><li><strong>并发消费</strong>：对一个队列中消息，每一个消费者内部都会创建一个线程池，对队列中的消息多线程处理。</li><li><strong>顺序消费</strong>： 在RocketMQ中提供了基于队列的顺序消费模型，即尽管一个消费组中的消费者会创建一个多线程，但针对同一个 Queue，会加锁。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>并发消费模型中，消息消费失败默认会重试 16 次，每一次的间隔时间不一样。而顺序消费，如果一条消息消费失败，则会一直消费，直到消费成功。故在顺序消费的使用过程中，应用程序需要区分系统异常、业务异常，如果是不符合业务规则导致的异常则重试多少次都无法消费成功，这个时候一定要告警机制，及时进行人为干预，否则消费会积压。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;span class=&quot;custom-blockquote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; d</summary>
      
    
    
    
    <category term="RocketMQ" scheme="https://ohbug.cn/categories/RocketMQ/"/>
    
    
    <category term="RocketMQ" scheme="https://ohbug.cn/tags/RocketMQ/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：I/O - NIO</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava9.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava9.html</id>
    <published>2023-02-18T11:20:15.000Z</published>
    <updated>2023-02-19T08:12:53.334Z</updated>
    
    <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>《Java高并发核心编程 卷一》</p></blockquote><h1 id="NIO-Non-Blocking-IO"><a href="#NIO-Non-Blocking-IO" class="headerlink" title="NIO (Non-Blocking IO)"></a>NIO (Non-Blocking IO)</h1><ul><li>核心部件： <code>Channel</code> ， <code>Buffer</code> ， <code>Selector</code> 。</li><li>NIO的非阻塞是NIO使用了通道和通道的多路复用技术，NIO的实现是基于底层选择器的系统调用的，所以NIO需要底层操作系统提供支持。</li></ul><h2 id="Buffer"><a href="#Buffer" class="headerlink" title="Buffer"></a>Buffer</h2><h3 id="Buffer重要变量"><a href="#Buffer重要变量" class="headerlink" title="Buffer重要变量"></a>Buffer重要变量</h3><p><img src="/img/java/niobuffer.png" alt="picture 1">  </p><ul><li><p>非线程安全类，NIO Channel 的读写都要经过Buffer，所谓Channel的读取，就是将数据从Channel读取到Buffer中;所谓Channel的写入，就是将数据从Buffer写入Channel中。</p></li><li><p>Buffer本身并没有实现存储的功能，而是其子类有对应的存储数据的数组，比如<code>ByteBuffer</code>的底层是字节数组，<code>CharBuffer</code> 底层是<code>final char[] hb;</code>。</p></li><li><p>Buffer 有四个标识Buffer位置的重要变量：<code>capacity</code> ,<code>limit</code> ,<code>position</code>，<code>mark</code>。</p><ol><li>capacity属性表示内部容量的大小。一旦写入的对象数量超过了capacity，缓冲区就满了，不能再写入了。且一旦初始化，就不能再改变，因为底层是数组。</li><li>position表示当前的位置。position属性的值与缓冲区的读写模式有关。<ul><li>写模式：在刚进入写模式时，position值为0，表示当前的写入位置为从头开始。每当一个数据写到缓冲区之后，position会向后移动到下1个可写的位置。初始的position值为0，最大可写值为limit-1。当position值达到limit时，缓冲区就已经无空间可写了。</li><li>读模式：当缓冲区刚开始进入读模式时，position会被重置为0。当从缓冲区读取时，也是从position位置开始读。读取数据后，position向前移动到下一个可读的位置。在读模式下，limit表示可读数据的上限。position的最大值为最大可读上限limit，当position达到limit时表明缓冲区已经无数据可读。通过 <code>flip()</code> 切换读写模式。</li><li>在从写模式到读模式的翻转过程中，position和limit属性值会进行调整，limit属性被设置成写模式时的position值，表示可以读取的最大数据位置。position由原来的写入位置变成新的可读位置，也就是0表示可以从头开始读。</li></ul></li><li>limit属性表示可以写入或者读取的数据最大上限，其属性值的具体含义也与缓冲区的读写模式有关。在不同的模式下，limit值的含义是不同的。<ul><li>在写模式下，limit属性值的含义为可以写入的数据最大上限。在刚进入写模式时，limit的值会被设置成缓冲区的capacity值表示可以一直将缓冲区的容量写满。</li><li>在读模式下，limit值的含义为最多能从缓冲区读取多少数据。</li></ul></li><li>mark可以设置Buffer中一个位置，然后可以调用 <code>reset()</code> 让 position 恢复到mark 位置方便读取。</li></ol></li></ul><h3 id="Buffer重要方法"><a href="#Buffer重要方法" class="headerlink" title="Buffer重要方法"></a>Buffer重要方法</h3><p><img src="/img/java/niocoverRtoW.png" alt="picture 2">  </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 创建完成默认是写模式。allocate(int capacity);&#x2F;&#x2F; 把对象写入缓冲区，put得参数要与Buffer类型一致。put(各种类型);&#x2F;&#x2F; 读写转换filp();&#x2F;&#x2F; 在读取完成后，将缓冲区切换成写模式可以调用Buffer.clear() 它们可以将缓冲区转换为写模式。&#x2F;&#x2F; (1)将position清零&#x2F;&#x2F; (2)limit设置为capacity最大容量值，可以一直写入，直到缓冲区写满clear();&#x2F;&#x2F; 每次从position的位置读取一个数据，并且进行相应的缓冲区属性的调整get(...);&#x2F;&#x2F; 已经读完的数据，如果需要再读一遍，可以调用rewind方法rewind();</code></pre><h2 id="Channel"><a href="#Channel" class="headerlink" title="Channel"></a>Channel</h2><p><img src="/img/java/channel.png" alt="picture 3"> </p><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; FileChannel 文件拷贝代码    private static void NIOCopyResource(String source, String dest) &#123;        try (FileChannel inChannel &#x3D; new FileInputStream(source).getChannel();             FileChannel outChannel &#x3D; new FileOutputStream(dest).getChannel()) &#123;            ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024 * 500);            while (inChannel.read(buffer) !&#x3D; -1) &#123;                &#x2F;&#x2F; 到这表示有数据都进来了，需要进行读写模式转换，为写文件做准备                buffer.flip();                &#x2F;&#x2F; 写Buffer中数据到目标文件后，为下次循环转换到读模式                outChannel.write(buffer);                buffer.clear();            &#125;        &#125;catch (IOException e)&#123;            e.printStackTrace();        &#125;    &#125;</code></pre><h2 id="Selector"><a href="#Selector" class="headerlink" title="Selector"></a>Selector</h2><ul><li>Selector就是来实现IO多路复用的，主要工作就是注册监听轮询。一个Channel代表一个链接。</li><li>只有继承了 SelectableChannel的Channel才可以注册到Selector后被监听。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 服务端 ServerSocketChannel 网络传输代码private static void startServer() throws Exception&#123;        Selector selector &#x3D; Selector.open();        ServerSocketChannel serverSocketChannel &#x3D; ServerSocketChannel.open();        ServerSocket serverSocket &#x3D; serverSocketChannel.socket();        serverSocket.bind(new InetSocketAddress(host, port));        serverSocketChannel.configureBlocking(false);        serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);        ByteBuffer buffer &#x3D; ByteBuffer.allocate(1024*1024*5);        while (true) &#123;            while (selector.select() &gt; 0) &#123;                Iterator&lt;SelectionKey&gt; iterator &#x3D; selector.selectedKeys().iterator();                while (iterator.hasNext()) &#123;                    SelectionKey key &#x3D; iterator.next();                    if (!key.isValid()) &#123;                        continue;                    &#125;                    SelectableChannel selectableChannel &#x3D; key.channel().configureBlocking(false);                    if (key.isAcceptable()) &#123;                        ServerSocketChannel ssc &#x3D; (ServerSocketChannel) selectableChannel;                        SocketChannel accept &#x3D; ssc.accept();                        if (accept &#x3D;&#x3D; null) continue;                        accept.configureBlocking(false);                        accept.register(selector, SelectionKey.OP_READ);                    &#125;                    if (key.isReadable()) &#123;                        SocketChannel sc &#x3D; (SocketChannel) selectableChannel;                        int length;                        while ((length &#x3D; sc.read(buffer) )!&#x3D; -1) &#123;                            buffer.flip();                            System.out.println(new String(buffer.array(), 0, length));                            buffer.clear();                        &#125;                    &#125;                    iterator.remove();                &#125;            &#125;        &#125;    &#125;&#x2F;&#x2F; 客户端    private static void startClient() throws Exception&#123;        &#x2F;&#x2F; 1、获取通道（channel）        SocketChannel socketChannel &#x3D; SocketChannel.open(new InetSocketAddress(Server.host, Server.port));        &#x2F;&#x2F; 2、切换成非阻塞模式        socketChannel.configureBlocking(false);        &#x2F;&#x2F;不断的自旋、等待连接完成，或者做一些其他的事情        while (!socketChannel.finishConnect()) &#123;        &#125;        &#x2F;&#x2F; 3、分配指定大小的缓冲区        ByteBuffer byteBuffer &#x3D; ByteBuffer.allocate(1024*1024*5);        byteBuffer.put(&quot;hello world&quot;.getBytes());        byteBuffer.flip();        socketChannel.write(byteBuffer);        socketChannel.shutdownOutput();        socketChannel.close();    &#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>《Java编程的逻辑》<br><a href="https://cloud.tencent.com/developer/article/1902272">https://cloud.tencent.com/developer/article/1902272</a></p></blockquote><h1 id="内存映射文件"><a href="#内存映射文件" class="headerlink" title="内存映射文件"></a>内存映射文件</h1><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ul><li><p>所谓内存映射文件，就是将文件映射到内存，文件对应于内存中的一个字节数组，对文件的操作变为对这个字节数组的操作，而字节数组的操作直接映射到文件上。这种映射可以是映射文件全部区域，也可以是只映射一部分区域。不过，这种映射是操作系统提供的一种假象，文件一般不会马上加载到内存，操作系统只是记录下了这回事，当实际发生读写时，才会按需加载。操作系统一般是按页加载的，页可以理解为就是一块，页的大小与操作系统和硬件相关，典型的配置可能是4K、8K等，当操作系统发现读写区域不在内存时，就会加载该区域对应的一个页到内存。这种按需加载的方式，使得内存映射文件可以方便高效地处理非常大的文件，内存放不下整个文件也不要紧，操作系统会自动进行处理，将需要的内容读到内存，将修改的内容保存到硬盘，将不再使用的内存释放。但是同步时机是不确定的。</p></li><li><p>之前提到，在一般的文件读写中，会有两次数据复制，一次是从硬盘复制到操作系统内核，另一次是从操作系统内核复制到用户态的应用程序。而在内存映射文件中，一般情况下，只有一次复制，<strong>且内存分配在操作系统内核，应用程序访问的就是操作系统的内核内存空间</strong>，这显然要比普通的读写效率更高。 正是内存映射的一次复制，避免掉了用户态与内核态的切换，所以对于超小文件的大批量读写是友好的。</p></li><li><p>内存映射文件的另一个重要特点是: 它可以被多个不同的应用程序共享，多个程序可以映射同一个文件，映射到同一块内存区域，一个程序对内存的修改，可以让其他程序也看到，这使得它特别适合用于不同<strong>应用程序之间的通信</strong>。</p></li><li><p>在操作系统中的应用，比如:</p><ul><li>按需加载代码，只有当前运行的代码在内存，其他暂时用不到的代码还在硬盘。</li><li>同时启动多次同一个可执行文件，文件代码在内存也只有一份。</li><li>不同应用程序共享的动态链接库代码在内存也只有一份。</li></ul></li><li><p>内存映射文件也有<strong>局限性</strong>。比如，它不太适合处理小文件，它是按页分配内存的，对于<strong>小文件，会浪费空间</strong>。另外，映射文件要消耗一定的操作系统资源，<strong>初始化比较慢</strong>。</p></li><li><p><strong>总结</strong>：对于一般的文件读写不需要使用内存映射文件，但如果处理的是大文件，要求极高的读写效率，那就可以考虑内存映射文件。</p></li></ul><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><ul><li>首先要获得这条由应用程序直通内核的管道，可以通过<code>FileInputStream/FileOutputStreamo</code>与<code>RandomAccessFile</code> 获得。也可以通过 <code>FileChannel.open(..)</code> 得到。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 将1.txt 映射到内存后，对内存中的操作会同步到文件上。&#x2F;&#x2F; FileChannel.MapMode.READ_ONLY 只可读映射，如果进行写操作会抛出异常&#x2F;&#x2F; FileChannel.MapMode.READ_WRITE 读写映射，对缓存区的修改最终会写入文件&#x2F;&#x2F; FileChannel.MapMode.PRIVATE 读写映射，只对缓冲区修改，但是不会写入文件RandomAccessFile rw &#x3D; new RandomAccessFile(&quot;1.txt&quot;, &quot;rw&quot;);FileChannel rwChannel &#x3D; rw.getChannel();MappedByteBuffer mappedByteBuffer &#x3D; rwChannel.map(FileChannel.MapMode.READ_WRITE, 0, 5);mappedByteBuffer.put(0, (byte)&#39;H&#39;);mappedByteBuffer.put(3, (byte)&#39;9&#39;);rw.close();rwChannel.close();</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;span class=&quot;custom-blockquote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; d</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>MySQL - 索引</title>
    <link href="https://ohbug.cn/post/mysql/mysql1.html"/>
    <id>https://ohbug.cn/post/mysql/mysql1.html</id>
    <published>2023-02-08T14:58:37.000Z</published>
    <updated>2023-02-15T12:38:26.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="常用索引模型"><a href="#常用索引模型" class="headerlink" title="常用索引模型"></a>常用索引模型</h1><ul><li>哈希表：既然涉及到了Hash，则最快的效率一定是直接可以根据Hash进行定位。但是难免会有冲突的时候，冲突的时候会链接成链表，此时若链表很长，且若链表内的信息都无序，若要查找一个特定的值，或查找一个区间内的值，则只能遍历，则查询效率也是很低的。所以<strong>哈希表这种结构适用于只有等值查询的场景</strong>。</li><li>有序数组：<strong>有序数组在等值查询和范围查询场景中的性能就都非常优秀</strong>，因为是有序的，所以查找一个值可以用二分查找，若再区间内查值，因为是有序的，则也可以使用二分查找，但是对于数据频繁插入的时期下，数组元素的移动是相当耗费时间的。所以<strong>有序数组索引只适用于静态存储引擎</strong>。</li><li>搜索树：最直接的就想到了二叉平衡查找树，但是若树深20，则每次查找一个值，都平均需要比较20次才会找到一个值，查询效率也不是很高，所以引入了多叉树，越多叉越能够减少比较次数。所以多叉树广泛应用到数据库中。</li></ul><h1 id="InnoDB的索引模型"><a href="#InnoDB的索引模型" class="headerlink" title="InnoDB的索引模型"></a>InnoDB的索引模型</h1><ul><li>InnoDB中使用了 B+ 树，每个索引在 InnoDB 中都对应一颗树。</li><li>B+树的叶子节点是page （页），一个页里面可以存多个行。页内部有个有序数组，二分法进行查找匹配行。</li><li>比如下面一张表</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">create table T(id int primary key,k int not null,index (k))engine&#x3D;InnoDB;-- data: (100,1)、(200,2)、(300,3)、(500,5) 和 (600,6)</code></pre><ul><li>对应的结构为</li></ul><p><img src="/img/mysql/innodb-index.png" alt="picture 1">  </p><h2 id="主键索引和普通索引"><a href="#主键索引和普通索引" class="headerlink" title="主键索引和普通索引"></a>主键索引和普通索引</h2><ul><li><strong>主键索引</strong>：只要搜索ID这个B+ Tree即可拿到数据。</li><li><strong>普通索引</strong>：先搜索索引拿到主键值，再到主键搜索ID索引树搜索一次(回表)。共查询两次。</li></ul><p><img src="/img/mysql/b+tree.png"></p><h3 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h3><p><img src="/img/mysql/innodb-index.png" alt="picture 1">  </p><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p> 数据如上，结构与上面建表语句一致，问 select * from T where k between 3 and 5 ; 有几次id树的搜索操作。</p></blockquote><ul><li>解析：<ul><li>当查询3时，搜索k树找到ID为300，回表搜索id树，记一次。</li><li>当查询4时，k树中无值。无操作。</li><li>当查询5时，搜索k树找到ID为500，回表搜索id树，记一次。共两次ID树的搜索操作。</li></ul></li><li>优化：若想减少回表操作，则可以使用 <code>select id from T where k between 3 and 5 ;</code>，因为在k树中搜索到了相应的k值后，k值得叶子会直接拿到ID值。</li></ul><h2 id="索引维护"><a href="#索引维护" class="headerlink" title="索引维护"></a>索引维护</h2><ul><li>因为B+树的特性，如果索引是比较有序的，如数据库中得自增ID，则B+树每次插入一条新记录，都是追加操作，都不涉及到挪动其他记录，也不会触发叶子节点的分裂，这样效率是很高的。</li><li>若索引插入是比较无序的，比如某个业务的id作为索引，会造成数据的频繁挪动，甚至分裂出其他的分支，这个过程称为页分裂。页分裂操作还影响数据页的利用率。原本放在一个页的数据，现在分到两个页中，整体空间利用率降低大约 50%。</li><li><strong>综上</strong>，则插入的索引有序是十分有利的。<strong>自增主键往往是更合理的选择，且建议设置为bigint unsigned</strong>。</li><li>如果删除再新建主键索引，它会使得所有的二级索引都失效，并且会用ROWID来作主键索引，性能消耗比较大。删除再重建普通索引貌似影响不大，不过要注意在业务低谷期操作，避免影响业务。</li></ul><h1 id="最左前缀原则"><a href="#最左前缀原则" class="headerlink" title="最左前缀原则"></a>最左前缀原则</h1><p><img src="/img/mysql/left.png" alt="picture 2">  </p><ul><li>如上建立了一个name&amp;age得联合索引，当name定义在左侧时，mysql是按照name进行排序的，所以可以看出索引项是按照索引定义里面出现的字段顺序排序的。当查找张三的时候，会定位到ID4，此时从ID4往右侧依次遍历，直到name不是张三，则得到name为张三的所有结果。</li><li>若查询姓张的依旧可以使用上述的规则，找到姓张的使用<code>like 张%</code>，定位到ID3，此时从ID3往右侧依次遍历，直到name不是张打头，则得到name为姓张的所有结果。可以看到，不只是索引的全部定义，只要满足最左前缀，就可以利用索引来加速检索。</li><li>知道了最左前缀的用处，那如何<strong>安排联合索引的字段顺序</strong>呢？<ul><li>增强索引的复用能力，一般最左侧的字段就不需要为其单独的建立索引的，而是根据需求建立其他字段的索引。所以<strong>第一原则</strong>是：如果通过调整顺序，可以少维护一个索引，那么这个顺序往往就是需要优先考虑采用的。例如<code>(a,b)</code>联合，a就不需要单独创建索引，而b是需要的，因为b是利用不上这个联合索引的。</li></ul></li></ul><h1 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h1><ul><li>继最左前缀原则后，若要查询姓张且是男生的话，就需要这样写 <code>select * from T where name like &#39;张%&#39; and ismale=1 ;</code>，这条语句的like中依旧利用了最左前缀原则，但是还有性别的判断条件，难道还要通过回表来查询是否为男性吗？mysql后加入的针对此问题的优化叫做索引下推，mysql在定位到张姓开头的时候，会自动的判断 <code>ismale</code> 字段，过滤掉不必要的回表操作。</li></ul><center><p><img src="/img/mysql/index-get.png" alt="picture 3">  </p></center>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;常用索引模型&quot;&gt;&lt;a href=&quot;#常用索引模型&quot; class=&quot;headerlink&quot; title=&quot;常用索引模型&quot;&gt;&lt;/a&gt;常用索引模型&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;哈希表：既然涉及到了Hash，则最快的效率一定是直接可以根据Hash进行定位。但是难免会有冲突的</summary>
      
    
    
    
    <category term="MySQL" scheme="https://ohbug.cn/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="https://ohbug.cn/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：字符与字节流</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava7.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava7.html</id>
    <published>2023-02-04T01:20:15.000Z</published>
    <updated>2023-02-18T10:38:20.288Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://juejin.cn/post/6844903993844432909">https://juejin.cn/post/6844903993844432909</a></p></blockquote><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>基本常识是: 一般读写文件需要两次数据复制，比如读文件，需要先从硬盘复制到操作系统内核，再从内核复制到应用程序分配的内存中。操作系统运行所在的环境和应用程序是不一样的，操作系统所在的环境是内核态，应用程序是用户态，应用程序调用操作系统的功能，需要两次环境的切换，先从用户态切到内核态，再从内核态切到用户态。这种用户态&#x2F;内核态的切换是有开销的，应尽量减少这种切换。为提升效率可以使用缓冲区。</p></blockquote><center><p><img src="/img/java/basicjava7-io.png" alt="picture 1">  </p></center><h1 id="流分类"><a href="#流分类" class="headerlink" title="流分类"></a>流分类</h1><ul><li>基本分与三类，首先适用于读写二进制形式的流为 inputStream&#x2F;outputStream 类，适用于读写文字内容的 reader&#x2F;writer 类。还有网络IO的 Socket 类。</li></ul><h1 id="二进制文件和字节流"><a href="#二进制文件和字节流" class="headerlink" title="二进制文件和字节流"></a>二进制文件和字节流</h1><h2 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h2><ul><li>这是二进制文件字节流的基类，是抽象类</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 读方法，返回0到255，如果因为读到末尾后导致的无信息可读返回 -1 . 否则就一直阻塞到有信息可读为止public abstract int read() throws IOException;&#x2F;&#x2F; 返回流中不阻塞的字节的估计大小public int available() throws IOException &#123;...&#125;&#x2F;&#x2F; 跳读，public long skip(long n) throws IOException &#123;...&#125;&#x2F;&#x2F; 回头读，但不是每个实现类都可以实现回头重读，需要先通过markSupported方法测试后才可以知道&#x2F;&#x2F; mark 先标记一处，往下读后调用reset即可回到mark位置。readlimit表示从mark处最多往后读多少字节，&#x2F;&#x2F; 若往后超了，则mark位置失效。public synchronized void mark(int readlimit) &#123;&#125;public synchronized void reset() throws IOException &#123;...&#125;public boolean markSupported() &#123;...&#125;public void close() throws IOException &#123;&#125;&#x2F;&#x2F; java 9中加入的默认实现，里面用到了一个Buffer数组，默认DEFAULT_BUFFER_SIZE是8192字节。public long transferTo(OutputStream out) throws IOException &#123;...&#125;...</code></pre><h2 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h2><ul><li>close 之前一般先调用flush，但每个子类的flush有些不同，需要分别对待。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract void write(int b) throws IOException;public void flush() throws IOException &#123; &#x2F;* NULL *&#x2F; &#125;public void close() throws IOException &#123; &#x2F;* NULL *&#x2F; &#125;...</code></pre><h2 id="FileIn-x2F-FileOut"><a href="#FileIn-x2F-FileOut" class="headerlink" title="FileIn&#x2F;FileOut"></a>FileIn&#x2F;FileOut</h2><ul><li><p>输入源和输出目标是文件的流。</p></li><li><p>FileOutputStream 没有缓冲，没有重写flush方法，调用fush方法没有任何效果，即调用的 OutputStream 的空方法 ，数据只是传递给了操作系统，但操作系统什么时候保存到硬盘上，这是不一定的。要确保数据保存到了硬盘上，可以调用FileOutputStream中的特有方法 sync</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 同步仅影响此文件描述符下游的缓冲区。&#x2F;&#x2F; 若想sync有效，则必须首先调用flush刷新，将缓存刷新到系统后，再sync，系统才会同步到磁盘。然后数据才会受到同步的影响。new FileOutputStream(&quot;out.txt&quot;).getFD().sync();</code></pre><ul><li>flush方法只能将应用程序缓冲的数据写到操作系统，sync方法则确保数据写到硬盘，不过一般情况下，我们并不需要手工调用它，只要操作系统和硬件设备没问题，数据迟早会写入。</li></ul><h3 id="基本使用"><a href="#基本使用" class="headerlink" title="基本使用"></a>基本使用</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">FileInputStream inputStream &#x3D; new FileInputStream(&quot;sourceFile&quot;);FileOutputStream targetFile &#x3D; new FileOutputStream(&quot;targetFile&quot;);int length;byte[] buffer &#x3D; new byte[4];while ((length&#x3D; inputStream.read(buffer))!&#x3D;-1)&#123;    targetFile.write(buffer, 0 , length);&#125;inputStream.close();targetFile.close();</code></pre><h2 id="其他基本类似，略"><a href="#其他基本类似，略" class="headerlink" title="其他基本类似，略"></a>其他基本类似，略</h2><ul><li>ByteArrayInputStream&#x2F;ByteArrayOutputStream: 输入源和输出目标是字节数组的流</li><li>DataInputStream&#x2F;DataOutputStream: 装饰类，按基本类型和字符串而非只是字节读写流。</li><li>BufferedInputStream&#x2F;BufferedOutputStream: 装饰类，对输入输出流提供缓冲功能。</li></ul><h1 id="文本字符流"><a href="#文本字符流" class="headerlink" title="文本字符流"></a>文本字符流</h1><h2 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h2><ul><li>utf-8：英文和数字字符每个占一个字节，而每个中文占三个字节。</li><li>gb18030：英文和数字字符每个占一个字节，而每个中文占2个字节。</li><li>utf-16be：无论是英文还是中文字符，每个字符都占两人字节。UTF-16BE也是<strong>Java内存中对字符的编码方式</strong>。</li></ul><h2 id="基本类"><a href="#基本类" class="headerlink" title="基本类"></a>基本类</h2><ul><li>Reader&#x2F;Writer: 字符流的基类，它们是抽象类。</li><li>FileReader&#x2F;FileWriter: 输入源和输出目标是文件的字符流。</li><li>CharArrayReader&#x2F;CharArrayWriter: 输入源和输出目标是char数组的字符流。</li><li>StringReader&#x2F;StringWriter: 输入源和输出目标是String的字符流。</li><li>BufferedReader&#x2F;BufferedWriter: 装饰类，对输入&#x2F;输出流提供缓冲，以及按行读写功能。</li><li>PrintWriter: 装饰类，可将基本类型和对象转换为其字符串形式输出的类。</li><li>InputStreamReader&#x2F;OutputStreamWriter: 适配器类，将字节流转换为字符流。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">try(        FileReader in &#x3D; new FileReader(&quot;sourceFile&quot;, Charset.forName(&quot;utf-8&quot;));        BufferedReader reader &#x3D; new BufferedReader(in);        PrintStream writer &#x3D; new PrintStream(&quot;target&quot;, Charset.forName(&quot;utf-8&quot;));    )&#123;    while (reader.ready()) &#123;        writer.println(reader.readLine());    &#125;&#125;catch (IOException e) &#123;    e.printStackTrace();&#125;</code></pre><ul><li><p>FileReader&#x2F;FileWriter是没有缓冲的，也不能按行读写，所以，一般应该在它们的外面包上对应的缓冲类。</p></li><li><p><strong>总结：</strong>写文件时，可以优先考虑PrintWriter，因为它使用方便，支持自动缓冲、指定编码类型、类型转换等。</p></li><li><p>如果指定编码类型，需要使用InputStreamReader; 如果不需要，可使用FileReader，但都应该考虑在外面包上缓冲类BufferedReader。</p></li></ul><h1 id="字符与字节的区别"><a href="#字符与字节的区别" class="headerlink" title="字符与字节的区别"></a>字符与字节的区别</h1><ul><li>字节流是按字节读取的，而字符流则是按char读取的，一个char在文件中保存的是几个字节与编码有关，但字符流封装了这种细节，我们操作的对象就是char。</li><li>一个char不完全等同于一个字符，对于绝大部分字符，一个字符就是一个char，根据utf-16be编码不同，对于增补字符集中的字符，需要两个char表示，对于这种字符，Java中的字符流是按char而不是一个完整字符处理的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：I/O 原理与模型</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava8.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava8.html</id>
    <published>2023-02-04T01:20:15.000Z</published>
    <updated>2023-02-18T10:38:17.428Z</updated>
    
    <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>《Java高并发核心编程 卷一》</p></blockquote><h1 id="底层原理"><a href="#底层原理" class="headerlink" title="底层原理"></a>底层原理</h1><h2 id="IO读写原理"><a href="#IO读写原理" class="headerlink" title="IO读写原理"></a>IO读写原理</h2><ul><li>为了避免用户进程直接操作内核，保证内核安全，操作系统将内存(虚拟内存)划分为两部分：一部分是内核空间 (KernelSpace)，另一部分是用户空间(User-Space)。在Linux系统中，内核模块运行在内核空间，对应的进程处于内核态;用户程序运行在用户空间，对应的进程处于用户态。</li></ul><ul><li>位于用户态的进程不可以直接访问硬件资源或系统调用，而内核态的进程是可以的，若用户态想进行系统调用，则用户态进程必须通过系统调用 (System Ca11)向内核发出指令，完成调用系统资源之类的操作。。</li></ul><ul><li>用户的IO操作都是基于系统的read和write两大系统调用，操作系统层面的read系统调用并不是直接从物理设备把数据读取到应用的内存中，write系统调用也不是直接把数据写入物理设备。上层应用无论是调用操作系统的read还是调用操作系统的write都会涉及缓冲区。具体来说，上层应用通过操作系统的read系统调用把数据从内核缓冲区复制到应用程序的进程缓冲区，通过操作系统的write系统调用把数据从应用程序的进程缓冲区复制到操作系统的内核缓冲区。即应用程序的IO操作实际上不是物理设备级别的读写而是缓存的复制。read和write两大系统调用都不负责数据在内核缓冲区和物理设备之间的交换。这个底层的读写交换操作是由操作系统内核(Kernel) 来完成的。所以，在应用程序中，无论是对socket的IO操作还是对文件的IO操作，都属于上层应用的开发，它们在输入 (Input) 和输出 (Output) 维度上的执行流程是类似的，都是在内核缓冲区和进程缓冲区之间进行数据交换。</li></ul><h2 id="内存缓冲区和进程缓冲区"><a href="#内存缓冲区和进程缓冲区" class="headerlink" title="内存缓冲区和进程缓冲区"></a>内存缓冲区和进程缓冲区</h2><ul><li>缓冲区的目的是减少与设备之间的频繁物理交换。操作系统会对内核缓冲区进行监控，等待缓冲区达到一定数量的时候，再进行IO设备的中断处理，集中执行物理设备的实际IO操作通过这种机制来提升系统的性能。至于具体什么时候执行系统中断(包括读中断、写中断)则由操作系统的内核来决定，应用程序不需要关心。</li></ul><ul><li>上层应用使用read系统调用时，仅仅把数据从内核缓冲区复制到应用的缓冲区(进程缓冲区);上层应用使用write系统调用时，仅仅把数据从应用的缓冲区复制到内核缓冲区。</li></ul><h1 id="IO模型"><a href="#IO模型" class="headerlink" title="IO模型"></a>IO模型</h1><h2 id="同步阻塞IO"><a href="#同步阻塞IO" class="headerlink" title="同步阻塞IO"></a>同步阻塞IO</h2><p><img src="/img/java/IO1.png" alt="picture 1">  </p><ul><li>同步阻塞IO(Blocking I0) 指的是用户空间(或者线程)主动发起，需要等待内核I0操作彻底完成后才返回到用户空间的IO操作。在IO操作过程中，发起I0请求的用户进程(或者线程) 处于阻塞状态。</li></ul><h2 id="同步非阻塞"><a href="#同步非阻塞" class="headerlink" title="同步非阻塞"></a>同步非阻塞</h2><p><img src="/img/java/IO2.png" alt="picture 1">  </p><ul><li>同步非阻塞I0指的是用户进程主动发起，不需要等待内核IO操作彻底完成就能立即返回用户空间的IO操作。在I0操作过程中，发起IO请求的用户进程(或者线程) 处于非阻塞状态。</li><li>一旦开始IO调用，会发生两种情况<ol><li>在内核缓冲区中没有数据的情况下，系统调用会立即返回个调用失败的信息。</li><li>在内核缓冲区中有数据的情况下，在数据的复制过程中系统调用是阻塞的，直到完成数据从内核缓冲区复制到用户缓冲区。复制完成后，系统调用返回成功，用户进程(或者线程) 可以开始处理用户空间的缓冲区数据。</li></ol></li></ul><ul><li>非阻塞的实现也是基于不断的轮询查询内核状态，虽然每次查询不阻塞了，但是消耗也是非常大的。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>同步非阻塞IO也可以简称为NIO，但是它不是Java编程中的NI0。Java编程中的NIO 类库组件所归属的不是基础IO模型中的NIO模型，而是IO多路复用模型。</p></blockquote><h2 id="IO多路复用"><a href="#IO多路复用" class="headerlink" title="IO多路复用"></a>IO多路复用</h2><p><img src="/img/java/IO3.png" alt="picture 3">  </p><ul><li>为了提高性能，操作系统引入了一种新的系统调用，专门用于查询I0文件描述符(含socket连接)的就绪状态。在Linux系统中，新的系统调用为select&#x2F;epoll系统调用。通过该系统调用，一个用户进程或者线程)可以监视多个文件描述符，一旦某个描述符就绪 (一般是内核缓冲区可读&#x2F;可写)，内核就能够将文件描述符的就绪状态返回给用户进程(或者线程)，用户空间可以根据文件描述符的就绪状态进行相应的IO系统调用。</li><li>IO多路复用解决了同步非阻塞的轮询问题，目前支持I0多路复用的系统调用有select、epoll等。几乎所有的操作系统都支持select系统调用，它具有良好的跨平台特性。epoll是在Linux 2.6内核中提出的，是select系统调用的Linux增强版本。</li><li>IO多路复用是从轮询内核发展到轮询socket网络连接，有IO就绪状态时就返回这些就绪的状态。</li></ul><ul><li>I0多路复用模型建立在操作系统的基础设施之上，即操作系统的内核必须能够提供多路分离的系统调用select&#x2F;epoll。</li></ul><ul><li>通过JDK的源码可以看出，Java语言的NIO组件在Linux系统上是使用epo11系统调用实现的。所以，Java语言的NIO组件所使用的就是IO多路复用模型。</li><li>优点：一个选择器查询线程可以同时处理成于上万的网络连接，不必创建大量的线程，也不必维护这些线程，从而大大减少了系统的开销。与一个线程维护一个连接的阻塞I0模式相比，这一点是I0多路复用模型的最大优势。</li><li>缺点：本质上select&#x2F;epoll系统调用是阻塞式的，属于同步IO，需要在读写事件就绪后由系统调用本身负责读写，也就是说这个读写过程是阻塞的。要彻底地解除线程的阻塞，就必须使用异步IO模型。</li></ul><h2 id="异步IO"><a href="#异步IO" class="headerlink" title="异步IO"></a>异步IO</h2><p><img src="/img/java/IO4.png" alt="picture 4">  </p><ul><li>异步IO(Asynchronous IO，AIO) 指的是用户空间的线程变成被动接收者，而内核空间成为主动调用者。在异步I0模型中，当用户线程收到通知时，数据已经被内核读取完毕并放在了用户缓冲区内，内核在I0完成后通知用户线程直接使用即可，在整个内核的数据处理中都不需要用户阻塞。</li></ul><ul><li>流程：用户发出read后立刻可以去做其他事情，当有IO请求时，内核负责准备数据，并且把数据拷贝到用户缓冲区后回调用户注册的函数后，用户开始IO操作。</li></ul><div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>Linux操作系统中文件句柄数的限制。在生产环境Linux系统中，基本上都需要解除文件句柄数的限制。原因是Linux系统的默认值为1024，也就是说，一个进程最多可以接受1024个socket连接，这是远远不够的。修改方式如下</p><ul><li>修改 <code>/etc/security/limits.conf</code></li></ul><pre class="line-numbers language-conf" data-language="conf"><code class="language-conf">; soft nofile表示软性极限，hard nofile表示硬性极限。; 硬性极限值是实际的限制，就是最大可以是100万，不能再多了。; 软性极限值则是系统发出警告 (Warning)的极限值，超过这个极限值，内核会发出警告。soft nofile 1000000 ;hard nofile 1000000 ;</code></pre></div>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;span class=&quot;custom-blockquote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; d</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Redis复习：基本命令</title>
    <link href="https://ohbug.cn/post/redis/basic-redis1.html"/>
    <id>https://ohbug.cn/post/redis/basic-redis1.html</id>
    <published>2023-02-03T04:17:32.000Z</published>
    <updated>2023-02-03T12:03:17.352Z</updated>
    
    <content type="html"><![CDATA[<h1 id="特性"><a href="#特性" class="headerlink" title="特性"></a>特性</h1><ul><li>键值 (key-value)型，value支持多种不同数据结构，功能丰富。</li><li>单线程，每个命令具备原子性。</li><li>低延迟，速度快(基于内存、10多路复用、良好的编码)。</li><li>支持数据持久化。</li><li>支持主从集群、分片集群。</li></ul><h1 id="登入"><a href="#登入" class="headerlink" title="登入"></a>登入</h1><ul><li><code>redis-cli -h host -p port -a password</code>，登入成功后，输入ping，后返回pong。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.redis.com.cn/redis-keys.html">https://www.redis.com.cn/redis-keys.html</a><br><a href="https://redis.io/docs/data-types/">https://redis.io/docs/data-types/</a></p></blockquote><h1 id="基础命令"><a href="#基础命令" class="headerlink" title="基础命令"></a>基础命令</h1><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 除了以下命令，还有好多命令参考上面文档127.0.0.1:6379&gt; mset k1 v1 k2 v2 k3 v3OK-- KEYS:查看符合模板的所有key，不建议在生产环境设备上使用  : keys [正则]127.0.0.1:6379&gt; keys *1) &quot;k1&quot;2) &quot;k3&quot;3) &quot;k2&quot;127.0.0.1:6379&gt; keys *11) &quot;k1&quot;127.0.0.1:6379&gt; keys k*1) &quot;k1&quot;2) &quot;k3&quot;3) &quot;k2&quot;-- DEL:删除一个指定的key : del [key...]127.0.0.1:6379&gt; del k1(integer) 1127.0.0.1:6379&gt; keys *1) &quot;k3&quot;2) &quot;k2&quot;-- EXISTS:判断key是否存在，0不存在，1存在127.0.0.1:6379&gt; EXISTS k1(integer) 0127.0.0.1:6379&gt; EXISTS k2(integer) 1-- TTL:查看一个KEY的剩余有效期，被删除-2，若永久返回-1127.0.0.1:6379&gt; TTL k1(integer) -2127.0.0.1:6379&gt; TTL k2(integer) -1-- EXPIRE:给一个key设置有效期，有效期到期时该key会被自动删除，设置k2在20秒后过期127.0.0.1:6379&gt; EXPIRE k2 20(integer) 1127.0.0.1:6379&gt; TTL k2 -- 剩余13秒 (integer) 13127.0.0.1:6379&gt; TTL k2-- 剩余5秒 (integer) 5-- 过期被删除127.0.0.1:6379&gt; TTL k2(integer) -2</code></pre><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><ul><li>Redis字符串存储字节序列，包括文本、序列化对象和二进制数组。它们通常用于缓存，但它们支持额外的功能，允许实现计数器并执行按位操作。</li><li>最大不超过512MB。</li><li>大部分操作都是O(1)操作，但是一些随机命令可能会达到O(n)级别。比如 <code>SUBSTR</code>, <code>GETRANGE</code>,  <code>SETRANGE</code></li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- SET设置指定 key 的值-- GET获取指定 key 的值127.0.0.1:6379&gt; set name qidaiOK127.0.0.1:6379&gt; get name&quot;qidai&quot;-- GETRANGE返回 key 中字符串值的子字符127.0.0.1:6379&gt; GETRANGE name 0 2&quot;qid&quot;-- SETRANGE从偏移量 offset 开始用 value 覆写给定 key 所储存的字符串值127.0.0.1:6379&gt; SETRANGE name 1 ohbug(integer) 6127.0.0.1:6379&gt; get name&quot;qohbug&quot;-- SETEX设置 key 的值为 value 同时将过期时间设为 seconds127.0.0.1:6379&gt; SETEX name 20 oooOK127.0.0.1:6379&gt; get name&quot;ooo&quot;127.0.0.1:6379&gt; ttl name(integer) 12127.0.0.1:6379&gt; ttl name(integer) 11-- SETNX只有在 key 不存在时设置 key 的值127.0.0.1:6379&gt; set name qidaiOK127.0.0.1:6379&gt; SETNX name ohbug(integer) 0127.0.0.1:6379&gt; get name&quot;qidai&quot;-- STRLEN返回 key 所储存的字符串值的长度127.0.0.1:6379&gt; STRLEN name(integer) 5-- INCR将 key 中储存的数字值增一-- INCRBY将 key 所储存的值加上给定的增量值 ( increment )127.0.0.1:6379&gt; set age 1OK127.0.0.1:6379&gt; get age&quot;1&quot;127.0.0.1:6379&gt; INCR age(integer) 2127.0.0.1:6379&gt; get age&quot;2&quot;127.0.0.1:6379&gt; INCRBY age 5   -- 每次加五(integer) 7127.0.0.1:6379&gt; get age&quot;7&quot;</code></pre><h1 id="key-结构"><a href="#key-结构" class="headerlink" title="key 结构"></a>key 结构</h1><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 设置一个key名为name，值为qidaiset name qidai-- 为了区分name，那么可以使用前缀方式，分隔符为分号 :  ，-- 类似于分表操作127.0.0.1:6379&gt; set ohbug:src:name qidaiOK127.0.0.1:6379&gt; set ohbug:cls:name red22OK127.0.0.1:6379&gt; set name qidaiOK127.0.0.1:6379&gt; keys *1) &quot;ohbug:src:name&quot;3) &quot;ohbug:cls:name&quot;4) &quot;name&quot;127.0.0.1:6379&gt; get ohbug:src:name&quot;qidai&quot;127.0.0.1:6379&gt; get ohbug:cls:name&quot;red22&quot;127.0.0.1:6379&gt; get name&quot;qidai&quot;</code></pre><ul><li>命令行看不出啥，来看看图形界面。明显看出单独的name和其他有限定的name的不同。</li></ul><p><img src="/img/redis/redis-keystruct.png" alt="picture 1">  </p><h1 id="Lists"><a href="#Lists" class="headerlink" title="Lists"></a>Lists</h1><ul><li>基于链表实现，可以用来实现堆栈和队列，以及为后台工作系统构建队列管理。</li><li>最长长度限制 ： 2^{32} -1</li><li>由于是基于链表实现，所以对头尾操作是O(1)，而对于某些插入命令，设值LSET复杂度是O(n)的。</li></ul><p><img src="/img/redis/redis-lists.png" alt="picture 2">  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- BLPOP移出并获取列表的第一个元素，如果列表内为空，则阻塞-- BLMOVE 将一个元素移入另一个list中，如果原list中为空，则阻塞-- BRPOP移出并获取列表的最后一个元素-- LINDEX通过索引获取列表中的元素-- LINSERT在列表的元素前或者后插入元素-- LLEN获取列表长度-- LPOP移出并获取列表的第一个元素-- LPUSH将一个或多个值插入到列表头部-- RPUSH在列表中添加一个或多个值-- RPUSHX为已存在的列表添加值-- LREM移除列表元素-- LSET通过索引设置列表元素的值-- LTRIM对一个列表进行修剪(trim)-- RPOP移除并获取列表最后一个元素-- LPUSHX将一个值插入到已存在的列表头部-- BRPOPLPUSH从列表中弹出一个值，并将该值插入到另外一个列表中并返回它-- RPOPLPUSH移除列表的最后一个元素，并将该元素添加到另一个列表并返回</code></pre><h1 id="Sets"><a href="#Sets" class="headerlink" title="Sets"></a>Sets</h1><ul><li>无序且元素唯一，可用于跟踪记录唯一的元素，比如IP地址，执行常见的集合操作，如交集、并集和差集。</li><li>可用于查找共同好友之类的操作。</li><li>最多2^32-1 个元素。</li><li>大部分命令都是<code>O(1)</code>级别，但是对于元素多的时候，要当心  <code>SMEMBERS</code> 操作，这个操作的级别是<code>O(n)</code>级别，它会返回所有set元素。作为替换操作，可以考虑 <code>SSCAN</code>  ，<code>SSCAN</code> 允许迭代地检索集合的所有成员。</li></ul><p><img src="/img/redis/redis-sets.png" alt="picture 3">  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- SADD向集合添加一个或多个成员-- SCARD获取集合的成员数-- SDIFF返回给定所有集合的差集-- SDIFFSTORE返回给定所有集合的差集并存储在 destination 中-- SINTER返回给定所有集合的交集-- SINTERSTORE返回给定所有集合的交集并存储在 destination 中-- SISMEMBER判断 member 元素是否是集合 key 的成员-- SMEMBERS返回集合中的所有成员-- SMOVE将 member 元素从 source 集合移动到 destination 集合-- SPOP移除并返回集合中的一个随机元素-- SRANDMEMBER返回集合中一个或多个随机数-- SREM移除集合中一个或多个成员-- SUNION返回所有给定集合的并集-- SUNIONSTORE所有给定集合的并集存储在 destination 集合中-- SSCAN迭代集合中的元素</code></pre><h1 id="Sorted-Sets"><a href="#Sorted-Sets" class="headerlink" title="Sorted Sets"></a>Sorted Sets</h1><ul><li>string 类型元素的集合，且不允许重复的成员，每个元素都会关联一个名为score的 double 类型的分数，根据score进行排序。</li><li>通过哈希表实现的，所以添加，删除，查找的复杂度都是 O(1)。但大部分是logn级别的复杂度</li><li>可用于排名应用，可取出前几名，后几名，中间几名。</li><li>默认range返回的是根据score返回的升序。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">127.0.0.1:6379&gt; zadd math 100 qidai(integer) 1127.0.0.1:6379&gt; zadd math 12 liming(integer) 1127.0.0.1:6379&gt; zadd math 23 xiaohong(integer) 1127.0.0.1:6379&gt; ZADD math 66 zhangsan(integer) 1127.0.0.1:6379&gt; ZRANGE math 0 11) &quot;liming&quot;2) &quot;xiaohong&quot;127.0.0.1:6379&gt; ZRANGE math 0 1 withscores1) &quot;liming&quot;2) &quot;12&quot;3) &quot;xiaohong&quot;4) &quot;23&quot;-- ZADD向有序集合添加一个或多个成员，或者更新已存在成员的分数-- ZCARD获取有序集合的成员数-- ZCOUNT计算在有序集合中指定区间分数的成员数-- ZINCRBY有序集合中对指定成员的分数加上增量 increment-- ZINTERSTORE计算给定的一个或多个有序集的交集并将结果集存储在新的有序集合 key 中-- ZLEXCOUNT在有序集合中计算指定字典区间内成员数量-- ZRANGE通过索引区间返回有序集合成指定区间内的成员-- ZRANGEBYLEX通过字典区间返回有序集合的成员-- ZRANGEBYSCORE通过分数返回有序集合指定区间内的成员-- ZRANK返回有序集合中指定成员的索引-- ZREM移除有序集合中的一个或多个成员-- ZREMRANGEBYLEX移除有序集合中给定的字典区间的所有成员-- ZREMRANGEBYRANK移除有序集合中给定的排名区间的所有成员-- ZREMRANGEBYSCORE移除有序集合中给定的分数区间的所有成员-- ZREVRANGE返回有序集中指定区间内的成员，通过索引，分数从高到底-- ZREVRANGEBYSCORE返回有序集中指定分数区间内的成员，分数从高到低排序-- ZREVRANK返回有序集合中指定成员的排名，有序集成员按分数值递减(从大到小)排序-- ZSCORE返回有序集中，成员的分数值-- ZUNIONSTORE计算一个或多个有序集的并集，并存储在新的 key 中-- ZSCAN迭代有序集合中的元素（包括元素成员和元素分值）</code></pre><h1 id="Hashes"><a href="#Hashes" class="headerlink" title="Hashes"></a>Hashes</h1><ul><li>结构为key - (file-value)，即一个key标识一个file-value对。适用存储对象。</li><li>大部分操作时间复杂度是O(1)，其中 <code>HKEYS</code>, <code>HVALS</code>, <code>HGETALL</code> 是O(n) 级别。</li><li>例如：<code> hset user name qidai sex man age 12</code>，则结构如下图</li></ul><p><img src="/img/redis/redis-hash.png" alt="picture 4">  </p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- HDEL删除一个或多个哈希表字段-- HEXISTS查看哈希表 key 中，指定的字段是否存在-- HGET获取存储在哈希表中指定字段的值-- HGETALL获取在哈希表中指定 key 的所有字段和值-- HINCRBY为哈希表 key 中的指定字段的整数值加上增量 increment-- HINCRBYFLOAT为哈希表 key 中的指定字段的浮点数值加上增量 increment-- HKEYS获取所有哈希表中的字段-- HLEN获取哈希表中字段的数量-- HMGET获取所有给定字段的值-- HMSET同时将多个 field-value (域-值)对设置到哈希表 key 中-- HSET将哈希表 key 中的字段 field 的值设为 value-- HSETNX只有在字段 field 不存在时，设置哈希表字段的值-- HVALS获取哈希表中所有值-- HSCAN迭代哈希表中的键值对-- HSTRLEN返回哈希表 key 中， 与给定域 field 相关联的值的字符串长度</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;特性&quot;&gt;&lt;a href=&quot;#特性&quot; class=&quot;headerlink&quot; title=&quot;特性&quot;&gt;&lt;/a&gt;特性&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;键值 (key-value)型，value支持多种不同数据结构，功能丰富。&lt;/li&gt;
&lt;li&gt;单线程，每个命令具备原子性。&lt;/l</summary>
      
    
    
    
    <category term="redis" scheme="https://ohbug.cn/categories/redis/"/>
    
    
    <category term="redis" scheme="https://ohbug.cn/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>红黑树 VS AVL</title>
    <link href="https://ohbug.cn/post/datastructure/redblacktree-avl.html"/>
    <id>https://ohbug.cn/post/datastructure/redblacktree-avl.html</id>
    <published>2023-02-02T02:07:00.000Z</published>
    <updated>2023-02-02T10:09:48.370Z</updated>
    
    <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://zhuanlan.zhihu.com/p/95892351">https://zhuanlan.zhihu.com/p/95892351</a><br><a href="https://www.bilibili.com/video/BV1xG4y1b7Zu/?spm_id_from=333.788.recommend_more_video.5&vd_source=e1294f8209fc39ec6e458c23cce6613f">https://www.bilibili.com/video/BV1xG4y1b7Zu/?spm_id_from=333.788.recommend_more_video.5&amp;vd_source=e1294f8209fc39ec6e458c23cce6613f</a></p></blockquote><ul><li>BST搜索树：左小右大，在元素基本有序时，插入操作可能将树形结构变成链表结构。此时复杂度并未降低，为改善这个情况，引入了AVL平衡二叉树。</li></ul><h1 id="平衡二叉树-AVL"><a href="#平衡二叉树-AVL" class="headerlink" title="平衡二叉树 AVL"></a>平衡二叉树 AVL</h1><ol><li>树上任一结点的左子树和右子树的高度之差不超过1。</li><li>结点的平衡因子=左子树高-右子树高。各个节点的平衡因子绝对值不超过1。</li></ol><h2 id="调整"><a href="#调整" class="headerlink" title="调整"></a>调整</h2><ul><li>因为要保证每一个节点的平衡因子绝对值都不超过1，则在插入时就需要进行频繁的二叉树节点的调整。</li></ul><h3 id="LL右"><a href="#LL右" class="headerlink" title="LL右"></a>LL右</h3><ul><li>在发生不平衡节点A的左侧的左侧插入导致的，即将不平衡节点的左子树B进行右旋，剩余节点进行有序插入即可。</li></ul><p><img src="/img/datastructure/avl-llr.png">  </p><h3 id="RR左"><a href="#RR左" class="headerlink" title="RR左"></a>RR左</h3><ul><li>在发生不平衡节点A的右侧的右侧插入导致的，即将不平衡节点的右子树B进行左旋，剩余节点进行有序插入即可。</li></ul><p><img src="/img/datastructure/avl-rrl.png">  </p><h3 id="LR左右"><a href="#LR左右" class="headerlink" title="LR左右"></a>LR左右</h3><ul><li>在发生不平衡节点A的左侧的右侧插入导致的，即将不平衡节点的左子树B进行左旋，再将整体右旋，剩余节点进行有序插入即可。</li></ul><p><img src="/img/datastructure/avl-lrlr.png">  </p><h3 id="RL右左"><a href="#RL右左" class="headerlink" title="RL右左"></a>RL右左</h3><ul><li>在发生不平衡节点A的右侧的左侧插入导致的，即将不平衡节点的右子树B进行右旋，再将整体左旋，剩余节点进行有序插入即可。</li></ul><p><img src="/img/datastructure/avl-rlrl.png">  </p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><ul><li>查找效率优秀：若树高为h，查找一个关键字最多需要对比h次，即时间复杂度不可能超过o(h)。含有n个结点的平衡二叉树的最大深度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.123ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4032.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2588.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2755.2,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g><g data-mml-node="mo" transform="translate(3643.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，平衡二叉树的平均查找长度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="9.123ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4032.2 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2588.6,0)"><path data-c="2061" d=""></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(2755.2,0)"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g><g data-mml-node="mo" transform="translate(3643.2,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>，即为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.357ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3251.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2862.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 的时间复杂度。</li><li>修改结构频繁：若大部分的插入删除操作总是打破平衡节点为1的限制，那么AVL树就会一直调整，这样开销会很大。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>既然AVL查找优秀，但是删除操作时有限制，那么将限制放松一些，则规则就开始与红黑树类似了。</p></blockquote><h1 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h1><p><img src="/img/datastructure/redblacktree2.png">  </p><ul><li>节点有红色和黑色两种</li><li>根节点一定是黑色的，若调整后根节点为红色，则需要变黑。</li><li>叶子节点规定（nil节点）都是黑色的。</li><li>不能有连续的红色节点，红色节点的子节点必须是黑色节点。</li><li>从同一个节点出发，此节点到叶子节点所经过的所有路径上的黑色节点数相同。</li></ul><h2 id="复杂度"><a href="#复杂度" class="headerlink" title="复杂度"></a>复杂度</h2><ul><li>由于红黑树是由红节点+黑节点构成，记作红节点数为R，黑节点数为B。则总数n=R+B。若此时先忽略红节点树，则只剩黑节点数，由于每条路径上的黑节点书都是相同的，则此时就退化成了一个AVL树，AVL树的复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.151ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3160.7 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2771.7,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> ，再将红节点数添加回来，此时红节点最多添加B个，即红黑交错的时候，红节点是最多的。此时红节点数的复杂度与黑节点数的复杂度相同，则此时整个红黑树的复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="10.419ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 4605.1 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1444.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(1929.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(2318.4,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D435" d="M231 637Q204 637 199 638T194 649Q194 676 205 682Q206 683 335 683Q594 683 608 681Q671 671 713 636T756 544Q756 480 698 429T565 360L555 357Q619 348 660 311T702 219Q702 146 630 78T453 1Q446 0 242 0Q42 0 39 2Q35 5 35 10Q35 17 37 24Q42 43 47 45Q51 46 62 46H68Q95 46 128 49Q142 52 147 61Q150 65 219 339T288 628Q288 635 231 637ZM649 544Q649 574 634 600T585 634Q578 636 493 637Q473 637 451 637T416 636H403Q388 635 384 626Q382 622 352 506Q352 503 351 500L320 374H401Q482 374 494 376Q554 386 601 434T649 544ZM595 229Q595 273 572 302T512 336Q506 337 429 337Q311 337 310 336Q310 334 293 263T258 122L240 52Q240 48 252 48T333 46Q422 46 429 47Q491 54 543 105T595 229Z"></path></g></g></g><g data-mml-node="mo" transform="translate(4216.1,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container> 。由于叶子节点都为黑节点，则黑节点的数量最少占整个树节点数量的一半，则假设此时黑节点的数量最少占整个树节点数量的一半，即 B = N/2 ，则此时整个红黑树的复杂度为 <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.946ex;" xmlns="http://www.w3.org/2000/svg" width="12.225ex" height="2.643ex" role="img" focusable="false" viewBox="0 -750 5403.5 1168.1"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mn"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g><g data-mml-node="mo" transform="translate(722.2,0)"><path data-c="2217" d="M229 286Q216 420 216 436Q216 454 240 464Q241 464 245 464T251 465Q263 464 273 456T283 436Q283 419 277 356T270 286L328 328Q384 369 389 372T399 375Q412 375 423 365T435 338Q435 325 425 315Q420 312 357 282T289 250L355 219L425 184Q434 175 434 161Q434 146 425 136T401 125Q393 125 383 131T328 171L270 213Q283 79 283 63Q283 53 276 44T250 35Q231 35 224 44T216 63Q216 80 222 143T229 213L171 171Q115 130 110 127Q106 124 100 124Q87 124 76 134T64 161Q64 166 64 169T67 175T72 181T81 188T94 195T113 204T138 215T170 230T210 250L74 315Q65 324 65 338Q65 353 74 363T98 374Q106 374 116 368T171 328L229 286Z"></path></g><g data-mml-node="mi" transform="translate(1444.4,0)"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(1929.4,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(2318.4,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g><g data-mml-node="TeXAtom" data-mjx-texclass="ORD" transform="translate(888,0)"><g data-mml-node="mo"><path data-c="2F" d="M423 750Q432 750 438 744T444 730Q444 725 271 248T92 -240Q85 -250 75 -250Q68 -250 62 -245T56 -231Q56 -221 230 257T407 740Q411 750 423 750Z"></path></g></g><g data-mml-node="mn" transform="translate(1388,0)"><path data-c="32" d="M109 429Q82 429 66 447T50 491Q50 562 103 614T235 666Q326 666 387 610T449 465Q449 422 429 383T381 315T301 241Q265 210 201 149L142 93L218 92Q375 92 385 97Q392 99 409 186V189H449V186Q448 183 436 95T421 3V0H50V19V31Q50 38 56 46T86 81Q115 113 136 137Q145 147 170 174T204 211T233 244T261 278T284 308T305 340T320 369T333 401T340 431T343 464Q343 527 309 573T212 619Q179 619 154 602T119 569T109 550Q109 549 114 549Q132 549 151 535T170 489Q170 464 154 447T109 429Z"></path></g></g></g><g data-mml-node="mo" transform="translate(5014.5,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>  = <mjx-container class="MathJax" jax="SVG"><svg style="vertical-align: -0.566ex;" xmlns="http://www.w3.org/2000/svg" width="7.357ex" height="2.262ex" role="img" focusable="false" viewBox="0 -750 3251.9 1000"><g stroke="currentColor" fill="currentColor" stroke-width="0" transform="scale(1,-1)"><g data-mml-node="math"><g data-mml-node="mi"><path data-c="1D45C" d="M201 -11Q126 -11 80 38T34 156Q34 221 64 279T146 380Q222 441 301 441Q333 441 341 440Q354 437 367 433T402 417T438 387T464 338T476 268Q476 161 390 75T201 -11ZM121 120Q121 70 147 48T206 26Q250 26 289 58T351 142Q360 163 374 216T388 308Q388 352 370 375Q346 405 306 405Q243 405 195 347Q158 303 140 230T121 120Z"></path></g><g data-mml-node="mo" transform="translate(485,0)"><path data-c="28" d="M94 250Q94 319 104 381T127 488T164 576T202 643T244 695T277 729T302 750H315H319Q333 750 333 741Q333 738 316 720T275 667T226 581T184 443T167 250T184 58T225 -81T274 -167T316 -220T333 -241Q333 -250 318 -250H315H302L274 -226Q180 -141 137 -14T94 250Z"></path></g><g data-mml-node="msub" transform="translate(874,0)"><g data-mml-node="mi"><path data-c="6C" d="M42 46H56Q95 46 103 60V68Q103 77 103 91T103 124T104 167T104 217T104 272T104 329Q104 366 104 407T104 482T104 542T103 586T103 603Q100 622 89 628T44 637H26V660Q26 683 28 683L38 684Q48 685 67 686T104 688Q121 689 141 690T171 693T182 694H185V379Q185 62 186 60Q190 52 198 49Q219 46 247 46H263V0H255L232 1Q209 2 183 2T145 3T107 3T57 1L34 0H26V46H42Z"></path><path data-c="6F" d="M28 214Q28 309 93 378T250 448Q340 448 405 380T471 215Q471 120 407 55T250 -10Q153 -10 91 57T28 214ZM250 30Q372 30 372 193V225V250Q372 272 371 288T364 326T348 362T317 390T268 410Q263 411 252 411Q222 411 195 399Q152 377 139 338T126 246V226Q126 130 145 91Q177 30 250 30Z" transform="translate(278,0)"></path><path data-c="67" d="M329 409Q373 453 429 453Q459 453 472 434T485 396Q485 382 476 371T449 360Q416 360 412 390Q410 404 415 411Q415 412 416 414V415Q388 412 363 393Q355 388 355 386Q355 385 359 381T368 369T379 351T388 325T392 292Q392 230 343 187T222 143Q172 143 123 171Q112 153 112 133Q112 98 138 81Q147 75 155 75T227 73Q311 72 335 67Q396 58 431 26Q470 -13 470 -72Q470 -139 392 -175Q332 -206 250 -206Q167 -206 107 -175Q29 -140 29 -75Q29 -39 50 -15T92 18L103 24Q67 55 67 108Q67 155 96 193Q52 237 52 292Q52 355 102 398T223 442Q274 442 318 416L329 409ZM299 343Q294 371 273 387T221 404Q192 404 171 388T145 343Q142 326 142 292Q142 248 149 227T179 192Q196 182 222 182Q244 182 260 189T283 207T294 227T299 242Q302 258 302 292T299 343ZM403 -75Q403 -50 389 -34T348 -11T299 -2T245 0H218Q151 0 138 -6Q118 -15 107 -34T95 -74Q95 -84 101 -97T122 -127T170 -155T250 -167Q319 -167 361 -139T403 -75Z" transform="translate(778,0)"></path></g><g data-mml-node="TeXAtom" transform="translate(1311,-241.4) scale(0.707)" data-mjx-texclass="ORD"><g data-mml-node="mi"><path data-c="1D441" d="M234 637Q231 637 226 637Q201 637 196 638T191 649Q191 676 202 682Q204 683 299 683Q376 683 387 683T401 677Q612 181 616 168L670 381Q723 592 723 606Q723 633 659 637Q635 637 635 648Q635 650 637 660Q641 676 643 679T653 683Q656 683 684 682T767 680Q817 680 843 681T873 682Q888 682 888 672Q888 650 880 642Q878 637 858 637Q787 633 769 597L620 7Q618 0 599 0Q585 0 582 2Q579 5 453 305L326 604L261 344Q196 88 196 79Q201 46 268 46H278Q284 41 284 38T282 19Q278 6 272 0H259Q228 2 151 2Q123 2 100 2T63 2T46 1Q31 1 31 10Q31 14 34 26T39 40Q41 46 62 46Q130 49 150 85Q154 91 221 362L289 634Q287 635 234 637Z"></path></g></g></g><g data-mml-node="mo" transform="translate(2862.9,0)"><path data-c="29" d="M60 749L64 750Q69 750 74 750H86L114 726Q208 641 251 514T294 250Q294 182 284 119T261 12T224 -76T186 -143T145 -194T113 -227T90 -246Q87 -249 86 -250H74Q66 -250 63 -250T58 -247T55 -238Q56 -237 66 -225Q221 -64 221 250T66 725Q56 737 55 738Q55 746 60 749Z"></path></g></g></g></svg></mjx-container>。</li><li>对比AVL的时间复杂度，整体是相同的，但是还是不及AVL的查找效率，所以红黑树是牺牲了一定的查找效率换来的是结构的更加稳定。这也是<strong>HashMap使用红黑树而不采用AVL的理由</strong>。</li></ul><h2 id="变换规则"><a href="#变换规则" class="headerlink" title="变换规则"></a>变换规则</h2><p><img src="/img/datastructure/redblacktree-cover2.png" alt="picture 7"><br><img src="/img/datastructure/redblacktree-cover.png" alt="picture 6">  </p><h2 id="调整-1"><a href="#调整-1" class="headerlink" title="调整"></a>调整</h2><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.cs.usfca.edu/~galles/visualization/RedBlack.html">https://www.cs.usfca.edu/~galles/visualization/RedBlack.html</a></p></blockquote><ul><li><p>红黑树的插入依旧沿用BST的左小右大原则，只是当到达一定的变化规则时，需要进行不同变化。</p></li><li><p>插入根节点65时直接为黑色。此时一个节点不满足任何变化规则。</p></li><li><p>后插入62，因为62 &lt; 65，所以链接到65的左边。此时62的父节点为黑色，满足<code>无需操作</code>。</p></li><li><p>后插入32，链接到62左侧。此时32的父节点是红色，叔节点是黑色，且32是在左左插入的。满足<code>左左条件</code>，进行右旋+变色调整。此时红色62被提到根节点位置，红色节点62下面是不可以挂红色节点32的，则根节点62与黑色节点65交换颜色。</p></li></ul><p><img src="/img/datastructure/redblacktree3.png" alt="   1">  </p><ul><li><p>后插入33，链接到32的右侧，此时33的父节点32为红色，叔节点65也是红色，满足 <code>父叔32，65都变黑，祖父62变红。祖父62变成当前节点，递归这个规则</code>。祖父变红成当前节点后，由于是根节点必须变黑。</p></li><li><p>后插入50，链接到33的右侧，此时50的父节点33是红色，叔节点null黑色，且相对于32来说为右右插入，满足右右条件，进行<code>左旋再变色</code>。提红色33为父节点，33再与32交换颜色。</p></li></ul><p><img src="/img/datastructure/redblacktree4.png" alt="picture 12">  </p><ul><li>后插入55，链接到50右侧，父节点50黑色，无需操作。</li><li>后插入57，链接到55右侧，父节点55红色，叔节点null黑色，且相对于50来说是右右插入，满足右右条件，进行<code>左旋再变色</code>。操作类似。</li></ul><p><img src="/img/datastructure/redblacktree5.png" alt="picture 13">  </p><ul><li>后插入60，链接到57右侧，父节点57红色，叔节点50红色，满足 <code>父叔57，50都变黑，祖父55变红。祖父55变成当前节点，递归这个规则</code>，55的父节点33是红色，叔节点65是黑色，且相对于62是右右插入，满足左右条件，进行<code>左旋右旋再变色</code>。</li></ul><p><img src="/img/datastructure/redblacktree6.png" alt="picture 14">  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;span class=&quot;custom-blockquote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; d</summary>
      
    
    
    
    <category term="数据结构" scheme="https://ohbug.cn/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
    <category term="红黑树" scheme="https://ohbug.cn/tags/%E7%BA%A2%E9%BB%91%E6%A0%91/"/>
    
    <category term="AVL" scheme="https://ohbug.cn/tags/AVL/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：Map源码实现</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava6.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava6.html</id>
    <published>2023-01-29T01:56:01.000Z</published>
    <updated>2023-02-03T02:26:10.991Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><p><img src="/img/java/CollectionClassMap-Map.png"></p><ul><li>紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。</li><li>下面进行实现类的源码分析，主要是分析其实现类的主要功能。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>对于红黑树的原理可以参考本博客中文章  <a href="datastructure/redblacktree-avl">《红黑树 VS AVL》</a><br><a href="https://www.pdai.tech/md/java/collection/java-map-HashMap&HashSet.html">https://www.pdai.tech/md/java/collection/java-map-HashMap&amp;HashSet.html</a><br><a href="https://www.bilibili.com/video/BV1ST411o7GR/?p=6&spm_id_from=pageDriver&vd_source=e1294f8209fc39ec6e458c23cce6613f">https://www.bilibili.com/video/BV1ST411o7GR/?p=6&amp;spm_id_from=pageDriver&amp;vd_source=e1294f8209fc39ec6e458c23cce6613f</a></p></blockquote><h1 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h1><h2 id="移位运算"><a href="#移位运算" class="headerlink" title="移位运算"></a>移位运算</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">A&gt;&gt;1;   &#x2F;&#x2F; 相当于A&#x2F;2，高位正数补零，负数补一A&lt;&lt;1;   &#x2F;&#x2F;相当于A*2，高位移出，低位的空位补零A&gt;&gt;&gt;1； &#x2F;&#x2F;无符号右移，只使用 0 进行补位</code></pre><h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><ul><li>即一个元素通过一个function可以得出对应的的散列值，但不同的元素也可能得到相同的散列值。是能够通过给定的关键字的值直接访问到具体对应的值的一个数据结构。</li><li>把关键字称为 Key，记录称为 Value，通过 Key 访问一个function来得到 Value 的地址。而这个function，也叫作散列函数或者哈希函数，存放记录的数组叫作散列表。</li><li>当发生两个key产生了同一个散列值时，此时发生hash碰撞，解决办法就是拉链法，即如图通过链表的方式将发生冲突的元素都连接起来。HashMap就是采用这一方法解决hash冲突，但是如果当冲突非常多，那么链表会越来越长，则效率变差，此时HashMap中定义了一个值，当链表长度超过此值且满足一定条件时，将链表转化为红黑树。</li></ul><p><img src="/img/java/hashmapfuncation.png"></p><h2 id="HashMap结构"><a href="#HashMap结构" class="headerlink" title="HashMap结构"></a>HashMap结构</h2><p><img src="/img/java/java-collection-hashmap8.png"></p><ul><li><p>Map的实现基于数组+链表+红黑树结构。每一个数组被称为一个bin，每一个bin里面可能连接着链表或者红黑树结构。</p></li><li><p>数组的源码定义，从此看出Map的实现基于Node类型的数组。</p></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">transient Node&lt;K,V&gt;[] table;</code></pre><ul><li>链表的源码定义</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123;    final int hash;    final K key;    V value;    Node&lt;K,V&gt; next;&#125;</code></pre><ul><li>红黑树的源码定义为</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123;    TreeNode&lt;K,V&gt; parent;  &#x2F;&#x2F; red-black tree links    TreeNode&lt;K,V&gt; left;    TreeNode&lt;K,V&gt; right;    TreeNode&lt;K,V&gt; prev;    &#x2F;&#x2F; needed to unlink next upon deletion+    boolean red;    ...&#125;</code></pre><h2 id="内部变量"><a href="#内部变量" class="headerlink" title="内部变量"></a>内部变量</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;** * 默认容量 *&#x2F;static final int DEFAULT_INITIAL_CAPACITY &#x3D; 1 &lt;&lt; 4; &#x2F;&#x2F; aka 16&#x2F;** * 最大容量 *&#x2F;static final int MAXIMUM_CAPACITY &#x3D; 1 &lt;&lt; 30;&#x2F;** * 负载因子，当数组的容量达到总容量的百分之七十五时，则map就需要考虑扩容了 *&#x2F;static final float DEFAULT_LOAD_FACTOR &#x3D; 0.75f;&#x2F;** * 树化阈值，当一个bin中的链表元素个数超过8时才具备链表转红黑树的条件。 *&#x2F;static final int TREEIFY_THRESHOLD &#x3D; 8;&#x2F;** * 红黑树退化为链表的阈值 *&#x2F;static final int UNTREEIFY_THRESHOLD &#x3D; 6;&#x2F;** * 整个bin的数量达到64个且链表长度达到8个后才具备转换红黑树的条件 * TREEIFY_THRESHOLD 和 MIN_TREEIFY_CAPACITY 两个变量是同时具备才可以 * 这样可以避免因为数组容量太小以至于都hash计算到一个bin中，若bin都64个了且链表 * 还是大于8个长，那么就说明了不是因为数组太小导致的hash冲突 *&#x2F;static final int MIN_TREEIFY_CAPACITY &#x3D; 64;</code></pre><h2 id="构造方法"><a href="#构造方法" class="headerlink" title="构造方法"></a>构造方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;**  * 默认的初始化16容量和0.75的负载因子  *&#x2F; public HashMap() &#123;     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR; &#x2F;&#x2F; all other fields defaulted &#125;&#x2F;**  * 指定初始化容量，默认负载因子0.75  *&#x2F; public HashMap(int initialCapacity) &#123;     this(initialCapacity, DEFAULT_LOAD_FACTOR); &#125;&#x2F;**  * 可指定默认初始化容量和负载因子  *&#x2F; public HashMap(int initialCapacity, float loadFactor) &#123;     &#x2F;&#x2F; 参数检查开始     if (initialCapacity &lt; 0)         throw new IllegalArgumentException(&quot;Illegal initial capacity: &quot; +                                            initialCapacity);     if (initialCapacity &gt; MAXIMUM_CAPACITY)         initialCapacity &#x3D; MAXIMUM_CAPACITY;     if (loadFactor &lt;&#x3D; 0 || Float.isNaN(loadFactor))         throw new IllegalArgumentException(&quot;Illegal load factor: &quot; +                                            loadFactor);     &#x2F;&#x2F; 参数检查结束     &#x2F;&#x2F; 指定的负载因子     this.loadFactor &#x3D; loadFactor;     &#x2F;&#x2F; threshold &#x3D; capacity * load factor，即直接算出来了下次数组达到多大的时候进行扩容。     this.threshold &#x3D; tableSizeFor(initialCapacity); &#125; &#x2F;**  *&#x2F; public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123;     this.loadFactor &#x3D; DEFAULT_LOAD_FACTOR;     putMapEntries(m, false); &#125;</code></pre><ul><li>其中的<code>putMapEntries</code>方法一会分析，现在来分析一下<code>tableSizeFor</code>。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"> &#x2F;**  * 返回大于cap的最小2的幂次方数，比如给定cap&#x3D;12，返回16，给定5返回8，返回结果始终是2的幂次方  * 原理： 因为2的幂次方的二进制都是高位为1，其余位都是0。比如cap&#x3D;100，tableSizeFor应返回128  * cap &#x3D; 0000 0000 0000 0000 0000 0000 0110 0100     numberOfLeadingZeros返回25  *  -1&#x3D;  10000 0000 0000 0000 0000 0000 0000 0001    无条件&gt;&gt;&gt;25  * res:  0000 0000 0000 0000 0000 0000 1000 0000      128  *  * 旧版HashMap.tableSizeFor的参考文章：https:&#x2F;&#x2F;www.cnblogs.com&#x2F;xiyixiaodao&#x2F;p&#x2F;14483876.html  *&#x2F; static final int tableSizeFor(int cap) &#123;     &#x2F;&#x2F; 返回无符号整形i的最高非零位前面的0的个数，包括符号位在内     &#x2F;&#x2F; cap-1是防止出现cap已经是2的次方数了     int n &#x3D; -1 &gt;&gt;&gt; Integer.numberOfLeadingZeros(cap - 1);     &#x2F;&#x2F; 小于0即cap为负数，负数返回1，否则只要不超过 最大容量 都会返回n+1     return (n &lt; 0) ? 1 : (n &gt;&#x3D; MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1; &#125;&#x2F;**  *  返回无符号整形i的最高非零位前面的0的个数，包括符号位在内。  *&#x2F; public static int numberOfLeadingZeros(int i) &#123;     &#x2F;&#x2F; HD, Count leading 0&#39;s     &#x2F;&#x2F; 若为0或负数，     if (i &lt;&#x3D; 0)         &#x2F;&#x2F; 0的所有位都是0，所以返回32位，若i为负数，负数的二进制位的最高位已经是1了，所以返回0；         return i &#x3D;&#x3D; 0 ? 32 : 0;     int n &#x3D; 31;     &#x2F;**      * 举例子  i&#x3D;65537      *     7: 0000 0000 0000 0001 0000 0000 0000 0001      * 1&lt;&lt;16: 0000 0000 0000 0001 0000 0000 0000 0000      * 1&lt;&lt;8 : 0000 0000 0000 0000 0000 0001 0000 0000      * 1&lt;&lt;4 : 0000 0000 0000 0000 0000 0000 0001 0000      * 1&lt;&lt;2 : 0000 0000 0000 0000 0000 0000 0000 0100      *      * 其中：i &gt;&#x3D; 1 &lt;&lt; 16 ，因为1&lt;&lt;16的高16位有1，若i&gt;1&lt;&lt;16，则i的高十六位一定也有1      *      i &gt;&#x3D; 1 &lt;&lt; 16，  满足，则n&#x3D;15，i&#x3D;0000 0000 0000 0000 0000 0000 0000 0001&#x3D;1      *      i &gt;&#x3D; 1 &lt;&lt;  8，不满足      *      i &gt;&#x3D; 1 &lt;&lt;  4，不满足      *      i &gt;&#x3D; 1 &lt;&lt;  2，不满足      *      return 15-0      *&#x2F;     &#x2F;&#x2F;如果高16位有1，那么n减半（二分查找的核心），i无符号右移16位，保留高16位     if (i &gt;&#x3D; 1 &lt;&lt; 16) &#123; n -&#x3D; 16; i &gt;&gt;&gt;&#x3D; 16; &#125;     &#x2F;&#x2F;到这里，如果前面一步false，那么高16位都是0；如果上面一步true，那么只有16位了。     &#x2F;&#x2F;如果高8位有1，那么n减半（二分查找的核心），i无符号右移8位，保留高8位     if (i &gt;&#x3D; 1 &lt;&lt;  8) &#123; n -&#x3D;  8; i &gt;&gt;&gt;&#x3D;  8; &#125;     &#x2F;&#x2F;如果高4位有1，那么n减半（二分查找的核心），i无符号右移4位，保留高4位     if (i &gt;&#x3D; 1 &lt;&lt;  4) &#123; n -&#x3D;  4; i &gt;&gt;&gt;&#x3D;  4; &#125;     &#x2F;&#x2F;如果高2位有1，那么n减半（二分查找的核心），i无符号右移2位，保留高2位     if (i &gt;&#x3D; 1 &lt;&lt;  2) &#123; n -&#x3D;  2; i &gt;&gt;&gt;&#x3D;  2; &#125;     return n - (i &gt;&gt;&gt; 1); &#125;</code></pre><ul><li>由此看出<code>tablesizeFor</code>的实现最关键的是得到一个数字的高位0的个数，通过对负一移位来实现的。</li></ul><h2 id="Put方法"><a href="#Put方法" class="headerlink" title="Put方法"></a>Put方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public V put(K key, V value) &#123;    return putVal(hash(key), key, value, false, true);&#125;&#x2F;** * Implements Map.put and related methods. * * @param hash hash for key * @param key the key * @param value the value to put * @param onlyIfAbsent if true, don&#39;t change existing value * @param evict if false, the table is in creation mode. 只有在构造方法执行的时候，才会传入false为构造模式 * @return previous value, or null if none * 从方法也可以看出来，若put替换value是不增加modCount的。 *&#x2F;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123;    &#x2F;&#x2F; tab 保存之前的数组引用，p指向当前要操作的位置上的元素，n&#x3D; tab.length，i遍历下标    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i;    &#x2F;&#x2F; 如果表为空    if ((tab &#x3D; table) &#x3D;&#x3D; null || (n &#x3D; tab.length) &#x3D;&#x3D; 0)        &#x2F;&#x2F; 表进行扩容初始化        n &#x3D; (tab &#x3D; resize()).length;    &#x2F;&#x2F; 到这表示表不为空，但是hash计算出来的结果映射到的数组下标位置上没有元素    &#x2F;&#x2F; (n - 1) &amp; hash，n为表长为2的次方数，只有(n - 1) &amp; hash这样才可以将hash均匀的分配到数组中，    &#x2F;&#x2F; 也是通过这种方式进行查位于哪个数组的    if ((p &#x3D; tab[i &#x3D; (n - 1) &amp; hash]) &#x3D;&#x3D; null)        &#x2F;&#x2F; 则直接赋值        tab[i] &#x3D; newNode(hash, key, value, null);    else &#123;        &#x2F;&#x2F; 到这表示表不为空，且位置上有元素        Node&lt;K,V&gt; e; K k;        &#x2F;&#x2F; 如果此位置上就是要put的key        if (p.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; p.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            &#x2F;&#x2F; 暂存            e &#x3D; p;        &#x2F;&#x2F; 此位置上第一个与要put的key不匹配，且已经是红黑树了        else if (p instanceof TreeNode)            &#x2F;&#x2F; 执行红黑树的操作            e &#x3D; ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value);        else &#123;            &#x2F;&#x2F; 即不是红黑树也不是单个元素，则只剩下链表的情况，遍历寻找            for (int binCount &#x3D; 0; ; ++binCount) &#123;                &#x2F;&#x2F; e已经保存了此位置上第一个元素的引用，判断是否还有下一个元素                &#x2F;&#x2F; 之前已经排除了第一个元素就是put的key，则如果没有下一个就直接链接上新node                if ((e &#x3D; p.next) &#x3D;&#x3D; null) &#123;                    &#x2F;&#x2F; 链接上新node                    p.next &#x3D; newNode(hash, key, value, null);                    &#x2F;&#x2F; 判断是否需要树化，binCount在遍历链表的时候已经算出目前位置有多少元素了                    if (binCount &gt;&#x3D; TREEIFY_THRESHOLD - 1) &#x2F;&#x2F; -1 for 1st                        treeifyBin(tab, hash); &#x2F;&#x2F; 进行树化                    break;                &#125;                &#x2F;&#x2F; 如果遍历中找到了与put元素一样的key，则跳出                if (e.hash &#x3D;&#x3D; hash &amp;&amp; ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    break;                &#x2F;&#x2F; 用于循环                p &#x3D; e;            &#125;        &#125;        &#x2F;&#x2F; 前面break后，e的引用已经是指向了链表的末尾。 情况为要么后面没元素了要么就是现在就是put的元素key        &#x2F;&#x2F; 不为空的情况就是第二种：现在e就是与要put的元素key相同的元素        if (e !&#x3D; null) &#123; &#x2F;&#x2F; existing mapping for key            &#x2F;&#x2F; 保存旧值用于返回            V oldValue &#x3D; e.value;              &#x2F;&#x2F; 是否替换            if (!onlyIfAbsent || oldValue &#x3D;&#x3D; null)                e.value &#x3D; value;            &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法            afterNodeAccess(e);            return oldValue;&#x2F;&#x2F; 返回旧值        &#125;    &#125;    ++modCount;    &#x2F;&#x2F; 判断是否需要扩容    if (++size &gt; threshold)        resize();    &#x2F;&#x2F; linkedHashMap 有用，目前是一个空方法    afterNodeInsertion(evict);    return null;&#125;</code></pre><h2 id="resize方法"><a href="#resize方法" class="headerlink" title="resize方法"></a>resize方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">final Node&lt;K,V&gt;[] resize() &#123;    &#x2F;&#x2F; 暂存旧引用    Node&lt;K,V&gt;[] oldTab &#x3D; table;    &#x2F;&#x2F; 对于初始化没有分配空间的情况，oldtab是空的，若不是空，则保存之前的容量    &#x2F;&#x2F; 之前的扩容阈值，达到这个阈值后考虑扩容    int oldCap &#x3D; (oldTab &#x3D;&#x3D; null) ? 0 : oldTab.length;    int oldThr &#x3D; threshold;    &#x2F;&#x2F; newCap扩容后的新容量，newThr扩容后的新阈值    int newCap, newThr &#x3D; 0;    &#x2F;&#x2F; 若之前有容量    if (oldCap &gt; 0) &#123;        &#x2F;&#x2F; 已经比最大的容量还大        if (oldCap &gt;&#x3D; MAXIMUM_CAPACITY) &#123;            &#x2F;&#x2F; 当下次达到Integer.MAX_VALUE个元素后再扩容。            &#x2F;&#x2F; 目的是之前扩容阈值&#x3D;capacity*0.75，这样赋值最大值是将剩下的百分十25利用起来            threshold &#x3D; Integer.MAX_VALUE;            return oldTab;        &#125;        &#x2F;&#x2F; 未到最大容量而且小于最大容量，则新容量是旧容量的二倍，通过oldCap &lt;&lt; 1实现，        &#x2F;&#x2F; 且旧容量已经大于等于16，则下次扩容阈值是之前扩容阈值的二倍        &#x2F;&#x2F; 若不满足，代表map初始化的时候指定了初始化容量。容量小于16        else if ((newCap &#x3D; oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp;                 oldCap &gt;&#x3D; DEFAULT_INITIAL_CAPACITY)            newThr &#x3D; oldThr &lt;&lt; 1; &#x2F;&#x2F; double threshold    &#125;    &#x2F;&#x2F; 到这表示oldCap&#x3D;0,但是oldThr&gt;0；此时只有初始化时指定参数。oldThr&#x3D;threshold&#x3D;tablesizeFor    else if (oldThr &gt; 0) &#x2F;&#x2F; initial capacity was placed in threshold        &#x2F;&#x2F; 将阈值直接当作新容量        newCap &#x3D; oldThr;    else &#123;               &#x2F;&#x2F; zero initial threshold signifies using defaults        &#x2F;&#x2F; 初始化时是默认的构造        newCap &#x3D; DEFAULT_INITIAL_CAPACITY;        newThr &#x3D; (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY);    &#125;    if (newThr &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 如果是0，表示newThr在前面的代码中未被赋值，表示只满足else if (oldThr &gt; 0)情况。        &#x2F;&#x2F; 计算下次扩容阈值        float ft &#x3D; (float)newCap * loadFactor;        newThr &#x3D; (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ?                  (int)ft : Integer.MAX_VALUE);    &#125;    threshold &#x3D; newThr;    &#x2F;&#x2F; 下面进行从旧数组将数组迁移到新数组的操作    @SuppressWarnings(&#123;&quot;rawtypes&quot;,&quot;unchecked&quot;&#125;) &#x2F;&#x2F; 新容量数组    Node&lt;K,V&gt;[] newTab &#x3D; (Node&lt;K,V&gt;[])new Node[newCap];    table &#x3D; newTab;    &#x2F;&#x2F; 如果之前的旧数组是空的话代表无元素可迁移，直接返回新数组引用即可。    if (oldTab !&#x3D; null) &#123;        &#x2F;&#x2F; 循环旧数组中的元素        for (int j &#x3D; 0; j &lt; oldCap; ++j) &#123;            Node&lt;K,V&gt; e;            &#x2F;&#x2F; 若元素不为空            if ((e &#x3D; oldTab[j]) !&#x3D; null) &#123;                &#x2F;&#x2F; 为了方便垃圾回收                oldTab[j] &#x3D; null;                &#x2F;&#x2F; bin中仅有一个元素                if (e.next &#x3D;&#x3D; null)                    &#x2F;&#x2F; 映射到新数组中                    newTab[e.hash &amp; (newCap - 1)] &#x3D; e;                &#x2F;&#x2F; 如果已经是树了，进行树的操作                else if (e instanceof TreeNode)                    ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap);                &#x2F;&#x2F; 到这就是链表情况                else &#123; &#x2F;&#x2F; preserve order                    &#x2F;&#x2F; 若一个bin中有一条链表，那么在遍历此链表上的元素的时候，由于容量不一样了，所以需要对                    &#x2F;&#x2F; 元素进行重新的hash计算，则会出现有的元素hash后在新数组的位置与目前位置相同，有些元素                    &#x2F;&#x2F; 在hash后在新数组的位置是 原来旧数组的位置加上原来旧容量的长度                    &#x2F;&#x2F; 若下标不动的，则依次链接到loxxxx的链表上                    &#x2F;&#x2F; 下标动的，依次链接到hixxxx的链表上                    Node&lt;K,V&gt; loHead &#x3D; null, loTail &#x3D; null;                    Node&lt;K,V&gt; hiHead &#x3D; null, hiTail &#x3D; null;                    Node&lt;K,V&gt; next;                    do &#123;                        next &#x3D; e.next;                        &#x2F;&#x2F; e.hash &amp; oldCap 决定了链表上的元素的下标是不是动                        &#x2F;&#x2F; 因为oldCap都是2的次方，则高位为1，其余位为0                        &#x2F;&#x2F; 例如：                        &#x2F;&#x2F; oldCap &#x3D; 1 0000                        &#x2F;&#x2F; e.hash &#x3D; 1 1111   或                        &#x2F;&#x2F; e.hash &#x3D; 0 1111                           &#x2F;&#x2F; 则通过与运算后，链表上的元素就被分为两个链表                        &#x2F;&#x2F; 下面就是拆分链表的逻辑                        if ((e.hash &amp; oldCap) &#x3D;&#x3D; 0) &#123;                            if (loTail &#x3D;&#x3D; null)                                loHead &#x3D; e;                            else                                loTail.next &#x3D; e;                            loTail &#x3D; e;                        &#125;                        else &#123;                            if (hiTail &#x3D;&#x3D; null)                                hiHead &#x3D; e;                            else                                hiTail.next &#x3D; e;                            hiTail &#x3D; e;                        &#125;                    &#125; while ((e &#x3D; next) !&#x3D; null);                    &#x2F;&#x2F; 不为空，则有下标不动的元素链表，直接链接                    if (loTail !&#x3D; null) &#123;                        loTail.next &#x3D; null;                        newTab[j] &#x3D; loHead;                    &#125;                    &#x2F;&#x2F; 不为空，则有下标移动的元素链表，连接到原来数组下标+旧容量的位置。                    if (hiTail !&#x3D; null) &#123;                        hiTail.next &#x3D; null;                        newTab[j + oldCap] &#x3D; hiHead;                    &#125;                &#125;            &#125;        &#125;    &#125;    return newTab;&#125;</code></pre><h2 id="get"><a href="#get" class="headerlink" title="get"></a>get</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public V get(Object key) &#123;    Node&lt;K,V&gt; e;    return (e &#x3D; getNode(key)) &#x3D;&#x3D; null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(Object key) &#123;    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n, hash; K k;    &#x2F;&#x2F; 若表不空，且key的hash位置不为空才继续    if ((tab &#x3D; table) !&#x3D; null &amp;&amp; (n &#x3D; tab.length) &gt; 0 &amp;&amp;        (first &#x3D; tab[(n - 1) &amp; (hash &#x3D; hash(key))]) !&#x3D; null) &#123;        &#x2F;&#x2F; 检查第一个元素是否匹配        if (first.hash &#x3D;&#x3D; hash &amp;&amp; &#x2F;&#x2F; always check first node            ((k &#x3D; first.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))            return first;        &#x2F;&#x2F; 第一个元素不匹配        if ((e &#x3D; first.next) !&#x3D; null) &#123;            &#x2F;&#x2F; 从树中寻找            if (first instanceof TreeNode)                return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key);            &#x2F;&#x2F; 否则遍历链表寻找            do &#123;                if (e.hash &#x3D;&#x3D; hash &amp;&amp;                    ((k &#x3D; e.key) &#x3D;&#x3D; key || (key !&#x3D; null &amp;&amp; key.equals(k))))                    return e;            &#125; while ((e &#x3D; e.next) !&#x3D; null);        &#125;    &#125;    return null;&#125;</code></pre><h1 id="TreeMap"><a href="#TreeMap" class="headerlink" title="TreeMap"></a>TreeMap</h1><p>todo</p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
    <category term="todo" scheme="https://ohbug.cn/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：List源码实现</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava5.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava5.html</id>
    <published>2023-01-27T01:57:16.000Z</published>
    <updated>2023-02-02T10:09:20.854Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><p><img src="/img/java/CollectionClassMap-List.png"></p><ul><li>紫色实线为继承，绿色实线为接口的继承，绿色虚线为类的继承。</li><li>下面进行实现类的源码分析，主要是分析其实现类的主要功能。</li></ul><h1 id="List"><a href="#List" class="headerlink" title="List"></a>List</h1><h2 id="ArrayList"><a href="#ArrayList" class="headerlink" title="ArrayList"></a>ArrayList</h2><h3 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h3><ul><li>从如下的得知，默认的空参构造并不会初始化一个数组，而是类似于懒加载的方式，当加入参数或者指定大小的时候才开始初始化数组大小。</li><li>若 ArrayList 对象都是空实例，则都会指向一个数组对象，以便节约内存。</li><li><code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 和  <code>EMPTY_ELEMENTDATA</code> 并不一样。<code>DEFAULTCAPACITY_EMPTY_ELEMENTDATA</code> 用于无参初始化，而 <code>EMPTY_ELEMENTDATA </code>用于优化创建ArrayList空实例时产生不必要的空数组。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 默认容量private static final int DEFAULT_CAPACITY &#x3D; 10;transient Object[] elementData;&#x2F;&#x2F; 共享的空数组private static final Object[] EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA &#x3D; &#123;&#125;;&#x2F;&#x2F; 空参构造，从这也可以看到出，ArrayList默认无参数初始化时，底层的数组长度是0，无元素public ArrayList() &#123;    this.elementData &#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(int initialCapacity) &#123;    if (initialCapacity &gt; 0) &#123;        &#x2F;&#x2F; 指定长度构造则只构造参数长度的数组对象。        this.elementData &#x3D; new Object[initialCapacity];    &#125; else if (initialCapacity &#x3D;&#x3D; 0) &#123;        &#x2F;&#x2F; 与无参的思路一样        this.elementData &#x3D; EMPTY_ELEMENTDATA;    &#125; else &#123;        throw new IllegalArgumentException(&quot;Illegal Capacity: &quot;+                                            initialCapacity);    &#125;&#125;&#x2F;&#x2F; 参数为Collection的子类即可public ArrayList(Collection&lt;? extends E&gt; c) &#123;    &#x2F;&#x2F; 将参数转为数组    Object[] a &#x3D; c.toArray();    &#x2F;&#x2F; 不为空    if ((size &#x3D; a.length) !&#x3D; 0) &#123;      &#x2F;&#x2F; 若构造参数也是ArrayList则直接赋值即可        if (c.getClass() &#x3D;&#x3D; ArrayList.class) &#123;            elementData &#x3D; a;        &#125; else &#123;          &#x2F;&#x2F; 否则还是执行下面的复制方法            elementData &#x3D; Arrays.copyOf(a, size, Object[].class);        &#125;    &#125; else &#123;        &#x2F;&#x2F; 如果传入参数没有元素，则赋值一个共享的空数组，以节约内存。        &#x2F;&#x2F; replace with empty array.        elementData &#x3D; EMPTY_ELEMENTDATA;    &#125;&#125;public Object[] toArray() &#123;  &#x2F;&#x2F; a 数组内容，长度，a数组类型    return Arrays.copyOf(a, a.length, Object[].class);&#125;public static &lt;T,U&gt; T[] copyOf(U[] original, int newLength, Class&lt;? extends T[]&gt; newType) &#123;    @SuppressWarnings(&quot;unchecked&quot;)    &#x2F;&#x2F; 由于ArrayList的底层就是使用的Object数组，则始终为true，返回一个新数组，新数组与传入参数的对象长度一样    &#x2F;&#x2F; 否则返回一个应有对象类型的数组。    &#x2F;&#x2F; 根据不同的参数，toArray的实现不一样的，比如若传入HashSet的实现类，则HashSet已经重写了toArray方法，则调用的是HashSet的实现方法，代码就不会执行到这里了    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)        ? (T[]) new Object[newLength]        : (T[]) Array.newInstance(newType.getComponentType(), newLength);    &#x2F;&#x2F; 数组复制，然后返回即可    System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength));    return copy;&#125;        </code></pre><ul><li>对于 <code>copyof</code> 方法的额外补充。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Object[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;Object[] strings &#x3D; Arrays.copyOf(str, 2);&#x2F;&#x2F; 此时上面copyof方法中的((Object)newType &#x3D;&#x3D; (Object)Object[].class) 为true&#x2F;&#x2F; 若换为String，或者其他类型的数组，则为false&#x2F;&#x2F; 如下，如果是Object数组，返回一个新Object数组，新数组与传入参数的规定长度一样    T[] copy &#x3D; ((Object)newType &#x3D;&#x3D; (Object)Object[].class)        ? (T[]) new Object[newLength]        : (T[]) Array.newInstance(newType.getComponentType(), newLength);&#x2F;&#x2F; 否则就返回与实际相符的类型数组。    public static Object newInstance(Class&lt;?&gt; componentType, int length)        throws NegativeArraySizeException &#123;        return newArray(componentType, length);    &#125;&#x2F;&#x2F; out: class java.lang.String  String[] str &#x3D; &#123;&quot;1&quot;,&quot;2&quot;&#125;;  System.out.println(str.getClass().getComponentType());</code></pre><h3 id="transient"><a href="#transient" class="headerlink" title="transient"></a>transient</h3><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.runoob.com/w3cnote/java-transient-keywords.html">https://www.runoob.com/w3cnote/java-transient-keywords.html</a></p></blockquote><ul><li>被<code>transient</code>修饰的字段的生命周期仅存于调用者的内存中而不会写到磁盘里持久化。只需要实现<code>Serilizable</code>接口，将不需要序列化的属性前添加<code>transient</code>，序列化对象的时候，这个属性就不会序列化到指定的目的地中。</li><li>只能修饰变量，而不能修饰方法和类。变量如果是用户自定义类变量，则该类需要实现<code>Serializable</code>接口。</li><li>被<code>transient</code>关键字修饰的变量不再能被序列化，一个静态变量不管是否被<code>transient</code>修饰，均不能被序列化。</li></ul><h3 id="add"><a href="#add" class="headerlink" title="add"></a>add</h3><ul><li>总结下来就是通过判断数组的大小与元素的数量，来返回合适的容量大小，以便创建合适的数组，在通过copyof方法进行复制元素。</li><li>重点是<code>grow</code>方法的实现，我们可以从源码得到，若满了，则推荐的扩容大小是之前的 1.5呗，是通过 <code>oldCapacity &gt;&gt; 1</code> 实现的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">protected transient int modCount &#x3D; 0;    public boolean add(E e) &#123;      &#x2F;&#x2F; 表示内部的修改次数，与迭代器配合，可以判断出迭代过程中是否被修改，防止多线程模式下安全问题        modCount++;        &#x2F;&#x2F; 添加元素        add(e, elementData, size);        return true;    &#125;    &#x2F;&#x2F; e要添加的参数，elementData是底层数组实现，s 已包含元素数量    private void add(E e, Object[] elementData, int s) &#123;      &#x2F;&#x2F; 数组无空闲地方存放待加入元素，则扩充数组大小，包括两种情况，一种是刚刚初始化完毕无空闲位置，一个是已满无空闲位置      &#x2F;&#x2F; 如果为false，即代表数组位置和数组内元素数量不一致，则不需要增长容量，因为有空闲位置。        if (s &#x3D;&#x3D; elementData.length)            elementData &#x3D; grow();        &#x2F;&#x2F; 插入值        elementData[s] &#x3D; e;        &#x2F;&#x2F; 容量+1        size &#x3D; s + 1;    &#125;    private Object[] grow() &#123;        return grow(size + 1);    &#125;    private Object[] grow(int minCapacity) &#123;      &#x2F;&#x2F; 保存原来长度        int oldCapacity &#x3D; elementData.length;        &#x2F;&#x2F; 如果不是空元素的ArrayList集合 或 刚初始化完成的        if (oldCapacity &gt; 0 || elementData !&#x3D; DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123;          &#x2F;&#x2F; 计算新容量的大小            int newCapacity &#x3D; ArraysSupport.newLength(oldCapacity,                    minCapacity - oldCapacity, &#x2F;* minimum growth *&#x2F;                    oldCapacity &gt;&gt; 1           &#x2F;* preferred growth *&#x2F;);            &#x2F;&#x2F; 复制元素进去，返回的是新的数组，原数组引用丢失，会被之后当垃圾回收掉            return elementData &#x3D; Arrays.copyOf(elementData, newCapacity);        &#125; else &#123;          &#x2F;&#x2F; 代表ArrayList中已经是空的了，此时与默认初始化大小和目前元素个数+1 比较，两个数取大值，创建大值容量的Object数组            return elementData &#x3D; new Object[Math.max(DEFAULT_CAPACITY, minCapacity)];        &#125;    &#125;    public static final int SOFT_MAX_ARRAY_LENGTH &#x3D; Integer.MAX_VALUE - 8;    &#x2F;&#x2F; 仅仅用来计算数组长度的    public static int newLength(int oldLength, int minGrowth, int prefGrowth) &#123;        &#x2F;&#x2F; 如果长度超过了Integer.MAX_VALUE，则异常发生OutOfMemoryError        &#x2F;&#x2F; 一般情况下选取prefGrowth，而当prefGrowth超过最大值而minGrowth没有超时，选取minGrowth        int prefLength &#x3D; oldLength + Math.max(minGrowth, prefGrowth); &#x2F;&#x2F; might overflow        if (0 &lt; prefLength &amp;&amp; prefLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;            return prefLength;        &#125; else &#123;            &#x2F;&#x2F; prefLength超了            &#x2F;&#x2F; put code cold in a separate method            return hugeLength(oldLength, minGrowth);        &#125;    &#125;    &#x2F;&#x2F; 判断oldLength + minGrowth是否超过了SOFT_MAX_ARRAY_LENGTH，如果超了即为负数直接报错，    &#x2F;&#x2F; 如果没超过SOFT_MAX_ARRAY_LENGTH，则直接返回SOFT_MAX_ARRAY_LENGTH，否则返回minLength的计算值    private static int hugeLength(int oldLength, int minGrowth) &#123;        int minLength &#x3D; oldLength + minGrowth;        if (minLength &lt; 0) &#123; &#x2F;&#x2F; overflow            throw new OutOfMemoryError(                &quot;Required array length &quot; + oldLength + &quot; + &quot; + minGrowth + &quot; is too large&quot;);        &#125; else if (minLength &lt;&#x3D; SOFT_MAX_ARRAY_LENGTH) &#123;            return SOFT_MAX_ARRAY_LENGTH;        &#125; else &#123;            return minLength;        &#125;    &#125;</code></pre><h3 id="get"><a href="#get" class="headerlink" title="get"></a>get</h3><ul><li>没啥好分析的。首先判断下标是否合法，合法则直接取值。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public E get(int index) &#123;    &#x2F;&#x2F; 仅仅是检查下标是否越界    Objects.checkIndex(index, size);    return elementData(index);&#125;E elementData(int index) &#123;    return (E) elementData[index];&#125;</code></pre><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><ul><li>检查下标是否合法，取出旧值并返回，新值替换就值。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public E set(int index, E element) &#123;    Objects.checkIndex(index, size);    E oldValue &#x3D; elementData(index);    elementData[index] &#x3D; element;    return oldValue;&#125;</code></pre><h3 id="remove"><a href="#remove" class="headerlink" title="remove"></a>remove</h3><ul><li>指定位置删除十分简单，若是指定对象删除，实现逻辑就是循环遍历元素然后依旧通过<code>fastRemove</code>删除，通过<code>System.arraycopy</code>实现。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public E remove(int index) &#123;    &#x2F;&#x2F; 检查下标是否合法    Objects.checkIndex(index, size);    final Object[] es &#x3D; elementData;    @SuppressWarnings(&quot;unchecked&quot;)     E oldValue &#x3D; (E) es[index];    fastRemove(es, index);    return oldValue;&#125;private void fastRemove(Object[] es, int i) &#123;    modCount++;    final int newSize;    &#x2F;&#x2F; 如果为true，则代表要删除的指定位置并不是最后一个元素，则数组整体往前移一个位置    if ((newSize &#x3D; size - 1) &gt; i)        System.arraycopy(es, i + 1, es, i, newSize - i);    &#x2F;&#x2F; 到这条件为false，或者要删除的指定位置是最后一个元素，直接赋值null即可      es[size &#x3D; newSize] &#x3D; null;&#125;</code></pre><h3 id="removeAll"><a href="#removeAll" class="headerlink" title="removeAll"></a>removeAll</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public boolean removeAll(Collection&lt;?&gt; c) &#123;    return batchRemove(c, false, 0, size);&#125;boolean batchRemove(Collection&lt;?&gt; c, boolean complement, final int from, final int end) &#123;    &#x2F;&#x2F; 不为空，否则空指针    Objects.requireNonNull(c);    final Object[] es &#x3D; elementData;    int r;    for (r &#x3D; from;; r++) &#123;        &#x2F;&#x2F; 若循环到了最后一个，即证明了没有要删除的元素        if (r &#x3D;&#x3D; end)            return false;        &#x2F;&#x2F; 如果包含对应的元素则结束循环，结束循环的位置就是第一个元素出现的下标位置        if (c.contains(es[r]) !&#x3D; complement)            break;    &#125;    &#x2F;&#x2F; 第一个元素出现的下标位置记作w，r指向下一个位置    int w &#x3D; r++;    try &#123;        &#x2F;&#x2F; 从下一个位置开始判断，结束条件为末尾        for (Object e; r &lt; end; r++)            &#x2F;&#x2F; 如果剩下的未遍历的c中的元素中，该元素不是要删除的元素            if (c.contains(e &#x3D; es[r]) &#x3D;&#x3D; complement)                &#x2F;&#x2F; 则将要删除的元素用不需要删除元素的值顶替                es[w++] &#x3D; e;    &#125; catch (Throwable ex) &#123;        &#x2F;&#x2F; Preserve behavioral compatibility with AbstractCollection,        &#x2F;&#x2F; even if c.contains() throws.        System.arraycopy(es, r, es, w, end - r);        w +&#x3D; end - r;        throw ex;    &#125; finally &#123;        &#x2F;&#x2F; 操作次数记录        modCount +&#x3D; end - w;        &#x2F;&#x2F; 经过上面操作，到这已经是将要删除的元素剔除完了，但是操作还没结束        &#x2F;&#x2F; 比如从12345中剔除24，则到这12345变为了13545，其中最后的45是要删除掉的        &#x2F;&#x2F; 则下面方法就是将后面多余元素删除的工作        shiftTailOverGap(es, w, end);    &#125;    return true;&#125;</code></pre><h2 id="LinkedList"><a href="#LinkedList" class="headerlink" title="LinkedList"></a>LinkedList</h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class LinkedList&lt;E&gt;    extends AbstractSequentialList&lt;E&gt;    implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable</code></pre><ul><li>从定义也可以看出来，<code>LinkedList</code> 不仅可以做链表，还可以当作队列使用，以及堆栈，但是如果涉及到堆栈等操作，更合适用的是 <code>ArrayDeque</code></li></ul><h3 id="结构"><a href="#结构" class="headerlink" title="结构"></a>结构</h3><ul><li><code>LinkedList</code>里面有一内部类<code>Node</code>，从这也可以看出<code>LinkedList</code>是一个双向链表。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">private static class Node&lt;E&gt; &#123;    E item;    Node&lt;E&gt; next;      Node&lt;E&gt; prev;    Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123;        this.item &#x3D; element;        this.next &#x3D; next;        this.prev &#x3D; prev;    &#125;&#125;</code></pre><h3 id="构造-1"><a href="#构造-1" class="headerlink" title="构造"></a>构造</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 元素个数transient int size &#x3D; 0;public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123;    this();    addAll(c);&#125;public boolean addAll(Collection&lt;? extends E&gt; c) &#123;    return addAll(size, c);&#125;public boolean addAll(int index, Collection&lt;? extends E&gt; c) &#123;    &#x2F;&#x2F; 内部实现就是简单的边界检查    checkPositionIndex(index);    &#x2F;&#x2F; 将参数转为数组，底层实现为Arrays.copyOf    Object[] a &#x3D; c.toArray();    &#x2F;&#x2F; 元素个数    int numNew &#x3D; a.length;    if (numNew &#x3D;&#x3D; 0)        return false;    &#x2F;&#x2F; 记录： pred前一个元素，succ 当前    Node&lt;E&gt; pred, succ;    &#x2F;&#x2F; 如果相等代表在最后追加    if (index &#x3D;&#x3D; size) &#123;        &#x2F;&#x2F; 若在最后追加，则last已经指向了最后一个元素，那么pred就应该是待添加元素的前驱节点        &#x2F;&#x2F; 即last即为待添加元素的前驱节点，所以pred&#x3D;last且当前节点succ未添加为空        succ &#x3D; null;        pred &#x3D; last;    &#125; else &#123;        &#x2F;&#x2F; 到这了就表示在链表中间插入新元素        &#x2F;&#x2F; 得到后继节点        succ &#x3D; node(index);        &#x2F;&#x2F; 再由后继节点得到前驱节点。        pred &#x3D; succ.prev;    &#125;    &#x2F;&#x2F; 遍历要插入得元素数组    for (Object o : a) &#123;        @SuppressWarnings(&quot;unchecked&quot;)         E e &#x3D; (E) o;        &#x2F;&#x2F; 创建一个待插入节点，此节点已经指向了前驱节点        Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, null);        &#x2F;&#x2F; 前驱节点为空，即插入节点为头节点。        if (pred &#x3D;&#x3D; null)            first &#x3D; newNode;        else            &#x2F;&#x2F; 否则将前驱节点得后指针指向待插入节点            pred.next &#x3D; newNode;        &#x2F;&#x2F; 元素指针后移，为下次循环做准备        pred &#x3D; newNode;    &#125;    &#x2F;&#x2F; 如果在末尾追加，则succ由上面可知一定是null，且由于上面得for循环已经将pred指向了最后一个元素，则pred即为链表末尾    if (succ &#x3D;&#x3D; null) &#123;        last &#x3D; pred;    &#125; else &#123;        &#x2F;&#x2F; 到这则不代表在末尾追加，则一定是在头或中间追加，则succ为待插入位置的后面的链表的头引用        &#x2F;&#x2F; 此时链表的状态是，待插入位置前面的元素 + 已加入的新元素 。succ指向的待插入位置后面的原来的元素        &#x2F;&#x2F; 直接连接（待插入位置前面的元素 + 已加入的新元素）和succ，即完成添加        pred.next &#x3D; succ;        succ.prev &#x3D; pred;    &#125;    size +&#x3D; numNew;    modCount++;    return true;&#125;transient Node&lt;E&gt; first;   &#x2F;&#x2F; 全局节点头指针transient Node&lt;E&gt; last;     &#x2F;&#x2F; 尾指针&#x2F;&#x2F; 返回指定元素索引处的节点Node&lt;E&gt; node(int index) &#123;    &#x2F;&#x2F; 如果插入下标为链表元素的左半边    if (index &lt; (size &gt;&gt; 1)) &#123;        &#x2F;&#x2F; 记录头节点        Node&lt;E&gt; x &#x3D; first;        &#x2F;&#x2F; 从头遍历，因为是左半边，所以从头遍历比较快        &#x2F;&#x2F; 找到要插入位置的左边一个元素并返回        for (int i &#x3D; 0; i &lt; index; i++)            x &#x3D; x.next;        return x;    &#125; else &#123;        &#x2F;&#x2F; 到这表示要插入的元素为链表元素的右半边，所以从尾部往前遍历        Node&lt;E&gt; x &#x3D; last;        &#x2F;&#x2F; 直到遍历到要插入位置的右边一个位置        for (int i &#x3D; size - 1; i &gt; index; i--)            x &#x3D; x.prev;        return x;    &#125;    &#x2F;&#x2F; 无论for停留在左边还是右边，返回的都是指定元素索引处的元素&#125;</code></pre><ul><li>由于里面的诸如：addFirst,addLast,removeFirst等一系列方法都是在调用几个共同的方法，只是传入参数不同，则下面只分析几个调用较多的公共方法。</li></ul><h3 id="linkLast"><a href="#linkLast" class="headerlink" title="linkLast"></a>linkLast</h3><ul><li>将e元素添加至末尾。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void linkLast(E e) &#123;    &#x2F;&#x2F; 保存原来的尾节点    final Node&lt;E&gt; l &#x3D; last;    &#x2F;&#x2F; 创建要插入的新节点    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(l, e, null);    &#x2F;&#x2F; 新节点设置为last节点    last &#x3D; newNode;    &#x2F;&#x2F; 若为真，则代表原来的链表为空    if (l &#x3D;&#x3D; null)        &#x2F;&#x2F; 则一共就元素，则首尾都是此新元素        first &#x3D; newNode;    else        &#x2F;&#x2F; 尾节点的下一个引用则为新节点        l.next &#x3D; newNode;    size++;    modCount++;&#125;</code></pre><h3 id="linkBefore"><a href="#linkBefore" class="headerlink" title="linkBefore"></a>linkBefore</h3><ul><li>将一个元素放置在一个元素的前面。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">void linkBefore(E e, Node&lt;E&gt; succ) &#123;    &#x2F;&#x2F;已经确保了succ不为空,在上面node方法中确保的    &#x2F;&#x2F;取出指定index索引上的元素的前一个元素引用    final Node&lt;E&gt; pred &#x3D; succ.prev;    &#x2F;&#x2F;创建新的元素,新元素的前一个元素就是目前指定index上的元素的前一个元素    &#x2F;&#x2F;下一个元素是index上面的元素    final Node&lt;E&gt; newNode &#x3D; new Node&lt;&gt;(pred, e, succ);    &#x2F;&#x2F;将指定索引位置的原元素的前指针指向新元素    succ.prev &#x3D; newNode;    &#x2F;&#x2F;如果是在头部添加,那么当前元素的前一个元素肯定为空    if (pred &#x3D;&#x3D; null)    &#x2F;&#x2F;然后新元素就成为了头元素        first &#x3D; newNode;    else    &#x2F;&#x2F;否则就将index-1位置的元素的后指针指向新元素        pred.next &#x3D; newNode;    size++;    modCount++;&#125;</code></pre><h3 id="unlink"><a href="#unlink" class="headerlink" title="unlink"></a>unlink</h3><ul><li>将一个非空元素删除，即讲该元素的前后指针和前驱节点和后继节点的指针相连。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">E unlink(Node&lt;E&gt; x) &#123;    final E element &#x3D; x.item;    final Node&lt;E&gt; next &#x3D; x.next;    final Node&lt;E&gt; prev &#x3D; x.prev;    &#x2F;&#x2F; 无前驱元素，则就是头节点    if (prev &#x3D;&#x3D; null) &#123;        first &#x3D; next;    &#125; else &#123;        &#x2F;&#x2F; 否则前驱节点的后指针指向该删除元素的后继节点        prev.next &#x3D; next;        &#x2F;&#x2F; 断开要删除元素的前指针        x.prev &#x3D; null;    &#125;    &#x2F;&#x2F; 无后继元素，就是末尾节点    if (next &#x3D;&#x3D; null) &#123;        last &#x3D; prev;    &#125; else &#123;        &#x2F;&#x2F; 到这就代表不是末尾节点，则该后继节点的前指针指向该删除元素的前驱节点        next.prev &#x3D; prev;        &#x2F;&#x2F; 断开要删除元素的后指针        x.next &#x3D; null;    &#125;    &#x2F;&#x2F; 赋值为空，方便回收    x.item &#x3D; null;    size--;    modCount++;    return element;&#125;</code></pre><ul><li>对于其他的方法，最后归到底基本都是在调用上面几个方法，且逻辑比较简单，就不一一分析了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：泛型</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava4.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava4.html</id>
    <published>2023-01-17T01:58:04.000Z</published>
    <updated>2023-02-02T10:08:50.240Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><h1 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h1><ul><li>通过使用泛型， 可以最大程度的保证其类型安全。</li><li>加入泛型的代码是更加的灵活的，避免了硬编码。</li><li>由于泛型是运行时被擦除的，所以类泛型不可应用于静态变量方法中。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>《写给大忙人看的JAVA核心技术》一书中对于泛型的解释相当详细，值得多次翻阅   @todo </p></blockquote><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ul><li>编译器在编译期间，会将使用泛型的类直接擦去泛型代码，转换为普通的非泛型代码。比如<code> MyFactory &lt;T,U&gt;</code> 直接就擦除成了<code>MyFactory</code>，替换为Object类型，由于不知道确切的类型了，则还需要加入强制类型转换。在虚拟机执行的时候是不知道泛型是啥的，只知道这是一个通过强制类型转换达到目的的普通代码。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyFactory&lt;K extends String, V extends Set&gt;&#123;    private K key;    private V sets;&#125;&#x2F;&#x2F; 擦除后public class MyFactory&#123;    private String key;    private Set sets;&#125;</code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><h2 id="泛型类"><a href="#泛型类" class="headerlink" title="泛型类"></a>泛型类</h2><ul><li>接口中使用泛型与泛型类中是类似的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class MyFactory &lt;T,U&gt;&#123;    public MyFactory() &#123;    &#125;    public MyFactory(T first, U second) &#123;        this.first &#x3D; first;        this.second &#x3D; second;    &#125;    private T first;    private U second;    public T getFirst() &#123;        return first;    &#125;    public U getSecond() &#123;        return second;    &#125;    public static void main(String[] args) &#123;        MyFactory&lt;Integer, String&gt; factory &#x3D; new MyFactory&lt;&gt;(1,&quot;ohbug.cn&quot;);        System.out.println(factory.getFirst());        System.out.println(factory.getSecond());    &#125;&#125;&#x2F;&#x2F;out1ohbug.cn</code></pre><h2 id="泛型方法"><a href="#泛型方法" class="headerlink" title="泛型方法"></a>泛型方法</h2><ul><li>泛型方法不一定非要使用在泛型类中。声明泛型方法的时候，必须在返回值前面加上泛型声明<pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 返回值为T的second方法public static &lt;T,Y&gt; T second(T i, Y j) &#123;&#125;&#x2F;&#x2F; 返回值为void的first方法public static &lt;T,Y&gt; void first(T i, Y j) &#123;&#125;</code></pre></li></ul><h2 id="泛型参数限定"><a href="#泛型参数限定" class="headerlink" title="泛型参数限定"></a>泛型参数限定</h2><h3 id="extends"><a href="#extends" class="headerlink" title="extends"></a>extends</h3><ul><li><p><code>&lt;T extends AutoCloseable&gt;</code>上界为<code>AutoCloseable</code>。即传入的参数必须是<code>AutoCloseable</code>以及子类。</p></li><li><p><code>&lt;T extends Runnable &amp; AutoCloseable&gt;</code>多重限定，但只可以有一个是类，且如果是类必须放在最前面。</p></li><li><p><code>Son[]</code>可直接赋值给<code>Father[]</code>，这称为协变，数组随元素类型变化而变化。但是<code>ArrayList&lt;Son&gt;</code>并不可以赋值给<code>ArrayList&lt;Father&gt;</code>。</p></li><li><p><code>&lt;T extends A&gt;</code>和<code>&lt;? extends A&gt;</code>的区别</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">public &lt;T extends String&gt; void  fun1(ArrayList&lt;T&gt; list) &#123;    for (T t : list) &#123;        System.out.println(t);    &#125;    T t &#x3D; list.get(1);    list.add((T) &quot;fun1&quot;);&#125;public void fun2(ArrayList&lt;? extends String&gt; list)&#123;    for (String s : list) &#123;        System.out.println(s);    &#125;    String s &#x3D; list.get(1);    list.add((String)&quot;fun1&quot;); &#x2F;&#x2F;error&#125;&#x2F;** 从这也可以看出来，T可以直接当作一个类型在其作用域内使用，返回值更加灵活，且可以对形参进行增删操作    而?类型不可以在作用域内使用，返回值更加确定，且不可对形参操作    由此可以得出结论：如果不希望形参被修改则需用? 类型，否则T类型更加灵活。    *&#x2F;</code></pre></li></ul><h3 id="super"><a href="#super" class="headerlink" title="super"></a>super</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 任何类型的数组都适用的方法    public static  &lt;T&gt; void filter(T[] arrs, Predicate&lt;? super T&gt; test) &#123;        for (T arr : arrs) &#123;            if (test.test(arr)) &#123;                System.out.println(arr);            &#125;        &#125;    &#125;    &#x2F;&#x2F;use    Integer[] arr &#x3D; &#123;21,52,0,1,63,52,91,2,4,2,3,9,8,1,100,22&#125;;    &#x2F;&#x2F; 打印arr中大于10的元素    filter(arr,e -&gt; e&gt;10);</code></pre><ul><li><code>Predicate&lt;? super T&gt;</code>，先想象T为一个具体类型Son，他是Father的子类，这里写为了<code>Predicate&lt;T&gt;</code>也是可以运行的，但是方法签名就将实参限制的太死了，若传入是Son数组，则后面只能是Son类型的函数时接口，如果我们需要使用父类的时候，而前面是子类数组，这样就行不通了。所以改为<code>Predicate&lt;? super T&gt;</code>，此时传入子类数组，依旧可以传入父类的判断逻辑。</li></ul><h2 id="通配符捕获"><a href="#通配符捕获" class="headerlink" title="通配符捕获"></a>通配符捕获</h2><ul><li>之前提到了T可以作为一个类型来定义变量，而? 是不可以的，如果就是用? 定义该怎么来。</li><li>如下通过添加一个其他的泛型方法，其他的泛型方法中的T就会捕获?的真是类型，从而可以使用T进行定义变量。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void get(List&lt;? extends Father&gt; list, int i) &#123;    &#x2F;&#x2F;error    &#x2F;&#x2F; ? f &#x3D; list.get(0);    Father father &#x3D; swap(list, i);    System.out.println(father);&#125;private static &lt;T&gt; T swap(List&lt;T&gt; list, int i) &#123;    T e &#x3D; list.get(i);    return e;&#125;public static void main(String[] args) &#123;    List&lt;Father&gt; fathers &#x3D; Arrays.asList(new Father(&quot;Qidai&quot;));    get(fathers, 0);&#125;&#x2F;&#x2F; out Father&#123;name&#x3D;&#39;Qidai&#39;&#125;</code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
    <category term="todo" scheme="https://ohbug.cn/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>MySQL必知必会 {一}</title>
    <link href="https://ohbug.cn/post/mysql/mysqlmustknow.html"/>
    <id>https://ohbug.cn/post/mysql/mysqlmustknow.html</id>
    <published>2023-01-16T13:08:37.000Z</published>
    <updated>2023-01-24T12:50:37.286Z</updated>
    
    <content type="html"><![CDATA[<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>所有操作的数据源来自《MySQL必知必会》，使用MySQL 8.0 进行学习</p></blockquote><p><img src="/img/mysql/mysqlstruc.png#pic_center"></p><ul><li>MySQL 可以分为 Server 层和存储引擎层两部分<ul><li>Server 层包括连接器、分析器、优化器、执行器等，涵盖 MySQL 的大多数核心服务功能，以及所有的内置函数（如日期、时间、数学和加密函数等），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</li><li>存储引擎层负责数据的存储和提取。其架构模式是插件式的，支持 InnoDB、MyISAM、Memory 等多个存储引擎。</li></ul></li></ul><h1 id="Select过程"><a href="#Select过程" class="headerlink" title="Select过程"></a>Select过程</h1><ul><li>连接器：如果用户名密码认证通过，连接器会得到相对应登入用户的该有权限。之后，这个连接里面的权限判断逻辑，都将依赖于此时读到的权限。这就意味着，一个用户成功建立连接后，即使你用管理员账号对这个用户的权限做了修改，也不会影响已经存在连接的权限。修改完成后，只有再新建的连接才会使用新的权限设置。</li><li>分析器：MySQL 需要知道你要做什么，因此需要对 SQL 语句做解析。</li><li>优化器：优化器是在表里面有多个索引的时候，决定使用哪个索引；或者在一个语句有多表关联（join）的时候，决定各个表的连接顺序。以达到最高的执行效率。</li><li>执行器：负责SQL的执行。</li></ul><h1 id="Update过程"><a href="#Update过程" class="headerlink" title="Update过程"></a>Update过程</h1><ul><li>大致与SELECT的过程是一样的，中间不一样的涉及到了两个重要的日志模块，redo log（重做日志）和 binlog（归档日志）。</li></ul><h2 id="redo-Log-（InnoDB特有）"><a href="#redo-Log-（InnoDB特有）" class="headerlink" title="redo Log （InnoDB特有）"></a>redo Log （InnoDB特有）</h2><ul><li>在 MySQL里若每一次的更新操作都需要写进磁盘，然后磁盘也要找到对应的那条记录，然后再更新，整个过程 IO 成本、查找成本都很高。为了解决这个问题，MySQL 的设计者就用了先写入日志文件后将日志中的条目总和一并写入磁盘中的思路来提升更新效率。</li><li>先写日志再写磁盘的就是MySQL 里经常说到的 WAL 技术，WAL 的全称是 Write-Ahead Logging。比如当有一条记录需要更新的时候，InnoDB 引擎就会先把记录写到 redo log里面，并更新内存，这个时候更新就算完成了。同时，InnoDB 引擎会在适当的时候，将这个操作记录更新到磁盘里面，而这个更新往往是在系统比较空闲的时候做。若更新相当频繁以至于redo log写满了，则需要先暂停更新操作，将一部分redo log写入磁盘以腾出新空间来供新的更新操作记录。</li><li>InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB，那么总共就可以记录 4GB 的操作。从头开始写，写到末尾就又回到开头循环写，类似一个循环队列。</li><li>有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为crash-safe。</li></ul><h2 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h2><ul><li>处理InnoDB特有的，Server层自己的日志叫做 bin log。bin log日志只能用于归档。</li></ul><h2 id="redo-log与bin-log-区别"><a href="#redo-log与bin-log-区别" class="headerlink" title="redo log与bin log 区别"></a>redo log与bin log 区别</h2><ul><li>redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；bin log 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID&#x3D;2 这一行的 c 字段加 1 ”。</li><li>redo log 是循环写的，空间固定会用完；bin log 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。</li></ul><h2 id="update内部流程"><a href="#update内部流程" class="headerlink" title="update内部流程"></a>update内部流程</h2><ul><li>先找主键，id是主键，引擎直接用树搜索找到这一行。如果 ID&#x3D;2 这一行所在的数据页本来就在内存中，就直接返回给执行器；否则，需要先从磁盘读入内存，然后再返回。</li><li>执行器拿到引擎给的行数据，把这个值加上 1，比如原来是 N，现在就是 N+1，得到新的一行数据，再调用引擎接口写入这行新数据。</li><li>引擎将这行新数据更新到内存中，同时将这个更新操作记录到 redo log 里面，此时 redo log 处于 prepare 状态。然后告知执行器执行完成了，随时可以提交事务。</li><li>执行器生成这个操作的 binlog，并把 binlog 写入磁盘。</li><li>执行器调用引擎的提交事务接口，引擎把刚刚写入的 redo log 改成提交（commit）状态，更新完成。</li></ul><h2 id="redo-log两段提交"><a href="#redo-log两段提交" class="headerlink" title="redo log两段提交"></a>redo log两段提交</h2><ul><li>redo log 和 bin log 都可以用于表示事务的提交状态，而两阶段提交就是让这两个状态保持逻辑上的一致。</li></ul><details class="custom-details"><summary>不采用两段式提交的结果</summary><p>由于 redo log 和 binlog 是两个独立的逻辑，如果不用两阶段提交，要么就是先写完 redo log 再写 binlog，或者采用反过来的顺序。我们看看这两种方式会有什么问题。</p><p>仍然用前面的 update 语句来做例子。假设当前 ID&#x3D;2 的行，字段 c 的值是 0，再假设执行 update 语句过程中在写完第一个日志后，第二个日志还没有写完期间发生了 crash，会出现什么情况呢？</p><p>先写 redo log 后写 binlog。假设在 redo log 写完，binlog 还没有写完的时候，MySQL 进程异常重启。由于我们前面说过的，redo log 写完之后，系统即使崩溃，仍然能够把数据恢复回来，所以恢复后这一行 c 的值是 1。<br>但是由于 binlog 没写完就 crash 了，这时候 binlog 里面就没有记录这个语句。因此，之后备份日志的时候，存起来的 binlog 里面就没有这条语句。<br>然后你会发现，如果需要用这个 binlog 来恢复临时库的话，由于这个语句的 binlog 丢失，这个临时库就会少了这一次更新，恢复出来的这一行 c 的值就是 0，与原库的值不同。<br>先写 binlog 后写 redo log。如果在 binlog 写完之后 crash，由于 redo log 还没写，崩溃恢复以后这个事务无效，所以这一行 c 的值是 0。但是 binlog 里面已经记录了“把 c 从 0 改成 1”这个日志。所以，在之后用 binlog 来恢复的时候就多了一个事务出来，恢复出来的这一行 c 的值就是 1，与原库的值不同。<br>可以看到，如果不使用“两阶段提交”，那么数据库的状态就有可能和用它的日志恢复出来的库的状态不一致。</p></details><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>redo log 用于保证 crash-safe 能力。<code>innodb_flush_log_at_trx_commit</code> 这个参数设置成 1 的时候，表示每次事务的 redo log 都直接持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后数据不丢失。<br><code>sync_binlog</code> 这个参数设置成 1 的时候，表示每次事务的 binlog 都持久化到磁盘。这个参数设置成 1，这样可以保证 MySQL 异常重启之后 binlog 不丢失。</p></blockquote><ul><li><code>show columns from customers;</code> 快捷语句 ：<code>describe customers;</code>。</li><li>查看表的创建语句 <code>show create tables customers;</code>。</li></ul><h1 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h1><ul><li>去重：<code>select distinct vend_id from products;</code>，<code>distinct</code>应用于所有列，即把要查询字段当作一个整体去重。</li><li>限制：<code>select * from customers limit 5;</code> 零到五行，<code>limit 3,5</code>，从第3个往后5个。</li><li>排序：<code>select prod_name from products order by prod_price ;</code>，<code>order by</code>后可以是显示列也可以是其他列，也可以是按照多个列排序。<code>DESC</code>降序，默 认为升序<code>ASC</code>。 <code>order by</code> 应位于<code>where</code>之后。</li><li>where：与串对比时需要加单引号。<ul><li>比较运算符：<code>&gt;</code>， <code>&lt;</code>，<code>=</code> ，<code>is null</code> …</li><li>逻辑运算符：<code>and</code> ，<code>or</code> ,<code>and</code> 优先级高于 <code>or</code>。<code>in</code>是一个范围，<code>in</code>一般比<code>or</code>执行快。<code>not</code>可对<code>in</code>，<code>exists</code>，<code>between</code>取反。</li><li><code>like</code>：<code>%</code>任意字符任意次数，搜索区分大小写，<code>%</code>不可匹配<code>null</code>。<code>_</code>单个字符。</li></ul></li></ul><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.runoob.com/mysql/mysql-functions.html">https://www.runoob.com/mysql/mysql-functions.html</a></p></blockquote><ul><li><code>avg</code> 自动忽略null。</li><li><code>count(*)</code>不忽略null，<code>count(column)</code>忽略null。</li></ul><h1 id="Group-by"><a href="#Group-by" class="headerlink" title="Group by"></a>Group by</h1><ul><li>可以包含任意多的列名，数据将在最后的列上进行分组汇总。</li><li>Group by中出现的列必须是检索列，Select中除聚集计算外，每个列必须在group by中给出。</li><li>null值作为单独一个分组返回。</li><li>必须位于where之后。 order by之前。</li><li>with rollup，得到每个分组的汇总信息。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; select vend_id,count(*) as num_prods from products group by vend_id with rollup;+---------+-----------+| vend_id | num_prods |+---------+-----------+|    1001 |         3 ||    1002 |         2 ||    1003 |         7 ||    1005 |         2 ||    NULL |        14 |+---------+-----------+5 rows in set (0.29 sec)mysql&gt; select vend_id,count(*) as num_prods from products group by vend_id;+---------+-----------+| vend_id | num_prods |+---------+-----------+|    1001 |         3 ||    1002 |         2 ||    1003 |         7 ||    1005 |         2 |+---------+-----------+4 rows in set (0.00 sec)</code></pre><h1 id="having"><a href="#having" class="headerlink" title="having"></a>having</h1><ul><li>where针对行过滤，having针对分组过滤。WHERE 在数据分组前进行过滤， HAVING在数据分组后进行过滤。</li><li><strong>子查询</strong>：列必须匹配在WHERE子句中使用子查询， 应该保证SELECT语句具有与WHERE子句中相同数目的列。 通常子查询将返回单个列并且与单个列匹配， 但如果需要也可以使用多个列。</li></ul><h1 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h1><ul><li>UNION 中的每个查询必须包含相同的列、 表达式或聚集函数（不过各个列不需要以相同的次序列出） 。</li><li>UNION 从查询结果集中自动去除了重复的行，如果想返回所有匹配行， 可使用UNION ALL。</li><li>在用UNION 组合查询时， 只能使用一条ORDER BY 子句， 它必须出现在最后一条SELECT 语句之后。</li></ul><h1 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h1> <pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE VIEW productcustomers AS SQL</code></pre><ul><li>视图是虚拟的表。 与包含数据的表不一样， 视图只包含使用时动态检索数据的查询。视图本身不包含数据， 因此它们返回的数据是从其他表中检索出来的。</li><li>在添加或更改这些表中的数据时， 视图将返回改变过的数据。</li><li>视图可以嵌套， 即可以利用从其他视图中检索数据的查询来构造一个视图。</li><li>视图不能索引， 也不能有关联的触发器或默认值。</li><li>视图可以和表一起使用。 例如， 编写一条联结表和视图的SELECT 语句。</li></ul><h1 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h1><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.yiibai.com/mysql/stored-procedure.html#article-start">https://www.yiibai.com/mysql/stored-procedure.html#article-start</a><br><a href="https://blog.csdn.net/whf_a/article/details/114871866">https://blog.csdn.net/whf_a/article/details/114871866</a><br>SQLSTATE状态码：<a href="https://blog.csdn.net/cao478208248/article/details/27647419">https://blog.csdn.net/cao478208248/article/details/27647419</a></p></blockquote><ul><li>简单、 安全、 高性能，因为存储过程得创建是编译后再存储的，所以使用存储过程比使用单独的SQL语句要快。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 声明变量的语法DECLARE variable_name datatype(size) DEFAULT default_value;-- 设置变量值SET total_count &#x3D; 10;-- 也可以用into方式设置变量值SELECT COUNT(*) INTO total_products FROM products</code></pre><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 模板，当使用图形化界面时，可省略DELIMITERDELIMITER &#x2F;&#x2F; CREATE PROCEDURE GetAllProducts()   BEGIN   SELECT *  FROM products;   END &#x2F;&#x2F;DELIMITER ;</code></pre><ul><li><code>DELIMITER \\</code>语句将标准分隔符 <code>;</code>更改为：<code>//</code>。<code>BEGIN </code>和<code>END</code>之间的部分称为存储过程的主体。</li></ul><p>MySQL游标只能用于存储过程（和函数） </p><h1 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h1><ul><li>创建触发器需要四条信息：触发器名；触发器关联的表；触发器应该响应的活动（DELETE 、 INSERT 或UPDATE ） ；触发器何时执行（处理之前或之后） 。</li><li>触发器名称应遵循命名约定<code>[trigger time]_[table name]_[trigger event]</code>，例如<code>before_employees_update</code>.</li><li>只有表才支持触发器， 视图不支持，每个表每个事件每次只允许一个触发器。单一触发器不能与多个事件或多个表关联。</li><li>如果before触发器执行失败，sql也会执行失败，sql在执行失败时，after型触发器不会执行，如果after触发器执行失败，sql会回滚。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">CREATE TRIGGER trigger_name trigger_time trigger_event ON table_name FOR EACH ROW BEGIN ... END;</code></pre><h2 id="INSERT"><a href="#INSERT" class="headerlink" title="INSERT"></a>INSERT</h2><ul><li>在INSERT 触发器代码内， 可引用一个名为 <code>NEW</code> 的虚拟表， 访问被插入的行；</li><li>在BEFORE INSERT 触发器中， <code>NEW</code> 中的值也可以被更新（允许更改被插入的值） ；</li><li>对于<code>AUTO_INCREMENT</code> 列， <code>NEW</code> 在INSERT 执行之前包含0 ， 在INSERT 执行之后包含新的自动生成值。</li><li><strong>实例：</strong>从下面可以看到可以从 <code>new</code> 虚拟表中获得自增后的最新值。且注意在MySQL8中，触发器不再支持由SELECT方式的返回值，只能将结果放入一个变量中带回。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql&gt; desc orders;+------------+----------+------+-----+---------+----------------+| Field      | Type     | Null | Key | Default | Extra          |+------------+----------+------+-----+---------+----------------+| order_num  | int      | NO   | PRI | NULL    | auto_increment || order_date | datetime | NO   |     | NULL    |                || cust_id    | int      | NO   | MUL | NULL    |                |+------------+----------+------+-----+---------+----------------+3 rows in set (0.00 sec)mysql&gt; select * from orders;+-----------+---------------------+---------+| order_num | order_date          | cust_id |+-----------+---------------------+---------+|     20005 | 2005-09-01 00:00:00 |   10001 ||     20006 | 2005-09-12 00:00:00 |   10003 ||     20007 | 2005-09-30 00:00:00 |   10004 ||     20008 | 2005-10-03 00:00:00 |   10005 ||     20009 | 2005-10-08 00:00:00 |   10001 ||     20011 | 2006-02-23 00:00:00 |   10001 ||     20012 | 2006-02-23 00:00:00 |   10001 |+-----------+---------------------+---------+7 rows in set (0.00 sec)mysql&gt; create trigger after_insert_orders after insert on orders for each row select new.order_num into @a;Query OK, 0 rows affected (1.64 sec)mysql&gt; select @a;+------------+| @a         |+------------+| NULL       |+------------+1 row in set (0.00 sec)mysql&gt; insert into orders(order_Date,cust_id) values(&#39;2006-05-23 00:00:00&#39;,10001);Query OK, 1 row affected (0.05 sec)mysql&gt; select @a;+-------+| @a    |+-------+| 20013 |+-------+1 row in set (0.00 sec)</code></pre><h2 id="DELETE"><a href="#DELETE" class="headerlink" title="DELETE"></a>DELETE</h2><ul><li>在DELETE 触发器代码内， 你可以引用一个名为 <code>OLD</code> 的虚拟表， 访问被删除的行；<code>OLD</code> 中的值全都是只读的， 不能更新。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 从info中删除的信息插入info_copy表中。mysql&gt; select * from info;+----+---------------+------+| no | name          | age  |+----+---------------+------+|  1 | Ricky Simmons |  867 ||  2 | Murakami Rena |   82 ||  3 | Ueda Kenta    |  950 ||  4 | Ikeda Akina   |  681 ||  5 | Fan Yunxi     |  583 |+----+---------------+------+5 rows in set (0.00 sec)mysql&gt; select * from info_copy;Empty set (0.00 sec)mysql&gt; create trigger before_delete_info before delete on info for each row insert into info_copy(no,name,age) values (old.no,old.name,old.age);Query OK, 0 rows affected (0.11 sec)mysql&gt; delete from info where no&#x3D;1;Query OK, 1 row affected (0.03 sec)mysql&gt; select * from info;+----+---------------+------+| no | name          | age  |+----+---------------+------+|  2 | Murakami Rena |   82 ||  3 | Ueda Kenta    |  950 ||  4 | Ikeda Akina   |  681 ||  5 | Fan Yunxi     |  583 |+----+---------------+------+4 rows in set (0.00 sec)mysql&gt; select * from info_copy;+----+---------------+------+| no | name          | age  |+----+---------------+------+|  1 | Ricky Simmons |  867 |+----+---------------+------+1 row in set (0.00 sec)</code></pre><h2 id="UPDATE"><a href="#UPDATE" class="headerlink" title="UPDATE"></a>UPDATE</h2><ul><li>在UPDATE 触发器代码中， 你可以引用一个名为<code>OLD </code>的虚拟表访问以前（UPDATE 语句前） 的值， 引用一个名为<code>NEW </code>的虚拟表访问新更新的值；</li><li>在BEFORE UPDATE 触发器中， <code>NEW </code>中的值可能也被更新（允许更改将要用于UPDATE 语句中的值） ；</li><li><code>OLD </code>中的值全都是只读的， 不能更新。</li></ul><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">-- 在更新的时候，将指定no的一行信息的名字改为 Qidai。mysql&gt; select * from info;+----+---------------+------+| no | name          | age  |+----+---------------+------+|  2 | Murakami Rena |   82 ||  3 | Ueda Kenta    |  950 ||  4 | Ikeda Akina   |  681 ||  5 | Fan Yunxi     |  583 |+----+---------------+------+4 rows in set (0.00 sec)mysql&gt; update info set age&#x3D;11 where no&#x3D;2;Query OK, 1 row affected (0.09 sec)Rows matched: 1  Changed: 1  Warnings: 0mysql&gt; select * from info;+----+-------------+------+| no | name        | age  |+----+-------------+------+|  2 | Qidai       |   11 ||  3 | Ueda Kenta  |  950 ||  4 | Ikeda Akina |  681 ||  5 | Fan Yunxi   |  583 |+----+-------------+------+4 rows in set (0.00 sec)</code></pre><h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><ul><li>开始一个事务：<code>START TRANSACTION;</code>。</li><li>回滚一个事务：<code>ROLLBACK</code>。</li><li>设置保存点：<code>SAVEPOINT delete1;</code>。</li><li>混滚至具体的保存点：<code>ROLLBACK TO delete1;</code>。</li><li>设置不自动提交：<code>SET autocommit=0;</code>。</li><li>事务处理用来管理 <code>INSERT</code> 、 <code>UPDATE</code> 和 <code>DELETE</code> 语句。</li><li>保留点在事务处理完成（执行一条 <code>ROLLBACK</code> 或 <code>COMMIT</code> ） 后自动释放 ，也可以用<code>RELEASE SAVEPOINT</code> 明确地释放保留点。</li><li><code>autocommit</code> 标志是针对每个连接而不是服务器的。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;&lt;span class=&quot;custom-blockquote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; d</summary>
      
    
    
    
    <category term="MySQL基础" scheme="https://ohbug.cn/categories/MySQL%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="MySQL" scheme="https://ohbug.cn/tags/MySQL/"/>
    
    <category term="《MySQL必知必会》" scheme="https://ohbug.cn/tags/%E3%80%8AMySQL%E5%BF%85%E7%9F%A5%E5%BF%85%E4%BC%9A%E3%80%8B/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：抽象类，String，枚举</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava3.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava3.html</id>
    <published>2023-01-13T08:15:35.000Z</published>
    <updated>2023-02-02T10:10:38.637Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><h1 id="抽象类"><a href="#抽象类" class="headerlink" title="抽象类"></a>抽象类</h1><ul><li>定义</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public abstract class Person &#123;    public abstract void call();&#125;</code></pre><ul><li>子类继承抽象类，则必须实现抽象类的抽象方法，或者使得子类也定义为抽象类。接口中同样有这样的规定。</li><li>需要注意的是，虽然说的类，但依旧不可以使用抽象类实例化对象，必须使用其子类来创建对象，或者使用如下方法。接口中有同样的规定。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">Person p &#x3D; new Person() &#123;    @Override    public void call() &#123;        System.out.println(&quot;person call method&quot;);    &#125;&#125;;p.call(); &#x2F;&#x2F; out -&gt;   person call method</code></pre><h2 id="抽象类和接口"><a href="#抽象类和接口" class="headerlink" title="抽象类和接口"></a>抽象类和接口</h2><ul><li>在Java8更新后，接口中同样可以实现方法体了，这样使得抽象类与接口基本没啥不一样的了，但是还有几点不同<ul><li>接口中只能定义常量， 而抽象类中可以定义实例变量。</li><li>一个普通类只可以继承一个抽象类，而可以实现多个接口。</li><li>抽象类的使用更多的是一种语法限制一种默认实现，使得编程的时候减少错误的发生。而接口更多的是一种能力的实现。</li></ul></li></ul><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><ul><li>枚举常量在静态成员之前构造，所以不能在枚举构造器中引用之外的静态变量。</li><li>枚举的构造器都是私有的。</li></ul><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p><img src="/img/java/error.png" alt="error"></p><h2 id="finally-代码块"><a href="#finally-代码块" class="headerlink" title="finally 代码块"></a>finally 代码块</h2><ul><li>最终都会执行，当try正常执行后finally执行。若try中有异常被捕获后，进入catch执行后finally执行。若try中有异常没有被捕获，则finally在异常抛出前被捕获。</li><li>catch非必须。</li><li>finally中的return会覆盖掉之前的所有返回值，并且会覆盖掉所有异常。</li><li>若在finally中抛出异常，则也会覆盖掉之前抛出的异常。</li><li>return若出现在try或者catch中，则finally执行完毕后才执行return。如下在执行return时会将ret暂时保存起来，而finally修改的值并不会被修改。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    System.out.println(Main.getRet());&#125;public static int getRet() &#123;    int ret &#x3D; 0;    try&#123;        System.out.println(&quot;try ...&quot;);        return ret;    &#125;finally &#123;        System.out.println(&quot;finally...&quot;);        ret &#x3D; 2;    &#125;&#125;&#x2F;&#x2F; out try ...finally...0</code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static int getRet() &#123;    int ret &#x3D; 0;    try&#123;        ret &#x3D; 1&#x2F;0;    &#125;finally &#123;        System.out.println(&quot;finally...&quot;);        return ret &#x3D; 2;    &#125;&#125;&#x2F;&#x2F;out finally...2</code></pre><h2 id="try自动释放资源"><a href="#try自动释放资源" class="headerlink" title="try自动释放资源"></a>try自动释放资源</h2><ul><li>位于<code>try()</code>括号中的资源将在try执行完毕后自动关闭。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">try(FileInputStream in &#x3D; new FileInputStream(&quot;filename&quot;))&#123;&#125; catch (Exception e) &#123;    throw new RuntimeException(e);&#125; </code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>包装类<code>Integer</code>之类的应使用<code>valueOf()</code>，因为除了<code>Float</code>和<code>Double</code>，其他包装类都会缓存一些包装类对象，使用<code>valueOf()</code>更高效。</p></blockquote><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="构造"><a href="#构造" class="headerlink" title="构造"></a>构造</h2><ul><li>在构造器<code>String(String)</code>的注释上找到一句话<code> the newly created string is a copy of the argument string.</code>，即使用构造方法创建的对象是一个副本，也就是说如下代码。s1是不等于s2的。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s1 &#x3D; &quot;A&quot;;String s2 &#x3D; new String(&quot;A&quot;);</code></pre><ul><li>下面则看一个比较被常调用的构造过程，总体的思路是循环判断每个字符是否可单字节编码，只要有一个不可以单字节编码，则整体切换为双字节编码。如下是详细调用过程</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">    public static void main(String[] args) &#123;        char[] chars &#x3D; &#123;&#39;Q&#39;,&#39;i&#39;,&#39;D&#39;,&#39;a&#39;,&#39;i&#39;&#125;;        String s &#x3D; new String(chars, 2, 2);        System.out.println(s);    &#125;    &#x2F;&#x2F; 下标从0开始算，offset&#x3D;2且count&#x3D;2，即从char数组中的第三个字母和第四个字母组成字符串返回    public String(char value[], int offset, int count) &#123;        this(value, offset, count, rangeCheck(value, offset, count));    &#125;    &#x2F;&#x2F; 这里的Void sig表示接受一次方法，此方法是无返回值的 ,此处的rangeCheck是来检查参数不出界的。    String(char[] value, int off, int len, Void sig) &#123;        if (len &#x3D;&#x3D; 0) &#123;            this.value &#x3D; &quot;&quot;.value;            this.coder &#x3D; &quot;&quot;.coder;            return;        &#125;        &#x2F;&#x2F; COMPACT_STRINGS默认为true        if (COMPACT_STRINGS) &#123;            &#x2F;&#x2F; 若此时返回为空，代表char数组中必有需要双字节编码的字符            &#x2F;&#x2F; 不为空的话，则代表char数组中字符都可以单字节编码，且已经都从char数组转换为了byte数组            byte[] val &#x3D; StringUTF16.compress(value, off, len);            if (val !&#x3D; null) &#123;              &#x2F;&#x2F; 转换好的数组直接赋值即可是String的底层实现。                this.value &#x3D; val;                this.coder &#x3D; LATIN1;                return;            &#125;        &#125;        &#x2F;&#x2F; 到这就是需要处理char中的双字符编码了        this.coder &#x3D; UTF16;        &#x2F;&#x2F;        this.value &#x3D; StringUTF16.toBytes(value, off, len);    &#125;    public static byte[] compress(char[] val, int off, int len) &#123;        byte[] ret &#x3D; new byte[len];        &#x2F;&#x2F; 若compress返回的与len参数相同，证明char中都是可单字节编码的且已经转换为byte数组，可直接用于String的底层实现了        &#x2F;&#x2F; 否则不同表示必须是有双字节编码了，直接返回null，再由上层函数进行下一步处理。        if (compress(val, off, ret, 0, len) &#x3D;&#x3D; len) &#123;            return ret;        &#125;        return null;    &#125;    &#x2F;&#x2F; compressedCopy char[] -&gt; byte[]    &#x2F;&#x2F; 整体方法思路就是循环判断每个字符是否是可以单字节编码的，如果可以，则该位置的字符直接从char转为byte，否则的话就结束本方法返回0    public static int compress(char[] src, int srcOff, byte[] dst, int dstOff, int len) &#123;        for (int i &#x3D; 0; i &lt; len; i++) &#123;            char c &#x3D; src[srcOff];            &#x2F;&#x2F; 单字符可编码，即是2的八次方即0到255内的字符内的字符            &#x2F;&#x2F; c&gt;0xff就是循环判断每个char是否是单字节可编码的            if (c &gt; 0xFF) &#123;              &#x2F;&#x2F; 进来后表示char数组中此位置的字符必须双字节编码的字符，则len&#x3D;0，中止循环，return 0                len &#x3D; 0;                break;            &#125;            &#x2F;&#x2F; 到这表示此位置的字符是单字节可编码的，则将char转byte            dst[dstOff] &#x3D; (byte)c;            srcOff++;            dstOff++;        &#125;        return len;    &#125;    &#x2F;&#x2F; 双字节的字符转byte的处理方法&#96;&#96;    public static byte[] toBytes(char[] value, int off, int len) &#123;        byte[] val &#x3D; newBytesFor(len);        for (int i &#x3D; 0; i &lt; len; i++) &#123;            putChar(val, i, value[off]);            off++;        &#125;        return val;    &#125;    &#x2F;&#x2F; 得到一个存储双字符编码长度的数组    public static byte[] newBytesFor(int len) &#123;        if (len &lt; 0) &#123;            throw new NegativeArraySizeException();        &#125;        if (len &gt; MAX_LENGTH) &#123;            throw new OutOfMemoryError(&quot;UTF16 String size is &quot; + len +                                       &quot;, should be less than &quot; + MAX_LENGTH);        &#125;        &#x2F;&#x2F; 返回你指定字符个数的二倍大小的数组        return new byte[len &lt;&lt; 1];    &#125;    static void putChar(byte[] val, int index, int c) &#123;      &#x2F;&#x2F; 边界检查，index&gt;&#x3D;0且小于字符数        assert index &gt;&#x3D; 0 &amp;&amp; index &lt; length(val) : &quot;Trusted caller missed bounds check&quot;;        &#x2F;&#x2F; index &#x3D; index&lt;&lt;1 ，即index*2        index &lt;&lt;&#x3D; 1;        &#x2F;&#x2F; 这里是将char中的双字符一个个的进行处理，因为要双字符则是16位二进制，一个字符八个二进制        &#x2F;&#x2F; 这里移位就是将高位和低位分别放入byte数组中。        val[index++] &#x3D; (byte)(c &gt;&gt; HI_BYTE_SHIFT);        val[index]   &#x3D; (byte)(c &gt;&gt; LO_BYTE_SHIFT);    &#125;    static final int HI_BYTE_SHIFT;  &#x2F;&#x2F;0     static final int LO_BYTE_SHIFT;  &#x2F;&#x2F;8</code></pre><h2 id="存储实现"><a href="#存储实现" class="headerlink" title="存储实现"></a>存储实现</h2><ul><li>在Java8及之前，底层存储还是<code>private final char value[]</code>， 自从9版本开始，底层实现更改了<code>private final byte[] value;</code>。其原因是：若存储字符串由英文字符组成，则在编码的时候可以使用一个byte的大小就可以表示，而存储汉字的时候，是由两个byte来实现的，对比之前的char存储实现，在最理想情况下，byte数组要比char数组要节省一半的空间。</li></ul><h2 id="length"><a href="#length" class="headerlink" title="length( )"></a>length( )</h2><ul><li>因为其存储为字节数组，之前字符数组的时候，String的长度是计算char的个数，而现在的length的实现有些许变化。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">  @Native static final byte LATIN1 &#x3D; 0;  @Native static final byte UTF16  &#x3D; 1;  public int length() &#123;      return value.length &gt;&gt; coder();  &#125;  byte coder() &#123;      return COMPACT_STRINGS ? coder : UTF16;   &#x2F;&#x2F; coder 变量可取值 UTF-16和LATIN1  &#125;  static final boolean COMPACT_STRINGS;  static &#123;      COMPACT_STRINGS &#x3D; true;  &#125;&#x2F;&#x2F; use  System.out.println(&quot;Qidai&quot;.length());   &#x2F;&#x2F; 5 其中coder()&#x3D;0  System.out.println(&quot;期待&quot;.length());   &#x2F;&#x2F; 2  其中coder()&#x3D;1</code></pre><ul><li>如上有一个很重要的方法就是<code>coder()</code>，里面一个关键的字段为：<code>COMPACT_STRINGS</code>，其意思是字符串是否采用压缩存储，默认为true，若为false，则字符串始终采用<code>UTF-16</code>编码，否则就是默认开始字符串压缩，这个值是由JVM启动时注入的。</li><li><code>coder()</code>方法中的<code>coder</code>变量是用来标识字符串是否为可以都用单字节编码，可以的话值为<code>LATIN1</code>，否则<code>UTF-16</code>。</li><li>所以<code>coder()</code>方法的逻辑就是看是否采用字符串压缩，是的话则返回<code>coder</code>值，否则返回<code>UTF-16</code>，即返回<code>1</code>。</li><li>解析：如上两个使用，第一个<code>Qidai</code>中每个字符都是可以单字节编码解决的，则<code>coder</code>变量为<code>LATIN1=0</code>，<code>COMPACT_STRINGS=true</code>，则<code>coder()</code>方法返回0，则<code>value.length</code>不变返回5。类似的，第二个使用，期待则<code>coder</code>变量返回1，由于汉字的俩字节编码的，则期待二次的<code>value.length=4</code>，最终<code>coder()</code>方法返回1，<code>4&gt;&gt;1=2</code>，则最终为2。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>String的底层实现的变动进而影响的相关类的实现，比如StringBuffer和StringBuilder的实现。其父类均为AbstractStringBuilder，其内部实现也改为了byte[]，coder的实现方式。</p></blockquote><h2 id="不变性"><a href="#不变性" class="headerlink" title="不变性"></a>不变性</h2><ul><li>String类的注释为：<code>Strings are constant; their values cannot be changed after they are created</code>，即字符串被创建后就不能改变了。</li><li>无论从字符串的不变性从其类的final防止继承，各种私有变量，还是各种常用方法的具体实现就可以看出，都是为了保证String的不可变，常用方法对于String的每次操作都是返回一个新字符串，拿subString方法举例，来说明</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">&#x2F;&#x2F; 最终的实现都是newString，足以说明之前的字符串是不会动的，而只是返回了一个新的字符串对象。public String substring(int beginIndex, int endIndex) &#123;    int length &#x3D; length();    checkBoundsBeginEnd(beginIndex, endIndex, length);    if (beginIndex &#x3D;&#x3D; 0 &amp;&amp; endIndex &#x3D;&#x3D; length) &#123;        return this;    &#125;    int subLen &#x3D; endIndex - beginIndex;    return isLatin1() ? StringLatin1.newString(value, beginIndex, subLen)                      : StringUTF16.newString(value, beginIndex, subLen);&#125;</code></pre><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p><a href="https://www.zhihu.com/question/55994121">https://www.zhihu.com/question/55994121</a><br><a href="http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/">http://tangxman.github.io/2015/07/27/the-difference-of-java-string-pool/</a></p></blockquote><h2 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h2><ul><li>常量池分，静态常量池，运行常量池，以及字符串常量池<ul><li>静态常量池：当java被编译之后，通过javap可以看到属于单独类文件的常量池信息，包括字面量和符号引用。字面量包括字符串，final常量，其他数据类型的值。符号引用包括类和结构的完全限定名，字段名称和描述符，方法名称和描述符。</li><li>运行时常量池：当完成类加载后，将编译成的一个个class文件加载入内存，一个class文件在方法区也对应一个独立的class的区域，其中class文件中的字符串常量将存入字符串常量池，而跟其他的分开。</li><li>字符串常量池：位于方法区外面，为类中的编译期可确定的字符串，后期使用的时候也会加入新的字符串，是全局共享的。创建字符串时首先会从字符串常量池中查找是否有一样的字符串，有则直接返回引用，否则创建一个放入池中。这种操作仅限于<code>String str = &quot;xx&quot;</code>方式，对于<code>String str = new String(&quot;xx&quot;)</code>方式还略有不同。</li></ul></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public static void main(String[] args) &#123;    String sxx1 &#x3D; &quot;QIDAI&quot;;    String sxx2 &#x3D; new String(&quot;Qidai&quot;);    double d1 &#x3D; 1.2;    Animal animal &#x3D; new Animal();&#125;</code></pre><ul><li>如下，类编译后的详细信息，可以看到里面确实包含了一些常量信息，class常量池中存的是字面量和符号引用，也就是说他们存的并不是对象的实例，而是对象的符号引用值。而经过解析之后，也就是把符号引用替换为直接引用，解析的过程会去查询全局字符串池，以保证运行时常量池所引用的字符串与全局字符串池中所引用的是一致的。</li><li>有一个有意思的是double类型的也加入了常量池，但是如果我们修改代码为<code>double d1 = 1.0D</code>，则常量池中就找不到double的信息了，而在最下面的main的汇编代码中就会多一条<code>dconst_1</code>，若是<code>double d1 = 2.0D</code>，则多一个<code>dconst_2</code>，对于float也是如此，我猜测是jvm的优化吧，由于大部分小数是不可完全的精确表示的，所以干脆直接的放入了常量池，而对于这种<code>1.0</code>整的小数，jvm会认出来并直接使用了，这仅仅是个人猜测。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">E:\projects\untitled\target\classes\org\example&gt;javap -v -c Main.classClassfile &#x2F;E:&#x2F;projects&#x2F;untitled&#x2F;target&#x2F;classes&#x2F;org&#x2F;example&#x2F;Main.class  Last modified 2023年1月16日; size 653 bytes  SHA-256 checksum 9a66102117f2905bdc9235cd77869b0de6f0e57cd3d953b8f19ea6b361a5d422  Compiled from &quot;Main.java&quot;public class org.example.Main  minor version: 0  major version: 61  flags: (0x0021) ACC_PUBLIC, ACC_SUPER  this_class: #21                         &#x2F;&#x2F; org&#x2F;example&#x2F;Main  super_class: #2                         &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类  interfaces: 0, fields: 0, methods: 2, attributes: 1Constant pool:                                                                     &#x2F;&#x2F; 静态常量池信息   #1 &#x3D; Methodref          #2.#3          &#x2F;&#x2F; java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         &#x2F;&#x2F; 父类的构造方法，符号引用#2,#3   #2 &#x3D; Class              #4             &#x2F;&#x2F; java&#x2F;lang&#x2F;Object                      &#x2F;&#x2F; 父类object   #3 &#x3D; NameAndType        #5:#6          &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:()V                          &#x2F;&#x2F; 引用5，6，表示无参构造   #4 &#x3D; Utf8               java&#x2F;lang&#x2F;Object   #5 &#x3D; Utf8               &lt;init&gt;   #6 &#x3D; Utf8               ()V   #7 &#x3D; String             #8             &#x2F;&#x2F; QIDAI                       &#x2F;&#x2F; 字符串常量符号引用   #8 &#x3D; Utf8               QIDAI                                         &#x2F;&#x2F; 字符串常量   #9 &#x3D; Class              #10            &#x2F;&#x2F; java&#x2F;lang&#x2F;String              #10 &#x3D; Utf8               java&#x2F;lang&#x2F;String  #11 &#x3D; String             #12            &#x2F;&#x2F; Qidai                       &#x2F;&#x2F; 字符串常量符号引用  #12 &#x3D; Utf8               Qidai                                        &#x2F;&#x2F; 字符串常量  #13 &#x3D; Methodref          #9.#14         &#x2F;&#x2F; java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V   &#x2F;&#x2F; 字符串引用的狗崽方法  #14 &#x3D; NameAndType        #5:#15         &#x2F;&#x2F; &quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V  #15 &#x3D; Utf8               (Ljava&#x2F;lang&#x2F;String;)V                          &#x2F;&#x2F; 字符串的有参构造  #16 &#x3D; Double             1.2d                                         &#x2F;&#x2F; 数值常量  #18 &#x3D; Class              #19            &#x2F;&#x2F; org&#x2F;example&#x2F;Animal         &#x2F;&#x2F; animal 的符号引用  #19 &#x3D; Utf8               org&#x2F;example&#x2F;Animal                           &#x2F;&#x2F; animal 的真实类型  #20 &#x3D; Methodref          #18.#3         &#x2F;&#x2F; org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V   &#x2F;&#x2F; animal 的无参构造  #21 &#x3D; Class              #22            &#x2F;&#x2F; org&#x2F;example&#x2F;Main  #22 &#x3D; Utf8               org&#x2F;example&#x2F;Main  #23 &#x3D; Utf8               Code  #24 &#x3D; Utf8               LineNumberTable  #25 &#x3D; Utf8               LocalVariableTable  #26 &#x3D; Utf8               this  #27 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Main;  #28 &#x3D; Utf8               main  #29 &#x3D; Utf8               ([Ljava&#x2F;lang&#x2F;String;)V  #30 &#x3D; Utf8               args  #31 &#x3D; Utf8               [Ljava&#x2F;lang&#x2F;String;  #32 &#x3D; Utf8               sxx1                               &#x2F;&#x2F; 对象名  #33 &#x3D; Utf8               Ljava&#x2F;lang&#x2F;String;  #34 &#x3D; Utf8               sxx2                               &#x2F;&#x2F; 对象名  #35 &#x3D; Utf8               d1  #36 &#x3D; Utf8               D   #37 &#x3D; Utf8               animal                       &#x2F;&#x2F; 对象名   #38 &#x3D; Utf8               Lorg&#x2F;example&#x2F;Animal;  #39 &#x3D; Utf8               SourceFile  #40 &#x3D; Utf8               Main.java&#123;  public org.example.Main();    descriptor: ()V    flags: (0x0001) ACC_PUBLIC    Code:      stack&#x3D;1, locals&#x3D;1, args_size&#x3D;1         0: aload_0         1: invokespecial #1                  &#x2F;&#x2F; Method java&#x2F;lang&#x2F;Object.&quot;&lt;init&gt;&quot;:()V         4: return      LineNumberTable:        line 10: 0      LocalVariableTable:        Start  Length  Slot  Name   Signature            0       5     0  this   Lorg&#x2F;example&#x2F;Main;  public static void main(java.lang.String[]);    descriptor: ([Ljava&#x2F;lang&#x2F;String;)V    flags: (0x0009) ACC_PUBLIC, ACC_STATIC    Code:      stack&#x3D;3, locals&#x3D;6, args_size&#x3D;1         0: ldc           #7                  &#x2F;&#x2F; String QIDAI         2: astore_1         3: new           #9                  &#x2F;&#x2F; class java&#x2F;lang&#x2F;String         6: dup         7: ldc           #11                 &#x2F;&#x2F; String Qidai         9: invokespecial #13                 &#x2F;&#x2F; Method java&#x2F;lang&#x2F;String.&quot;&lt;init&gt;&quot;:(Ljava&#x2F;lang&#x2F;String;)V        12: astore_2        13: ldc2_w        #16                 &#x2F;&#x2F; double 1.2d        16: dstore_3        17: new           #18                 &#x2F;&#x2F; class org&#x2F;example&#x2F;Animal        20: dup        21: invokespecial #20                 &#x2F;&#x2F; Method org&#x2F;example&#x2F;Animal.&quot;&lt;init&gt;&quot;:()V        24: astore        5        26: return      LineNumberTable:        line 12: 0        line 13: 3        line 14: 13        line 15: 17        line 16: 26      LocalVariableTable:        Start  Length  Slot  Name   Signature            0      27     0  args   [Ljava&#x2F;lang&#x2F;String;            3      24     1  sxx1   Ljava&#x2F;lang&#x2F;String;           13      14     2  sxx2   Ljava&#x2F;lang&#x2F;String;           17      10     3    d1   D           26       1     5 animal   Lorg&#x2F;example&#x2F;Animal;&#125;SourceFile: &quot;Main.java&quot;</code></pre><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">String str &#x3D; new String(&quot;1&quot;);String n &#x3D; &quot;1&quot;;&#x2F;&#x2F;str !&#x3D; n</code></pre><ul><li>上面说创建字符串时会在常量池中寻找,那么<code>new String(&quot;1&quot;)</code>为啥不等于<code>String str = &quot;1&quot;</code>呢？new操作其实是创建了一个真正的对象，所以这个new出来的对象1一定会在堆内存，new出来的对象是引用常量池中的对象的，如果常量池中没有这个对象，new操作就会先在常量池中新建一个常量，然后再引用他。</li></ul><p><img src="/img/java/Stringpool.png"></p><h2 id="intern"><a href="#intern" class="headerlink" title="intern"></a>intern</h2><ul><li>当调用intern方法时，如果池中已经包含一个由equals方法确定的与此string对象相等的字符串，则返回池中的字符串。否则，将此String对象添加到池中，并返回对此String对象的引用。因此，对于任意两个字符串s和t，<code>s.intern（）==t.intern</code>为真，当且仅当<code>s.equals（t）</code>为真。</li></ul><h2 id="拼接"><a href="#拼接" class="headerlink" title="拼接"></a>拼接</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">String s1 &#x3D; &quot;&#39;A&quot; + &quot;B&quot;;String s2 &#x3D; &quot;&#39;A&quot; + new String(&quot;B&quot;);String s3 &#x3D; new String(&quot;A&quot;) + new String(&quot;B&quot;);</code></pre><ul><li>从javap中只发现了一个常量即”A”+”B”，在编译期间可直接确定，并放入了常量池。</li><li>其他的我们可以看到的实现是用到了<code>StringConcatFactory</code>类中的<code>makeConcatWithConstants</code>拼接方法。而并非之前的<code>StringBuilder</code>实现了。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：继承，接口</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava2.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava2.html</id>
    <published>2023-01-11T01:47:37.000Z</published>
    <updated>2023-02-02T10:06:34.937Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><ul><li>子类不可访问父类的私有属性和方法。</li><li>super只是一个关键字，用来指定访问父类的方法和变量以及构造方法，而this是实实在在的对象。</li><li>当一个类继承的父类和实现的接口中有同名方法，则类优先。</li><li>子类重写了父类的方法时，子类的返回值是可更改的。</li><li>多态会确定对象的真实类型进行方法调用。这样写法的弊端是只能调用<code>Father</code>中的方法，如果要调用子类方法，则可以使用<code>instanceof</code>判断，将父类转为子类使用。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">Son son &#x3D; new Son();Father father &#x3D; son;father.getMoneny();  &#x2F;&#x2F; 子类的重写将被执行if(father instanceof Son) &#123;  Son son1 &#x3D; (Son)father;  son1.sonMethod();&#125;</code></pre><h2 id="构造器"><a href="#构造器" class="headerlink" title="构造器"></a>构造器</h2><ul><li>子类初始化，默认调用父类无参构造器，若父类中没有，子类必须在自己的构造器中调用<code>super(params)</code>进行初始化，否则编译出错。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Father &#123;  public Father() &#123;    test();  &#125;  public void test() &#123;  &#125;&#125;class Son extends Father &#123;  private int a &#x3D; 123;  public Son() &#123;&#125;  @Override  public void test() &#123;    System.out.println(a);  &#125;&#125;&#x2F;&#x2F; 使用Son son &#x3D; new Son();son.test();&#x2F;&#x2F; out  0   123 </code></pre><ul><li><code>Son</code>初始化的时候调用父类构造器，父类构造器内调用<code>tes()</code>方法，但是此时<code>Son</code>内的a变量并没被赋值，此时<code>Son</code>继承<code>Father</code>，且实际的类型为<code>Son</code>，则调用重写后的<code>test()</code>方法，输出为<code>0</code>，<code>Father</code>初始化完毕后，子类初始化，<code>a</code>变量得以赋值为<code>123</code>，此时<code>Son son = new Son()</code>执行完毕，<code>son.test()</code>输出<code>123</code>。这是一种不好的代码实践。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Father &#123;  public static String str &#x3D; &quot;father_base&quot;;  public String a &#x3D; &quot;fbase&quot;;  public static void test() &#123;    System.out.println(&quot;fbase--&gt; &quot; + str);  &#125;&#125;class Son extends Father &#123;  public static String str &#x3D; &quot;son_base&quot;;  public String a &#x3D; &quot;sbase&quot;;  public static void test() &#123;    System.out.println(&quot;sbase--&gt; &quot; + str);  &#125;&#125;&#x2F;&#x2F;use  public static void main(String[] args) &#123;    Son son &#x3D; new Son();    System.out.println(son.a);    System.out.println(son.str);    son.test();    Father father &#x3D; son;    System.out.println(father.a);    System.out.println(father.str);    father.test();  &#125;&#x2F;&#x2F; outsbaseson_basesbase--&gt; son_basefbasefather_basefbase--&gt; father_base</code></pre><ul><li><p>上面叫做静态绑定，实例变量，静态变量，静态方法，<code>private</code>方法都是静态绑定的，在编译的时候已经确定下来的。</p></li><li><p><code>protested</code>只可被子类访问，不可被外部类访问，可以被同包内类访问。</p></li></ul><h2 id="细节"><a href="#细节" class="headerlink" title="细节"></a>细节</h2><ul><li>类加载是从要加载的类的父类开始将其加载到内存的，Java的类加载是动态的。</li><li>类的初始化流程：父类静态代码块，子类静态代码块，父类实例代码块，父类构造方法，子类实例代码块，子类构造方法的顺序进行初始化。</li><li>JVM虚拟机的栈，堆，方法区<ul><li>栈：当方法调用时会产生方法压栈，且存放函数的局部变量等。</li><li>方法区：它用于存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码缓存等。</li><li>堆：实例化对象存放的地方</li></ul></li><li>初始化过程中，<ul><li>对象的创建要进行分配内存，包括父类和子类的所有实例变量，不包括静态变量。</li><li>对所有实例变量赋默认值，这一步在初始化之前已经完成。</li><li>执行实例化初始化代码。<code>Person p = new Person()</code>，则<code>Person</code>类信息放入了方法区，<code>p</code>对象引用放入了栈内，而<code>new Person()</code>所创建的对象则放入了堆中，<code>p</code>指向堆中的对象，对象保留了方法区内的类信息的引用。</li></ul></li><li>运行实例方法的时候是根据真实对象来找对于的方法进行执行的，若没有才找父类中的对应方法。</li></ul><h2 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h2><ul><li>破坏封装，若父类更改或者增加了公开方法，则可能直接影响子类的行为，甚至导致逻辑出错。相反，子类也限制了父类随意更改实现的自由。</li><li>在应用到现实生活中时，也并不是一定是严丝合缝的符合实际，鸟都会飞，那继承鸟类之后的企鹅不会飞。</li></ul><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>尽量少使用继承，使用继承时应将父类尽量抽象，将真正公共行为放入父类，也应考虑清楚哪些可以用final修饰以防止子类继承，进而得到更高父类的代码修改的自由度，且部分的功能可以用实现接口来实现比继承更加方便。</p></blockquote><h1 id="接口"><a href="#接口" class="headerlink" title="接口"></a>接口</h1><ul><li><p>所有方法默认为<code>public</code>。定义的变量默认为<code>public static final</code>。</p></li><li><p>接口允许多继承接口。类允许继承多个接口。</p></li><li><p>不能<code>new</code>接口，只能通过实现类来创建对象。</p></li><li><p>自我理解，接口更多的使用在为某一个类增加一种或多种特殊能力，而继承更像是一种模板。</p></li><li><p>类中 <code>extends</code> 在 <code>implements</code> 关键字之前。</p></li><li><p>在一些框架中，若直接用子类实现接口对象，则称面向具体编程，应避免这种情况，而采用面向接口编程。</p><h2 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h2><ul><li>通过<code>interfaceName.method()</code>限定调用。无需子类实现。<pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Demo &#123;  public static boolean hasNext() &#123;    return true;  &#125;&#125;</code></pre></li></ul><h2 id="默认方法"><a href="#默认方法" class="headerlink" title="默认方法"></a>默认方法</h2><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Demo &#123;  default boolean hasNext() &#123;    return true;  &#125;&#125;</code></pre><ul><li>通过子类对象调用。无需子类刻意实现。可被子类重写。</li><li>例子：默认方法的使用。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Father &#123;  default void callMe() &#123;    System.out.println(&quot;father&quot;);  &#125;&#125;class Son implements Father &#123;&#125;&#x2F;&#x2F;usenew Son().callMe();&#x2F;&#x2F;out father</code></pre><ul><li>例子：默认方法的重写，由下代码可看出若子类调用父类的方法用<code>Father.super.method()</code>方式。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Father &#123;  default void callMe() &#123;    System.out.println(&quot;father&quot;);  &#125;&#125;class Son implements Father &#123;  @Override  public void callMe() &#123;    Father.super.callMe();    System.out.println(&quot;son&quot;);  &#125;&#125;&#x2F;&#x2F;usenew Son().callMe();&#x2F;&#x2F;out -&gt; father son</code></pre><ul><li>例子：当两个接口中有一样的默认方法时，必须由子类重写。即使一个提供了默认实现，另一个接口仅仅是定义的同名抽象方法。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java">public interface Father &#123;  default void callMe() &#123;    System.out.println(&quot;father&quot;);  &#125;&#125;interface Mother &#123;  default void callMe() &#123;    System.out.println(&quot;mother&quot;);  &#125;&#125;class Son implements Father, Mother &#123;  @Override  public void callMe() &#123;    Father.super.callMe();  &#125;&#125;&#x2F;&#x2F;usenew Son().callMe();Father father &#x3D; new Son();father.callMe();Mother mother &#x3D; new Son();mother.callMe();&#x2F;&#x2F;out -&gt; father father father</code></pre></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
  </entry>
  
  <entry>
    <title>Java复习篇：内部类</title>
    <link href="https://ohbug.cn/post/java/basic/basicjava1.html"/>
    <id>https://ohbug.cn/post/java/basic/basicjava1.html</id>
    <published>2023-01-10T13:06:07.000Z</published>
    <updated>2023-02-02T10:07:00.863Z</updated>
    
    <content type="html"><![CDATA[<div class="custom-quote tip"><span class="custom-quote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M20.86 14.13C20 14.7 19.56 15.74 19.77 16.76C20.13 18.55 18.55 20.13 16.76 19.77C15.74 19.57 14.7 20 14.13 20.86C13.12 22.38 10.89 22.38 9.88 20.86C9.3 20 8.26 19.56 7.24 19.77C5.45 20.13 3.87 18.55 4.23 16.76C4.43 15.74 4 14.7 3.14 14.13C1.62 13.12 1.62 10.89 3.14 9.88C4 9.3 4.44 8.26 4.23 7.24C3.87 5.45 5.45 3.87 7.24 4.23C8.26 4.44 9.3 4 9.87 3.14C10.88 1.62 13.11 1.62 14.12 3.14C14.7 4 15.74 4.44 16.76 4.23C18.55 3.87 20.13 5.45 19.77 7.24C19.56 8.26 20 9.3 20.86 9.87C22.38 10.88 22.38 13.12 20.86 14.13Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M12.01 15C12.01 14.5 12.01 14.5 12.01 14.5C12.04 13.75 13 13.46 14.04 12.2C14.41 11.74 14.69 11.41 14.86 10.85C15.15 9.95 14.92 9.18 14.86 9.02C14.8 8.79 14.52 8 13.72 7.46C13.06 7.02 12.42 7 12.14 7C11.9 7 11.36 7 10.78 7.3C10.28 7.56 9.98 7.9 9.83 8.1C9.24 8.82 9.06 9.63 9 10.06"></path><path stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M11.99 18H12.01"></path></svg></span><p class="custom-quote-title">注意</p><p>  文中实现的代码，均来自于自己参考书中案例并基于Oracle openJDK 17.0.5 版本进行编写实现。<br>  文章欢迎大家评论指正。</p></div><blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>参考：<a href="https://www.cnblogs.com/dolphin0520/p/3811445.html">https://www.cnblogs.com/dolphin0520/p/3811445.html</a>     十分重要</p></blockquote><h1 id="小知识点的收获"><a href="#小知识点的收获" class="headerlink" title="小知识点的收获"></a>小知识点的收获</h1><ul><li>可变长参数就可以理解为数组</li><li>文中的一些说法，accessor访问器方法和mutator更改器方法，说白了mutator更改器方法就是类似list.add()方法，add方法改变了list对象的内容，即被成为更改器方法。而前者accessor就是相反，不改变调用者的对象属性与内容，比如工厂类的实现。</li><li>java所有参数都是值传递，引用对象传递地址值，基本数据类型是值拷贝。</li></ul><h1 id="函数调用的原理"><a href="#函数调用的原理" class="headerlink" title="函数调用的原理"></a>函数调用的原理</h1><ul><li>函数调用是通过栈来实现的，通过出栈和入栈的配合操作来达到函数调用，每次的调用都会分配栈空间来存储参数，局部变量以及返回地址等，从这也就知道函数调用是有成本的，若进行递归操作，数量多的递归层数会造成大量的方法栈压栈，若超出栈空间则会栈溢出，即<code>StackOverflowError</code>错误，会直接导致程序停摆。所以能避免这种进行就应该进行避免。</li></ul><h1 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h1><ul><li>对于所有内部类，越是作用域范围小的地方定义的变量优先级越高。</li></ul><h2 id="静态内部类"><a href="#静态内部类" class="headerlink" title="静态内部类"></a>静态内部类</h2>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  ...  public static class Inner &#123;....&#125;&#125;</code></pre><ul><li>使用，如下两种创建方式</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  private static int name &#x3D; 2;  public static class Inner &#123;    public void test() &#123;     System.out.println(&quot;xxx&quot; + name);    &#125;  &#125; public static void main(String[] args) &#123;  &#x2F;&#x2F;静态内部类对象的两种创建方式    new Inner().test();    new Outter.Inner().test();  &#125;&#125;</code></pre><ul><li>静态内部类除了不可以访问外部类的成员变量和方法，其他与普通类没啥不一样。</li><li>关于<strong>内部类为何可以访问外部类的私有变量</strong>，《Java编程的逻辑》中提到，是通过给私有变量建立了一个非私有的访问方法，在该方法中返回私有变量的值，类似于getter&#x2F;setter方法。<blockquote><span class="custom-blockquote-svg"><svg width="24" height="24" viewBox="0 0 24 24" fill="" xmlns="http://www.w3.org/2000/svg" data-reactroot=""><path fill="" d="M22 12C22 6.5 17.5 2 12 2C6.5 2 2 6.5 2 12C2 17.5 6.5 22 12 22C13.8 22 15.5 21.5 17 20.6L22 22L20.7 17C21.5 15.5 22 13.8 22 12Z" undefined="1"></path><path fill="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z" undefined="1"></path><path fill="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z" undefined="1"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M17 8.5C15.23 8.97 14.07 10.84 14.01 13.27C14 13.33 14 13.4 14 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M9 8.5C7.23 8.97 6.07 10.84 6.01 13.27C6 13.33 6 13.4 6 13.47V13.5"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M15.97 11.5H16.04C17.12 11.5 18 12.38 18 13.47V13.53C18 14.62 17.12 15.5 16.03 15.5H15.96C14.88 15.5 14 14.62 14 13.53V13.46C14 12.38 14.88 11.5 15.97 11.5Z"></path><path stroke-linejoin="round" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" stroke="" d="M7.97 11.5H8.04C9.12 11.5 10 12.38 10 13.47V13.53C10 14.62 9.12 15.5 8.03 15.5H7.97C6.88 15.5 6 14.62 6 13.53V13.46C6 12.38 6.88 11.5 7.97 11.5Z"></path></svg></span><p>由于这里自己就没编译出书上的代码段，则直接引用了书上的结果，之后会补上为什么。@todo P143</p></blockquote></li></ul><h2 id="成员内部类"><a href="#成员内部类" class="headerlink" title="成员内部类"></a>成员内部类</h2>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  ...  public class Inner &#123;....&#125;&#125;</code></pre><ul><li>使用，如下两种方式</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  private String name;  public Outter(String name) &#123;      this.name &#x3D; name;  &#125;  &#x2F;&#x2F; 得到内部类实例的方法一  public Inner getInner(String name) &#123;      return new Inner(name);  &#125;  public class Inner &#123;      private String name;      public Inner(String name) &#123;          this.name &#x3D; name;      &#125;      &#x2F;&#x2F; 判断是否属于一个Outter对象的方法      public boolean belongsTo(Outter obj) &#123;          return Outter.this &#x3D;&#x3D; obj;      &#125;  &#125;  public static void main(String[] args) &#123;      Outter qidai &#x3D; new Outter(&quot;Qidai&quot;);      Inner inner &#x3D; qidai.getInner(&quot;inner&quot;);      System.out.println(inner.belongsTo(qidai));      Outter ohbug &#x3D; new Outter(&quot;ohbug.cn&quot;);      &#x2F;&#x2F;得到内部实力类的方法二      Inner inner2 &#x3D; ohbug.new Inner(&quot;inner2&quot;);      System.out.println(inner2.belongsTo(qidai));  &#125;&#125;&#x2F;&#x2F; output : true false</code></pre><ul><li>成员内部类可以访问外部类的所有内容。</li><li>外部类访问内部类也是一样，但是外部类访问内部类的成员变量时需要创建内部类的对象，通过对象才可以访问，这是因为成员内部类的创建是依赖于外部类的，当有内部类访问外部类的时候，外部类一定先于内部类进行了初始化，所以内部类访问外部类的所有东西都是无条件的，而当外部类访问成员内部类的成员变量时，成员变量必须初始化才使用，即内部类初始化后才可以使用，即外部类引用内部类的变量必须通过内部类对象引用。</li><li>成员内部类中不能存在任何static的变量和方法，个人的理解是内部类要依赖于某一个外部类对象，而static修饰的变量和方法是在编译期就明确下来的，并不能知晓属于某一个外部类对象。但是static final 修饰的变量则为常量，是可以出现的。</li><li>可以看到，成员内部类的实例化是必须依赖一个已经实例化的外部类对象的。代码中展示了创建成员内部类对象的两种方法。  </li><li>由于内部类对象和外部类对象是类似绑定关系，则如上代码中的<code>beblongsTo()</code>方法展示了如何判断两个内部类对象是否属于一个外部类对象。</li><li>成员内部类编译完成后隐含的包含一个指向外部类的引用。通过<code>javap -p target.class</code>可以看到。如下代码。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  private int name &#x3D; 2;  public class Inner &#123;    public void test() &#123;      System.out.println(&quot;xxx&quot; + name);    &#125;  &#125;  public static void main(String[] args) &#123;    Inner inner &#x3D; new Outter().new Inner();    inner.test();  &#125;&#125;</code></pre><ul><li>反编译后为</li></ul>  <pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">shell&gt; javap -p Outter$Inner.class #内部类Compiled from &quot;Outter.java&quot;public class Outter$Inner &#123;      final Outter this$0;             #外部类对象引用，final不可变  public Outter$Inner(Outter);     #从这可以看到，本身代码并没有对Inner构造器初始化，但是Java自动的将Outter的对象传入进行初始化，进行绑定。  public void test();&#125;shell&gt; javap -p Outter.class       #外部类Compiled from &quot;Outter.java&quot;public class Outter &#123;  private int name;  public Outter();  public static void main(java.lang.String[]);&#125;</code></pre><ul><li>对比静态内部类，则没有<code>this$0</code>的引用，以及默认初始化的操作。</li></ul><details class="custom-details"><summary>点击查看静态内部类的代码以及反编译结果。</summary><p><pre><code><pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  private static int name &#x3D; 2;  public static class Inner &#123;    public void test() &#123;      System.out.println(&quot;xxx&quot; + name);    &#125;  &#125;  public static void main(String[] args) &#123;    new Inner().test();  &#125;&#125;</code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">shell&gt; javap -p Outter$Inner.classCompiled from &quot;Outter.java&quot;public class Outter$Inner &#123;  public Outter$Inner();  public void test();&#125;shell&gt; javap -p Outter.classCompiled from &quot;Outter.java&quot;public class Outter &#123;  private static int name;  public Outter();  public static void main(java.lang.String[]);  static &#123;&#125;;&#125;</code></pre></code></pre></p></details><h2 id="方法内部类"><a href="#方法内部类" class="headerlink" title="方法内部类"></a>方法内部类</h2>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Outter &#123;  ...  public void test() &#123;    class Inner &#123;      ...    &#125;  &#125;&#125;</code></pre><ul><li>若<code>test()</code>是实例方法，内部类则可以访问外部类的所有，以及<code>test()</code>方法中被final修饰的变量。</li><li>若<code>test()</code>是静态方法，则内部类只可以访问外部类的静态变量和方法，以及<code>test()</code>方法中被final修饰的变量。</li><li>关于其具体实现，与上面分析的成员内部类十分相似，若是成员方法内部类，一样是存有外部类的对象引用，一样是通过传递构造器参数来初始化成员方法内部类。静态方法内部类类似则没有。</li></ul><h2 id="匿名内部类"><a href="#匿名内部类" class="headerlink" title="匿名内部类"></a>匿名内部类</h2><ul><li><p>常用于监听类函数使用，在Java8中加入的lambda表达式中常用。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">new Panel().addMouseListener(new MouseAdapter() &#123;  @Override  public void mouseClicked(MouseEvent e) &#123;    super.mouseClicked(e);  &#125;&#125;);</code></pre></li><li><p>只能被使用一次，没有类名，没有构造方法。</p></li><li><p>可以使用外部类的所有内容，必须为final修饰。</p></li></ul><h2 id="final修饰"><a href="#final修饰" class="headerlink" title="final修饰"></a>final修饰</h2><ul><li><strong>关于匿名和方法内部类引用变量必须final修饰</strong>，有如下代码，摘自参考文章中。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;  public void test() &#123;    final int a &#x3D; 1;    new Thread()&#123;        public void run() &#123;            ...            System.out.println(a);            ...        &#125;;    &#125;.start();  &#125;&#125;</code></pre><ul><li>当<code>test()</code>方法执行完后，新开线程未必能够执行完成，那么a是如何处理的，a由final修饰，在编译期已经可以确定下来，则Java是将final参数直接复制一份进匿名内部类中。</li></ul>  <pre class="line-numbers language-java" data-language="java"><code class="language-java">public class Test &#123;  public void test(final int a) &#123;    new Thread()&#123;        public void run() &#123;            ...            System.out.println(a);            ...        &#125;;    &#125;.start();  &#125;&#125;</code></pre><ul><li>对于这种编译器并不能确定的参数，回想之前的成员内部类初始化，匿名内部类同样也有外部引用，为达到对匿名类内a的初始化，则在将外部引用传入内部类初始化的同时，会传入参数a的值，即内部类初始化的时候是通过类似<code>Inner(Outter_constructor,int)</code>的方式进行a的内容赋值的。</li><li>对于为何必须final修饰，由于Java是通过拷贝外部变量进内部类中，则两个内外部类的变量是不同的，这样如果内部类对变量进行修改，则内外变量会造成数据的不一样，所以必须是final修饰。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;custom-quote tip&quot;&gt;
&lt;span class=&quot;custom-quote-svg&quot;&gt;&lt;svg width=&quot;24&quot; height=&quot;24&quot; viewBox=&quot;0 0 24 24&quot; fill=&quot;&quot; xmlns=&quot;http://www.w3.o</summary>
      
    
    
    
    <category term="java基础" scheme="https://ohbug.cn/categories/java%E5%9F%BA%E7%A1%80/"/>
    
    
    <category term="java" scheme="https://ohbug.cn/tags/java/"/>
    
    <category term="todo" scheme="https://ohbug.cn/tags/todo/"/>
    
  </entry>
  
  <entry>
    <title>回顾，总结，出发 ！</title>
    <link href="https://ohbug.cn/post/talk/newstart2023.html"/>
    <id>https://ohbug.cn/post/talk/newstart2023.html</id>
    <published>2023-01-07T14:49:24.000Z</published>
    <updated>2023-01-17T10:43:50.138Z</updated>
    
    <content type="html"><![CDATA[<h1 id="回顾"><a href="#回顾" class="headerlink" title="回顾"></a>回顾</h1><p>回想自己中专一路过来到现在的本科，虽然说是本科已然是烂大街的现象，而且是普普通通的二本院校，不过回想起来也是十分的感谢自己遇到过的所有老师，自己好像有幸运加持一般，遇到的老师都或多或少的改变了自己的人生轨迹。</p><p>中专的时候，教室里上课考验的不再是学生的心理素质，而是考验的老师的心理素质。所有人几乎全部在睡觉或者玩手机，老师站在讲台上，手里握着泛黄的课本，认认真真的在讲着，偶尔抽来学生提问，也只是会得到学生的 “我不会” 的回答，老师也没有无奈的表情，或许是已经习惯了。记忆尤新的是我只是上去解了一个方程，下面居然都有惊叹的声音，我不经有些好奇，这有很难么？后来的我开始好好学，当时报的专业是数控机床，加上小时候拆东拆西的动手能力不错，很快就能上手机床，老师也很好，一些在鼓励我，最后快毕业的时候，大家凑钱买来黄铜，老师交给我，让我车一些子弹，当然是实心的，当作纪念品。从此，我的自信心就在这所不大点的学校培养起来了。</p><p>中专毕业后，自己也糊里糊涂的跟着去长城汽车实习了，这哪里是实习，分明是压榨，自己被分配到最底层的车间，每天拉着载满货物的两米多的板车到处走。直到过年回家了，帮家里收拾东西的时候，老妈说了一句，要不你还是再考学吧。</p><p>听从老妈的话，自己又顺利的从中专升入了大专，在这所也是不大点的学校，我收获颇丰。升入大专后，报的是计算机专业，也不知怎的，自己就和身边人在编程上有些差距，感觉编程还是很简单的，但是现在回想起来，谁不会照着书敲代码呢？ 但也就是自己这么一点点优势，后面才进入了老师的办公室，全职在办公室学开发，而且是不用上课的那种！！还有一千多块的工资拿，当时真过的还挺滋润的。后来慢慢的学，从strust2 到spring到后面出现的boot，当时只是会用的地步，之后跟着老师全国跑，涨了眼界，自此也快到了专科毕业，在专科的时候，真的是十分感谢把我招入办公室的老师，虽然我现在把那些技术都要忘得一干二净。</p><p>最后才到了近些年，也很幸运的把握住的升本的机会，来到了一所本科学校学习，到这，我才真正的明显的感觉到本科和专科的同学的不同，大家都开始学了，虽然不是重本，但是这给当时的我带来的感觉是相当有冲击力的。到了本科，依旧是计算机专业，仗着专科的学习，自己感觉相当良好，其实是相当傻逼。就因为这种翘尾巴，导致了我本科阶段的学习都是临时抱佛脚，而且把之前的技术全部抛掷脑后了，两年说完就完，到这自己又好像回到了入学中专的起点，脑子一点东西没剩下。到这依然是2022年了，自己拿到本科毕业证的时候已经24岁了。然后在家备考一年研究生，2023年的今天，我都已经25岁，但仍旧是什么都不是。</p><p>专科到本科之间这段时间，自己参加了培训班，又不满培训班的课程，当时真的是自己都学过就跑回家了，在这是傲娇了第二次，回头想想也真是傻逼。</p><p>吐槽：为什么培训班都教人包装简历，伪造学历来加入程序员这个行列，吃着这碗饭，自己难道都不怕被查吗？这也导致了我之后找公司真是狗都不要。这不是引战，我理解包装行为，谁又跟钱过不去呢。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>到这也算是大概的过了过最近几年，有几点我觉得还真是要提醒自己注意。</p><ol><li>存钱，存到手的才是钱。自己也到了该存钱的年纪了。</li><li>傲娇，这应该是我的致命伤，只要自己稍微了解，自己就会比较轻视这一块东西，以后多加改正。</li><li>考研，希望今年找工作顺利，利用闲暇时间再复习复习，也算是今年的大任务之一了。还有老爸安排的找对象，这个随缘吧。</li><li>今年多多看书，用自己的话总结下来，也希望老铁们看到这，加个收藏，多多支持。</li></ol><h1 id="出发"><a href="#出发" class="headerlink" title="出发"></a>出发</h1><p>最开心的莫过于自己搭建了自己博客网站，现在真是动力满满，一定要把这股劲保持下去。最后了希望自己在今年能回顾之前，总结问题，认真出发。</p><p>也由衷的祝福看到这的老铁们，2023年一帆风顺。</p><p>希望大家多多评论~</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;回顾&quot;&gt;&lt;a href=&quot;#回顾&quot; class=&quot;headerlink&quot; title=&quot;回顾&quot;&gt;&lt;/a&gt;回顾&lt;/h1&gt;&lt;p&gt;回想自己中专一路过来到现在的本科，虽然说是本科已然是烂大街的现象，而且是普普通通的二本院校，不过回想起来也是十分的感谢自己遇到过的所有老师，</summary>
      
    
    
    
    <category term="日常唠叨" scheme="https://ohbug.cn/categories/%E6%97%A5%E5%B8%B8%E5%94%A0%E5%8F%A8/"/>
    
    
    <category term="日常唠叨" scheme="https://ohbug.cn/tags/%E6%97%A5%E5%B8%B8%E5%94%A0%E5%8F%A8/"/>
    
  </entry>
  
</feed>
